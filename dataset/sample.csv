try_body,ArithmeticError,AssertionError,AttributeError,BlockingIOError,BrokenPipeError,ChildProcessError,ConnectionAbortedError,ConnectionError,ConnectionRefusedError,ConnectionResetError,DeprecationWarning,EOFError,FileExistsError,FileNotFoundError,FloatingPointError,FutureWarning,GeneratorExit,ImportError,IndentationError,IndexError,InterruptedError,IsADirectoryError,KeyError,KeyboardInterrupt,LookupError,MemoryError,ModuleNotFoundError,NameError,NotADirectoryError,NotImplementedError,OSError,OverflowError,PermissionError,ProcessLookupError,RecursionError,ReferenceError,RuntimeError,RuntimeWarning,StopAsyncIteration,StopIteration,SyntaxError,SystemError,SystemExit,TimeoutError,TypeError,UnboundLocalError,UnicodeDecodeError,UnicodeEncodeError,UnicodeError,UserWarning,ValueError,Warning,ZeroDivisionError
"
return sys_path.index(entry)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
return vocab.legal_at_bond(bond)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
nonlinearity = {'RNN_TANH': 'tanh', 'RNN_RELU': 'relu'}[rnn_type]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
pointer = getattr(pointer, scope_names[0])
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
cocoDt = cocoGt.loadRes(result_files[res_type])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
response.read()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0
"
cname = replacements[key]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
value = getattr(wrapped, attr)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.remove(cls.path_token)
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
dates.append(datetime(year, MONTH_NUMBERS[month], DAY_NUMBERS[day]))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
img = Image.open(img_path).convert('RGB')
got_img = True
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
attr = object.__getattr__(name)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from nltk.tokenize import word_tokenize
self.word_tokenize = word_tokenize
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import tensorflow as tf
import torch
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
future_mask = future_mask.bool()
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with open(out_file, mode='wb') as f:
    logger.info('Serialize %d results to %s', len(results), out_file)
    pickle.dump(results, f)
pickle.dump(stats_l, open((out_file + '.stats'), 'wb'))
break
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
gt_ob = ground_truth[(object_box_inds[:, 0], object_box_inds[:, 1])]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_vocab_file = cached_path(vocab_file, cache_dir=cache_dir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (model.tokens_embed.weight.shape == init_params[1].shape)
assert (model.positions_embed.weight.shape == init_params[0].shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
for core_idx in range(num_dims):
    curr_core_shape = tt_cores[core_idx].shape
    if (len(curr_core_shape) != len(tt_cores[0].shape)):
        return False
    if (shape is not None):
        for i in range(len(shape)):
            if (curr_core_shape[(i + 1)] != shape[i][core_idx]):
                return False
    if (core_idx >= 1):
        prev_core_shape = tt_cores[(core_idx - 1)].shape
        if (curr_core_shape[0] != prev_core_shape[(- 1)]):
            return False
    if (tt_ranks is not None):
        if (curr_core_shape[0] != tt_ranks[core_idx]):
            return False
        if (curr_core_shape[(- 1)] != tt_ranks[(core_idx + 1)]):
            return False
if ((tt_cores[0].shape[0] != 1) or (tt_cores[(- 1)].shape[(- 1)] != 1)):
    return False
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
os.makedirs(path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
for (i, gpu) in enumerate(GPUtil.getGPUs()):
    o.write(('gpu %d\n' % i))
    for k in ['id', 'driver', 'name', 'memoryTotal']:
        o.write(('\t%s=%s\n' % (k, gpu.__dict__[k])))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
self.assertTrue(self.type.values_eq(f(xv), zv), (f(xv), zv))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
grad_fn = tensor.grad_fn
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with open(file_path, 'r', newline='') as csv_file:
    reader = csv.reader(csv_file, dialect=csv.excel)
    for row in reader:
        network_test_information = row[0]
        inference_class_title = row[1]
        objective_function_class_title = row[2]
        network_test = network_mapping[network_test_information]
        inference_class = inference_mapping[inference_class_title]
        objective_function_class = objective_mapping[objective_function_class_title]
        key = (network_test, inference_class, None, None, objective_function_class, None)
        keys.add(key)
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(loss, P, Ly) = graph.graph_dist(args, plot=False)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.optimizer.load_state_dict(optim_states)
return False
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
full_batch = shape_broadcast(b_shapes)
bdims = len(full_batch)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
token_classification_task_clazz = getattr(module, hparams.task_type)
self.token_classification_task: TokenClassificationTask = token_classification_task_clazz()
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
print('Match from molAtomMapNum {}'.format(atom.GetProp('molAtomMapNumber')))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import ipadic
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
torch._utils._rebuild_tensor_v2
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
next_item = next(sequence)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
line = next(f)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.functions[idx] = class_obj(**opts)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
left_context = spacy_sent_rep[(adj_loc - 1)]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
lr = '{:.5g}'.format(storage.history('lr').latest())
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return self.get(name)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
active_run = (tracking.MlflowClient().get_run(run_id) if (run_id is not None) else None)
if submitted_run_obj.wait():
    _logger.info(""=== Run (ID '%s') succeeded ==="", run_id)
    _maybe_set_run_terminated(active_run, 'FINISHED')
else:
    _maybe_set_run_terminated(active_run, 'FAILED')
    raise ExecutionException((""Run (ID '%s') failed"" % run_id))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
word = idx2word[idx]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
factory = self._registry[type(constraint)]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.top_beam_finished = self.top_beam_finished.bool()
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
index = list(ids).index(tokenizer.EOS_ID)
return subtokenizer.decode(ids[:index])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
import onnxruntime as ort
import tensorrt as trt
from mmcv.tensorrt import onnx2trt, save_trt_engine
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (not ignore_utf_errors):
    with open(f, 'r', encoding='utf-8') as fd:
        self.add_from_file(fd)
else:
    with open(f, 'r', encoding='utf-8', errors='ignore') as fd:
        self.add_from_file(fd)
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
shape_cls = self.SHAPE_CLASSES.get(shape_model['type'], Shape)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import matplotlib.pyplot as plt
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from statsmodels.distributions.empirical_distribution import ECDF
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
__IPYTHON__
USE_COLORS = True
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
img_out_name = next((bn for bn in os.listdir(testset_public) if (img_name in bn)))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (model.tokens_embed.weight.shape == init_params[1].shape)
assert (model.positions_embed.weight.shape == init_params[0].shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
module.__spec__ = spec
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return iter(self.metadata)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
from subword_nmt import apply_bpe
bpe_parser = apply_bpe.create_parser()
bpe_args = bpe_parser.parse_args(['--codes', codes, '--separator', cfg.bpe_separator])
self.bpe = apply_bpe.BPE(bpe_args.codes, bpe_args.merges, bpe_args.separator, None, bpe_args.glossaries)
self.bpe_symbol = (bpe_args.separator + ' ')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
scores = self.score_candidates(batch, cand_vecs)
loss = self.criterion(scores, label_inds)
self.record_local_metric('mean_loss', AverageMetric.many(loss))
loss = loss.mean()
self.backward(loss)
self.update_params()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
selection = 'sele, chain {} and resi {} and name {}'.format(self.chain, atom.get_parent().get_id()[1], atom.get_id()[0])
with silence_stdout(), silence_stderr():
    selections = freesasa.selectArea([selection], sasa_struct, sasa)
    atom_area = selections['sele']
",0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
from apex import amp
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
value = next(it)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(a, b, c) = ap.split('|')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
offset = self.mid_vocabulary[mid]
entity = self._read_entity_from_offset(int(offset))
return entity
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
data[item.key]
continue
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
mesh = trimesh.load(in_pc)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (not (gisfinite(desired) and gisfinite(actual))):
    if (gisnan(desired) or gisnan(actual)):
        if (not (gisnan(desired) and gisnan(actual))):
            raise AssertionError(msg)
    elif (not (desired == actual)):
        raise AssertionError(msg)
    return
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
from .convert_gpt2_original_tf_checkpoint_to_pytorch import convert_gpt2_checkpoint_to_pytorch
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
stderr = '\n'.join(truncate(stderr.decode('utf-8'), max_line_len=200, max_lines=20))
logger.warning('Csmith failed with seed %d: %s', seed, stderr)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0
"
import sentencepiece as spm
self.sp = spm.SentencePieceProcessor()
self.sp.Load(sentencepiece_model)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
stop_timeout = os.getenv('NEPTUNE_STOP_TIMEOUT')
stop_timeout = (int(stop_timeout) if stop_timeout else None)
self._neptune_run.stop(seconds=stop_timeout)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
m['ppl'] = math.exp(m['nll_loss'])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_archive_file = cached_path(archive_file, cache_dir=cache_dir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
repo_dpath = dirname(dirname(__file__))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import numpy as np
import tensorflow as tf
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
mapping = OmegaConf.load(PathManager.get_local_path(abs_f))
f = abs_f
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
examples.append([lhs, rel, rhs, begin, end])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
import re
import numpy as np
import tensorflow as tf
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
setattr(namespace, self.dest, str_to_bool(values))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
return bpe.is_beginning_of_word(tok)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
fd = os.open(file, ((os.O_RDWR | os.O_CREAT) | os.O_EXCL))
",0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from fairseq import libnat
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from transformers import load_tf2_checkpoint_in_pytorch_model
model = load_tf2_checkpoint_in_pytorch_model(model, resolved_archive_file, allow_missing_keys=True)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_vocab_file = cached_path(vocab_file, cache_dir=cache_dir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
args.distributed_rank = distributed_utils.distributed_init(args)
single_process_main(args)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with open(cls.path_token, 'r') as f:
    return f.read()
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import sentencepiece as spm
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
repo_dpath = dirname(dirname(__file__))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
clip.write_gif(filename, verbose=False, progress_bar=False)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
n = _read_array(stream, _np.dtype(len_t), 1)[0]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
batch = torch.ones(()).new_empty((1, *input_res), dtype=next(flops_model.parameters()).dtype, device=next(flops_model.parameters()).device)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (value <= 0):
    raise ValueError(('Attempted to set %s timeout to %s, but the timeout cannot be set to a value less than or equal to 0.' % (name, value)))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
name = cls.name
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
embedder = cls.extract_embedder_from_model(model)
evaluator = cls.build_evaluator(cfg, dataset_name, embedder=embedder)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
x = float(x)
return (nan if ((nan is not None) and (x != x)) else x)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
nonlinearity = {'RNN_TANH': 'tanh', 'RNN_RELU': 'relu'}[rnn_type]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex import amp
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import numpy as np
import tensorflow as tf
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
datetime_series.fillna(method='ffil')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
for epoch in range(start_epoch, num_epochs):
    if args.distributed:
        loader_train.sampler.set_epoch(epoch)
    train_metrics = train_epoch(epoch, model, loader_train, optimizer, args, lr_scheduler=lr_scheduler, saver=saver, output_dir=output_dir, amp_autocast=amp_autocast, loss_scaler=loss_scaler, model_ema=model_ema, neptune=neptune)
    if (args.distributed and (args.dist_bn in ('broadcast', 'reduce'))):
        if (args.local_rank == 0):
            logging.info('Distributing BatchNorm running means and vars')
        distribute_bn(model, args.world_size, (args.dist_bn == 'reduce'))
    if (model_ema is not None):
        if (args.distributed and (args.dist_bn in ('broadcast', 'reduce'))):
            distribute_bn(model_ema, args.world_size, (args.dist_bn == 'reduce'))
        eval_metrics = validate(model_ema.ema, loader_eval, args, evaluator, log_suffix=' (EMA)', neptune=neptune)
    else:
        eval_metrics = validate(model, loader_eval, args, evaluator, neptune=neptune)
    if args.neptune:
        neptune.log_metric('valid/mAP', eval_metrics[eval_metric])
    if (lr_scheduler is not None):
        lr_scheduler.step((epoch + 1), eval_metrics[eval_metric])
    if (saver is not None):
        update_summary(epoch, train_metrics, eval_metrics, os.path.join(output_dir, 'summary.csv'), write_header=(best_metric is None))
        (best_metric, best_epoch) = saver.save_checkpoint(epoch=epoch, metric=eval_metrics[eval_metric])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import tensorflow_datasets as tfds
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return super().__getattr__(name)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return (obj.__array_ufunc__ is None)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return operator.index(x)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
ver = float(winreg.EnumValue(bkey, i)[0])
if (ver not in vc_vers):
    vc_vers.append(ver)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
return super(BaseLearner, self).__getattr__(attr)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (pointer.shape == array.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
file_name = DatasetCatalog.get('coco_2017_train')[0]['file_name']
if (not PathManager.exists(file_name)):
    raise FileNotFoundError()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with open(('%s%s.txt' % (data_dir, data_type)), 'r') as f:
    data = f.read().strip().split('\n')
    data = [i.split('\t') for i in data if (len(i.split('\t')) == 3)]
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
param = signature(func).parameters
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
from pybind11_tests.eigen import have_eigen
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
importlib.import_module(name)
return (lambda x: x)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import kwarray
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
expr_parse(instring, tmploc, doActions=False, callPreParse=False)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import re
import numpy as np
import tensorflow as tf
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex import amp
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
images = torch.cat(images).float().unsqueeze(1)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.annotation = Annotation()
self.annotation.fromJsonFile(filename)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return self._dirindex
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
durations.append(durations_dict[key])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return mpmath.hyp1f1(a, b, x)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1
"
import torch
import tensorflow as tf
from tensorflow.python.keras import backend as K
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
d = dict(inspect.signature(cls._func).parameters)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
import sentencepiece as spm
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
encoding = encoding.decode('ascii')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0
"
with open(temp_file_path, 'w'):
    pass
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from tokenizers import ByteLevelBPETokenizer
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.mkdir(targetpath, 448)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.mkdir(os.path.join(args.aachen_path, ('%s_kpts' % args.experiment_name), 'query'))
",0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
data = ds.ImageFolderDataset(DATA_DIR)
data = data.map(operations=exception_func, input_columns=['image'], num_parallel_workers=1)
for _ in data.__iter__():
    pass
assert False
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
ious = bbox_iou(image_pred_class[i].unsqueeze(0), image_pred_class[(i + 1):], device)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
mp.set_start_method('spawn')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(action, args) = parse_utt_with_world(gen_utt, world)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
t(C.T, A[:2, :], B[:, :2].T)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
return '{:.2f}'.format(math.pow(2, loss))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
print('start training the VAE...')
self.train()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex import amp
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from sacremoses import MosesTokenizer, MosesDetokenizer
self.tok = MosesTokenizer(args.moses_source_lang)
self.detok = MosesDetokenizer(args.moses_target_lang)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return list(map(x_type, x))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
test_stats_list[k].append((float(v) * 100))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
tnr = (float(tn) / (tn + fp))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1
"
import re
import numpy as np
import tensorflow as tf
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
sample[k] = ds.collater([s[k] for s in samples])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import pyarrow.plasma as plasma
self._plasma = plasma
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import wandb
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
fn = ('%s/solutions_%d.png' % (outputDirectory, iteration))
visualizeSolutions(result.taskSolutions, fn, train)
eprint(('Exported solutions to %s\n' % fn))
dreamOfTowers(result.grammars[(- 1)], ('%s/random_%d' % (outputDirectory, iteration)))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import re
import numpy as np
import tensorflow as tf
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
left_position_embeddings = self.x_position_embeddings(bbox[:, :, 0])
upper_position_embeddings = self.y_position_embeddings(bbox[:, :, 1])
right_position_embeddings = self.x_position_embeddings(bbox[:, :, 2])
lower_position_embeddings = self.y_position_embeddings(bbox[:, :, 3])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (pointer.shape == array.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
_valid_extensions = set(val.split(','))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
while ((self.state['i_epoch'] < self.params['runner']['n_epochs']) and (not self.termination_check())):
    self.state['i_cycle'] = 0
    while (self.state['i_cycle'] < self.params['runner']['n_cycles']):
        with KeepTime('/'):
            with KeepTime('demo'):
                chunk = self.explorer['demo'].update()
                with KeepTime('store'):
                    self.memory['demo'].store(chunk)
        self.state['i_cycle'] += 1
    self.state['i_epoch'] += 1
    self.monitor_epoch()
    self.log()
    gc.collect()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0
"
(scores, predictions) = self.translator.translate(texts_to_translate, batch_size=(len(texts_to_translate) if (self.opt.batch_size == 0) else self.opt.batch_size))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
loaded_model = torch.jit.load('traced_model.pt')
os.remove('traced_model.pt')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
call(['nvcc'], stdout=DEVNULL, stderr=DEVNULL)
return True
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_archive_file = cached_path(archive_file, cache_dir=cache_dir, force_download=force_download, resume_download=resume_download, proxies=proxies)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(ls_x, ls_y) = visible['left_shoulder']
(rs_x, rs_y) = visible['right_shoulder']
(mid_shoulder_x, mid_shoulder_y) = (((ls_x + rs_x) / 2), ((ls_y + rs_y) / 2))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (pointer.shape == array.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
out = _minimal_ext_cmd(['git', 'rev-parse', 'HEAD'])
sha = out.strip().decode('ascii')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
hsplit(a, 2)
assert_(0)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
tokenizer = MecabTokenizer(mecab_dic='unidic_lite')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
dc = ((2.0 * intersection) / float((size_i1 + size_i2)))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1
"
for _ in range(self.chunk_size):
    chunk.append(next(self.itr))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex.parallel import DistributedDataParallel as DDP
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
f = DatasetCatalog._REGISTERED[name]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
out = _minimal_ext_cmd(['git', 'rev-parse', 'HEAD'])
sha = out.strip().decode('ascii')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import Mykytea
self.ja_word_tokenizer = Mykytea.Mykytea(('-model %s/local/share/kytea/model.bin' % os.path.expanduser('~')))
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
mode = Split[mode]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
model.learn(self.n_timesteps, **kwargs)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import wandb
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (cur_stats['kl'] < min_dist):
    min_dist = cur_stats['kl']
    argmin_dist = file
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return super(self.__class__, self).__getattribute__(item)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import numpy as np
import tensorflow.compat.v1 as tf
import tensorflow_hub as hub
import tensorflow_text
tf.disable_eager_execution()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
iv1 = gof.op.get_test_value(inputs[1])
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
readahead[sequence] = bool(val)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
self.assertGradientChecks(gc, op, inputs, i, [0])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
bypass = proxy_bypass(parsed.hostname)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
edge = self._road_id_to_edge[waypoint.road_id][waypoint.section_id][waypoint.lane_id]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
data = datetime.strptime(text, '%B %Y')
return (True, (data.year, data.month, None))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
image_name = base_bench['image_name']
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
z.__name__ = f.__name__
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(yield operand.infer_unary_op(self.op))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
clustering_index = self.faiss.index_cpu_to_all_gpus(self.faiss.IndexFlatIP(self.index_ivf.d))
self.index.clustering_index = clustering_index
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(self.path_save_solDATA)
",0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.remove((eICU_path + 'preprocessed_timeseries.csv'))
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if prepend_batch_axis:
    value = [value]
tensor = as_tensor(value)
if (tensor.ndim > 2):
    tensor = tensor.squeeze(0)
elif (tensor.ndim < 2):
    tensor = tensor[None, :]
batch_outputs[key] = tensor
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
iter(data[0])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
return int(x)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
import apex
apex.amp.register_half_function(torch, 'einsum')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
c = chr(int(h, 16))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
(line, field) = line.rstrip().rsplit(' ', 1)
if (field == '#fairseq:overwrite'):
    overwrite = True
    (line, field) = line.rsplit(' ', 1)
else:
    overwrite = False
count = int(field)
word = line
if ((word in self) and (not overwrite)):
    raise RuntimeError(""Duplicate word found when loading Dictionary: '{}'. Duplicate words can overwrite earlier ones by adding the #fairseq:overwrite flag at the end of the corresponding row in the dictionary file. If using the Camembert model, please download an updated copy of the model file."".format(word))
self.add_symbol(word, n=count, overwrite=overwrite)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
assert (list(symbolic_weight.shape) == list(array.shape))
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
HyperParameters(params)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import re
import numpy as np
import tensorflow as tf
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
calcx4[sequence] = bool(val)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
os.remove(file)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
all_best_covariances = np.zeros((n_best_tot, n_features, n_features))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
mod = importlib.import_module((('parlai.tasks.' + task) + '.build'))
file_list = mod.RESOURCES
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
n_qr = numpy.linalg.qr(a, 'complete')
f = function([A], qr(A, 'complete'))
t_qr = f(a)
assert _allclose(n_qr, t_qr)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
return safe_round((base ** loss), round)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
nuisance_parameter_names = f['nuisance_parameters/names'][()]
nuisance_parameter_systematics = f['nuisance_parameters/systematics'][()]
nuisance_parameter_benchmarks_pos = f['nuisance_parameters/benchmark_positive'][()]
nuisance_parameter_benchmarks_neg = f['nuisance_parameters/benchmark_negative'][()]
nuisance_parameter_names = _decode(nuisance_parameter_names)
nuisance_parameter_systematics = _decode(nuisance_parameter_systematics)
nuisance_parameter_benchmarks_pos = _decode(nuisance_parameter_benchmarks_pos)
nuisance_parameter_benchmarks_neg = _decode(nuisance_parameter_benchmarks_neg)
nuisance_parameter_benchmarks_neg = [(None if (val == '') else val) for val in nuisance_parameter_benchmarks_neg]
nuisance_parameters = OrderedDict(zip(nuisance_parameter_names, zip(nuisance_parameter_systematics, nuisance_parameter_benchmarks_pos, nuisance_parameter_benchmarks_neg)))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
mask_color = [(x / 255) for x in self.metadata.stuff_colors[category_idx]]
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
st['key'] = 2.1
assert False, 'cannot change type of value for set keys'
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
float(s)
return True
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
nice = self.__nice__()
classname = self.__class__.__name__
return f'<{classname}({nice}) at {hex(id(self))}>'
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
tensor.id = response_ids.pop((- 1))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import pytest
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
lres.fun = lres.fun[0]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
self.accept(listener)
continue
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.anin2_msg.data = o['analogIn2']
self.pub_anin2 = True
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.chflags(dst, st.st_flags)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
cur_ppl = f'{math.exp(cur_loss):8.2f}'
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (not os.path.exists(newdir)):
    os.makedirs(newdir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with PathManager.open(video_fpath, 'rb') as io:
    container = av.open(io)
    stream = container.streams.video[video_stream_idx]
    frames = []
    for pts in keyframes:
        try:
            container.seek(pts, any_frame=False, stream=stream)
            frame = next(container.decode(video=0))
            frames.append(frame)
        except av.AVError as e:
            logger = logging.getLogger(__name__)
            logger.warning(f'Read keyframes: Error seeking video file {video_fpath}, video stream {video_stream_idx}, pts {pts}, AV error: {e}')
            container.close()
            return frames
        except OSError as e:
            logger = logging.getLogger(__name__)
            logger.warning(f'Read keyframes: Error seeking video file {video_fpath}, video stream {video_stream_idx}, pts {pts}, OS error: {e}')
            container.close()
            return frames
        except StopIteration:
            logger = logging.getLogger(__name__)
            logger.warning(f'Read keyframes: Error decoding frame from {video_fpath}, video stream {video_stream_idx}, pts {pts}')
            container.close()
            return frames
    container.close()
    return frames
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
pronoun_data = pickle.load(dataint)
ref_sen_len = len(pronoun_data['reference_sentence'])
ref_con_len = len(pronoun_data['reference_context'])
if ((ref_con_len - ref_sen_len) <= 0):
    continue
pos_context_input = [pronoun_data['reference_context']]
pos_sentence_input = []
pos_context_pids = get_pronoun_idx(pronoun_data['reference_context'], pronoun_list)
pos_sentenceonly_pids = get_pronoun_idx(pronoun_data['reference_sentence'], pronoun_list)
pos_sentence_pids = pos_context_pids[(- len(pos_sentenceonly_pids)):]
pos_pronoun_input = [pos_sentence_pids]
neg_context = pronoun_data['reference_context'][:(- ref_sen_len)]
neg_context.extend(pronoun_data['noisy_sentence'])
neg_context_pids = get_pronoun_idx(neg_context, pronoun_list)
neg_sentenceonly_pids = get_pronoun_idx(pronoun_data['noisy_sentence'], pronoun_list)
neg_sentence_pids = neg_context_pids[(- len(neg_sentenceonly_pids)):]
neg_context_input = [neg_context]
neg_sentence_input = []
neg_pronoun_input = [neg_sentence_pids]
try:
    neg_score = net.forward(neg_context_input, neg_sentence_input, neg_pronoun_input, 1)
    pos_score = net.forward(pos_context_input, pos_sentence_input, pos_pronoun_input, 1)
except:
    print(pronoun_data)
    raise
if (pos_score > neg_score):
    pos += 1
elif (pos_score == neg_score):
    tie += 1
elif (neg_score > pos_score):
    neg += 1
",0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (not (float(self.years).is_integer() and float(self.months).is_integer())):
    raise ValueError('fractional years or months not supported for date calculations')
newmonth = (other.month - self.months)
(carry, newmonth) = fquotmod(newmonth, 1, 13)
newyear = ((other.year - self.years) + carry)
maxdays = max_days_in_month(newyear, newmonth)
if (other.day > maxdays):
    newday = maxdays
else:
    newday = other.day
newdt = other.replace(year=newyear, month=newmonth, day=newday)
return (newdt - self.tdelta)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import re
import numpy as np
import tensorflow as tf
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.comm.close()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return ((float(self.num_incorrect_words) * 100.0) / self.num_words)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1
"
system = load_system(source_dir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.id2children[parent_id].remove(id)
if (not self.id2children[parent_id]):
    self.id2children.pop(parent_id)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
meth = getattr(visitor, visit_attr)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
__import__(module_name)
module = sys.modules[module_name]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
u = getattr(self.module, (self.name + '_u'))
v = getattr(self.module, (self.name + '_v'))
w = getattr(self.module, (self.name + '_bar'))
return True
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
t_xz0 = batch_data['t_xz0'].to(self.device, self.dtype, non_blocking=True)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
j = word.index(first, i)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
u = getattr(self.module, (self.name + '_u'))
v = getattr(self.module, (self.name + '_v'))
w = getattr(self.module, (self.name + '_bar'))
return True
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
quat = (rel_quat * Quaternion(obj[k]))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
passage_evidence[(int((evi * 100)) - 2)] = 1
passage_evidence_nodes.append('<p{}>'.format((int((evi * 100)) - 1)))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
while True:
    try:
        example = self.data_buffer.pop(0)
    except IndexError:
        break
    self.batch.append(self.convert_example_to_feature(example))
    if (len(self.batch) >= self.batch_size):
        break
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return _os_sendfile(fdout, fdin, offset, nbytes)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import re
import numpy as np
import tensorflow as tf
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
model.load_state_dict(state_dict=torch.load(model_path))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert torch.allclose(attention1, attention2.float(), atol=0.0001, rtol=1e-05)
assert torch.allclose(context1, context2.float(), atol=0.0001, rtol=1e-05)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
user_paths = os.environ['PYTHONPATH'].split(os.pathsep)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
try:
    sys.argv[0] = script_name
    if (script_args is not None):
        sys.argv[1:] = script_args
    with open(script_name, 'rb') as f:
        exec(f.read(), g)
finally:
    sys.argv = save_argv
    _setup_stop_after = None
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0
"
self.pixels[y][x] = min(color, 255)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
response = requests.head(url, allow_redirects=True, proxies=proxies)
if (response.status_code != 200):
    etag = None
else:
    etag = response.headers.get('ETag')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
f_iter = iter(field)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
from apex.normalization import FusedLayerNorm
return FusedLayerNorm(normalized_shape, eps, elementwise_affine)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import torch
import tensorflow as tf
from tensorflow.python.keras import backend as K
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (attr not in ambiguous_functions)
response_hook_function = hook_method_response_functions[attr_id]
new_response = response_hook_function(response)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from_config_func = type(self).from_config
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(valid_inds, exs) = zip(*[(i, ex) for (i, ex) in enumerate(observations) if valid(ex)])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
import numpy as np
import tensorflow as tf
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
typeobj = self.type()
dictoffset = int_from_int(typeobj.field('tp_dictoffset'))
if (dictoffset != 0):
    if (dictoffset < 0):
        type_PyVarObject_ptr = gdb.lookup_type('PyVarObject').pointer()
        tsize = int_from_int(self._gdbval.cast(type_PyVarObject_ptr)['ob_size'])
        if (tsize < 0):
            tsize = (- tsize)
        size = _PyObject_VAR_SIZE(typeobj, tsize)
        dictoffset += size
        assert (dictoffset > 0)
        assert ((dictoffset % _sizeof_void_p()) == 0)
    dictptr = (self._gdbval.cast(_type_char_ptr()) + dictoffset)
    PyObjectPtrPtr = PyObjectPtr.get_gdb_type().pointer()
    dictptr = dictptr.cast(PyObjectPtrPtr)
    return PyObjectPtr.from_pyobject_ptr(dictptr.dereference())
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
np.save(os.path.join(path, name), code, allow_pickle=False)
trying = False
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.td.cleanup()
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.remove('access.log')
os.remove('error.log')
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from fairseq.data.data_utils_fast import batch_by_size_fast
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return (""CAST(STRFTIME('%s', %s) AS INTEGER)"" % (self.extract_map[extract.field], self.process(extract.expr, **kw)))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import pyarrow.plasma as plasma
self._plasma = plasma
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
tokenizer = MecabTokenizer(do_lower_case=True, normalize_text=False, mecab_option='-d /usr/local/lib/mecab/dic/jumandic')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
source_point_idx = np.random.choice(source_point_cands.shape[0])
source_point = (source_point_cands[source_point_idx][0], source_point_cands[source_point_idx][1], np.random.choice(h3d.angles))
t3 = time()
(target_x, target_y, target_yaw) = target_point
source_continous = h3d.env.house.to_coor(source_point[0], source_point[1], shft=True)
target_continous = h3d.env.house.to_coor(target_x, target_y, shft=True)
points_queue = []
distances_source = dict()
prev_pos = dict()
distances_source[source_point] = 0
prev_pos[source_point] = ((- 1.0), (- 1.0), (- 1.0), (- 1.0), (- 1.0))
source_point = (source_point[0], source_point[1], source_point[2], source_continous[0], source_continous[1])
heappush(points_queue, (heuristic_estimate(source_continous, target_continous), source_point))
while True:
    if (len(points_queue) == 0):
        count_path_not_found += 1
        logging.info('A* not able to find path to target')
        raise ValueError('Path not found to target {} {}'.format(source_point[:3], target_point))
    (f_dist, point) = heappop(points_queue)
    add_neighbors(h3d, points_queue, point, distances_source, prev_pos, target_continous)
    if ((point[0] == target_x) and (point[1] == target_y) and (point[2] == target_yaw)):
        shortest_path_nodes = []
        while True:
            shortest_path_nodes.append(point)
            point = prev_pos[point[:3]]
            if (point[0] == (- 1)):
                break
        shortest_path_nodes.reverse()
        break
t4 = time()
logging.info('Time spent for coupled graph generation and A*: {:.6f}s'.format((t4 - t3)))
(act_q, pos_q, coord_q, actual_q) = ([], [], [], [])
episode_images = []
movemap = None
for i in range((len(shortest_path_nodes) - 1)):
    u = shortest_path_nodes[i]
    v = shortest_path_nodes[(i + 1)]
    pos_q.append((float(u[3]), 1.0, float(u[4]), float(u[2])))
    coord_q.append(h3d.env.house.to_grid(u[3], u[4]))
    (curr_x, curr_y, curr_yaw) = (u[3], u[4], u[2])
    (next_x, next_y, next_yaw) = (v[3], v[4], v[2])
    if (curr_yaw != next_yaw):
        if ((next_yaw == 171) and (curr_yaw == (- 180))):
            act_q.append(1)
        elif ((next_yaw == (- 180)) and (curr_yaw == 171)):
            act_q.append(2)
        elif (next_yaw < curr_yaw):
            act_q.append(1)
        else:
            act_q.append(2)
    else:
        act_q.append(0)
pos_q.append((shortest_path_nodes[(- 1)][3], 1.0, shortest_path_nodes[(- 1)][4], shortest_path_nodes[(- 1)][2]))
act_q.append(3)
if args.check_validity:
    h3d.env.reset(x=pos_q[0][0], y=pos_q[0][2], yaw=pos_q[0][3])
    h3d_yaw = pos_q[0][3]
    actual_q.append((float(h3d.env.cam.pos.x), 1.0, float(h3d.env.cam.pos.z), float(h3d.env.cam.yaw)))
    for (i, action) in enumerate(act_q[:(- 1)]):
        pre_pos = [h3d.env.cam.pos.x, h3d.env.cam.pos.z, h3d.env.cam.yaw]
        (img, _, episode_done) = h3d.step(action)
        episode_images.append(img)
        post_pos = [h3d.env.cam.pos.x, h3d.env.cam.pos.z, h3d.env.cam.yaw]
        actual_q.append((float(h3d.env.cam.pos.x), 1.0, float(h3d.env.cam.pos.z), float(h3d.env.cam.yaw)))
        if all([(np.abs((pre_pos[x] - post_pos[x])) < 1e-09) for x in range(3)]):
            raise ValueError('Invalid action')
        angle_delta = (post_pos[2] - pre_pos[2])
        h3d_yaw = ((((h3d_yaw + 180) + angle_delta) % 360) - 180)
        assert (np.abs((h3d.env.cam.pos.x - pos_q[(i + 1)][0])) < 0.001)
        assert (np.abs((h3d.env.cam.pos.z - pos_q[(i + 1)][2])) < 0.001)
        assert (h3d_yaw == pos_q[(i + 1)][3])
    count_valid += 1
    movemap = h3d.env.house._showMoveMap(visualize=False)
    logging.info('Valid')
result = {'actions': act_q, 'actual_q': actual_q, 'answer': q['answer'], 'coordinates': coord_q, 'images': episode_images, 'movemap': movemap, 'positions': pos_q, 'question': q['question']}
with open(os.path.join(args.shortest_path_dir, '{}_{}.pkl'.format(h, q['id'])), 'wb') as f:
    pickle.dump(result, f)
    logging.info('Saved {}_{}.pkl'.format(h, q['id']))
    logging.info('Length of shortest path: {}'.format(len(shortest_path_nodes)))
    shortest_path_lengths.append(len(shortest_path_nodes))
count_path_found += 1
break
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
line = next(self.random_file).strip()
if (line == ''):
    self.current_random_doc = (self.current_random_doc + 1)
    line = next(self.random_file).strip()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
dist.script_args.remove('--help-fcompiler')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
os.makedirs(dir_path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return bpe.is_beginning_of_word(tok)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
content.index(NO_COPYRIGHT_LINE)
return True
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
self._validate_sample(value)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
return [self.protocol_parser[x] for x in filenames]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import fastBPE
self.bpe = fastBPE.fastBPE(codes)
self.bpe_symbol = '@@ '
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
nn.utils.remove_weight_norm(module)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
target_state[mono_name].copy_(val)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
num_tokens_vec = self.num_tokens_vec(indices).astype('int64')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with open(filepath) as fp:
    return self._parse_distro_release_content(fp.readline())
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
for token in name.split('.'):
    if (rval is None):
        rval = d[token]
    else:
        rval = getattr(rval, token)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return list(map(type, x))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
self.vocab[word] += 1
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import re
import numpy as np
import tensorflow as tf
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import regex as re
self.re = re
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (self.__fp != self.fp):
    self.__fp.close()
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from keras_contrib.layers.normalization import InstanceNormalization
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
repo_dpath = dirname(dirname(__file__))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
ratio = (float(translation_length) / reference_length)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1
"
(x, y) = next(self.iter)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
key = names.index(key)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
version = tuple(map(int, torchvision.__version__.split('.')[:2]))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
return [STR_TO_TOKEN[lexeme] for lexeme in lexemes]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if ((time.time() - worker.tmp.last_update()) <= self.timeout):
    continue
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
stack_var = tf.get_default_graph().get_tensor_by_name(('module_apply_default/stack_%d:0' % i))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
exp = Explorer(**vars(args))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
tup = (numberized_row_tuple + (self._get_token_logits(row[self.start_logits_column], row[self.pad_mask_column]), self._get_token_logits(row[self.end_logits_column], row[self.pad_mask_column]), row[self.has_answer_logits_column]))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_archive_file = cached_path(archive_file, cache_dir=cache_dir, force_download=force_download, proxies=proxies)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.set_clip_path(self.axes.patch)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (p_i.shape == arr_i.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(name)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import kwarray
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (pointer.shape == array.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
db = apsw.Connection(':memory:')
db.createscalarfunction('foo', (lambda x: b('another string')))
for row in db.cursor().execute('select foo(3)'):
    pass
(1 / 0)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (not ignore_utf_errors):
    with open(f, 'r', encoding='utf-8') as fd:
        self.add_from_file(fd)
else:
    with open(f, 'r', encoding='utf-8', errors='ignore') as fd:
        self.add_from_file(fd)
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return next(self.parameters()).device
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
my_func = getattr(self, func.__name__)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return f.readline()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0
"
from mpi4py import MPI
rand_seed = ((rand_seed - (rand_seed % MPI.COMM_WORLD.size)) + MPI.COMM_WORLD.rank)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
SharedVariable(name='u', type=Tensor(broadcastable=[False], dtype='float64'), value=dict(), strict=False)
assert 0
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
from apex import amp
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from fairseq import libnat
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
sock.connect((probe_addr, 1))
ip_addr = sock.getsockname()[0]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
self._record.add_value(PluginEnum.IMAGE.value, 'input_data/auto', input_data)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0
"
assert chainer.backends.cuda.cudnn_enabled
logging.info('--> cudnn is available in chainer.')
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from fairseq.modules.dynamicconv_layer import DynamicconvLayer
return DynamicconvLayer(input_size, kernel_size=kernel_size, padding_l=padding_l, num_heads=num_heads, weight_dropout=weight_dropout, weight_softmax=weight_softmax, bias=bias)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
names = os.listdir(dirname)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return obj.isoformat()
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
tensorized_scalar = torch.tensor(scalars).cuda()
output_tensors = [tensorized_scalar.clone() for _ in range(torch.distributed.get_world_size())]
torch.distributed.all_gather(output_tensors, tensorized_scalar)
concat = torch.cat(output_tensors, dim=0)
if (num_total_examples is not None):
    concat = concat[:num_total_examples]
return concat
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
font = {'weight': 'normal', 'size': 18}
matplotlib.rc('font', **font)
fig = plt.figure(figsize=(30, 24))
ax = fig.add_subplot(111)
ax2 = ax.twinx()
x_values = list(range((self.epoch + 1)))
ax.plot(x_values, self.all_tr_losses, color='b', ls='-', label='loss_tr')
ax.plot(x_values, self.all_val_losses, color='r', ls='-', label='loss_val, train=False')
if (len(self.all_val_losses_tr_mode) > 0):
    ax.plot(x_values, self.all_val_losses_tr_mode, color='g', ls='-', label='loss_val, train=True')
if (len(self.all_val_eval_metrics) == len(x_values)):
    ax2.plot(x_values, self.all_val_eval_metrics, color='g', ls='--', label='evaluation metric')
ax.set_xlabel('epoch')
ax.set_ylabel('loss')
ax2.set_ylabel('evaluation metric')
ax.legend()
ax2.legend(loc=9)
fig.savefig(join(self.output_folder, 'progress.png'))
plt.close()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
task.step()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return accimage.Image(path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
sig = inspect.signature(self.__init__)
classname = type(self).__name__
argstr = []
for (name, param) in sig.parameters.items():
    assert ((param.kind != param.VAR_POSITIONAL) and (param.kind != param.VAR_KEYWORD)), ""The default __repr__ doesn't support *args or **kwargs""
    assert hasattr(self, name), 'Attribute {} not found! Default __repr__ only works if attributes match the constructor.'.format(name)
    attr = getattr(self, name)
    default = param.default
    if (default is attr):
        continue
    argstr.append('{}={}'.format(name, pprint.pformat(attr)))
return '{}({})'.format(classname, ', '.join(argstr))
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(self.next_input, self.next_target) = next(self.loaditer)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
checkpoint_suffix = args.model_name.split('/')[(- 1)].split('-')
if (len(checkpoint_suffix) > 2):
    checkpoint_suffix = checkpoint_suffix[1]
else:
    checkpoint_suffix = checkpoint_suffix[(- 1)]
global_step = int(checkpoint_suffix)
epochs_trained = (global_step // (len(train_dataloader) // args.gradient_accumulation_steps))
steps_trained_in_current_epoch = (global_step % (len(train_dataloader) // args.gradient_accumulation_steps))
logger.info('   Continuing training from checkpoint, will skip to saved global_step')
logger.info('   Continuing training from epoch %d', epochs_trained)
logger.info('   Continuing training from global step %d', global_step)
logger.info('   Will skip the first %d steps in the current epoch', steps_trained_in_current_epoch)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
from mmcv.ops import get_onnxruntime_op_path
ort_custom_op_path = get_onnxruntime_op_path()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
class_names = MetadataCatalog.get(dataset_name).thing_classes
check_metadata_consistency('thing_classes', dataset_name)
print_instances_class_histogram(dicts, class_names)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self._current_line = next(self._lines)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (self.num_workers != self._num_workers):
    self.num_workers = self._num_workers
    self.logger.info(f'Enabling {self.num_workers} workers for data loading...')
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
while (n_filled < self.bptt):
    if ((streams[i] is None) or (len(streams[i]) <= 1)):
        streams[i] = next(sent_stream)
    n_new = min((len(streams[i]) - 1), (self.bptt - n_filled))
    data[(n_retain + n_filled):((n_retain + n_filled) + n_new), i] = streams[i][:n_new]
    target[n_filled:(n_filled + n_new), i] = streams[i][1:(n_new + 1)]
    streams[i] = streams[i][n_new:]
    n_filled += n_new
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
height = segm.shape[0]
width = segm.shape[1]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from fairseq.modules.dynamicconv_layer import DynamicconvLayer
return DynamicconvLayer(input_size, kernel_size=kernel_size, padding_l=padding_l, num_heads=num_heads, weight_dropout=weight_dropout, weight_softmax=weight_softmax, bias=bias)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return mgw.local_rank(*args)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
subtype = pyarrow.from_numpy_dtype(self.dtype.subtype)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
open(os.path.join(localpath, 'test.write'), 'wb').close()
os.remove(os.path.join(localpath, 'test.write'))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
collapsed.append(self.collapse_indices_ndim(subtensor, merge_repeats))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
return [self.protocol_parser[x] for x in filenames]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_archive_file = cached_path(archive_file, cache_dir=cache_dir)
resolved_config_file = cached_path(config_file, cache_dir=cache_dir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if ('jieba' not in sys.modules):
    import jieba
else:
    jieba = sys.modules['jieba']
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import sentencepiece as spm
self.sp = spm.SentencePieceProcessor()
self.sp.Load(vocab)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
ft = build_features(inpt, inpt['entities'][interaction[0]], inpt['entities'][interaction[1]], nlp)
features.append(ft)
targets.append(inpt['predicates'][i][0])
i += 1
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
nice = self.__nice__()
classname = self.__class__.__name__
return f'<{classname}({nice}) at {hex(id(self))}>'
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
lr = '{:.5g}'.format(storage.history('lr').latest())
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex import amp
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
selected_tissues = random.sample(list(tissue_dataloader_dict), k=12)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
import fvcore
data.append(('fvcore', fvcore.__version__))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_model_file = cached_path(model_file, cache_dir=cache_dir)
resolved_config_file = cached_path(config_file, cache_dir=cache_dir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
img = imread(path)[:, :, :3]
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
spacy_model = spacy.load(spacy_model_name, disable=disable)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(iid, aid, is_present, cid, utime) = line.decode('ascii').strip().split()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
from apex import amp
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
data_time = storage.history('data_time').avg(20)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
fd = int(fileobj.fileno())
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0
"
resolved_archive_file = cached_path(archive_file, cache_dir=cache_dir, force_download=force_download, proxies=proxies, resume_download=resume_download, local_files_only=local_files_only)
if (resolved_archive_file is None):
    raise EnvironmentError
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.impl = _GetchWindows()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
line = f.readline()
break
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0
"
network = self.model.network[signal_type]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
assert (pointer.shape == array.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if isinstance(model, ElectraForMaskedLM):
    name = name.replace('electra/embeddings/', 'generator/embeddings/')
if (discriminator_or_generator == 'generator'):
    name = name.replace('electra/', 'discriminator/')
    name = name.replace('generator/', 'electra/')
name = name.replace('dense_1', 'dense_prediction')
name = name.replace('generator_predictions/output_bias', 'generator_lm_head/bias')
name = name.split('/')
if any(((n in ['global_step', 'temperature']) for n in name)):
    logger.info('Skipping {}'.format(original_name))
    continue
pointer = model
for m_name in name:
    if re.fullmatch('[A-Za-z]+_\\d+', m_name):
        scope_names = re.split('_(\\d+)', m_name)
    else:
        scope_names = [m_name]
    if ((scope_names[0] == 'kernel') or (scope_names[0] == 'gamma')):
        pointer = getattr(pointer, 'weight')
    elif ((scope_names[0] == 'output_bias') or (scope_names[0] == 'beta')):
        pointer = getattr(pointer, 'bias')
    elif (scope_names[0] == 'output_weights'):
        pointer = getattr(pointer, 'weight')
    elif (scope_names[0] == 'squad'):
        pointer = getattr(pointer, 'classifier')
    else:
        pointer = getattr(pointer, scope_names[0])
    if (len(scope_names) >= 2):
        num = int(scope_names[1])
        pointer = pointer[num]
if m_name.endswith('_embeddings'):
    pointer = getattr(pointer, 'weight')
elif (m_name == 'kernel'):
    array = np.transpose(array)
try:
    assert (pointer.shape == array.shape), f'Pointer shape {pointer.shape} and array shape {array.shape} mismatched'
except AssertionError as e:
    e.args += (pointer.shape, array.shape)
    raise
print('Initialize PyTorch weight {}'.format(name), original_name)
pointer.data = torch.from_numpy(array)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
mean = self.mean(etas).item()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
iter(size)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
poll_obj = select.poll()
_retry_on_intr(poll_obj.poll, 0)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
y = self._base.predict_proba(x)
if (y.shape[1] == 2):
    y = y[:, 1]
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import Mykytea
self.ja_word_tokenizer = Mykytea.Mykytea(('-model %s/local/share/kytea/model.bin' % os.path.expanduser('~')))
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return toks[index]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
pointer = getattr(pointer, l[0])
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import nltk
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import sentencepiece as spm
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(g, W) = GENERATOR_FUNCTIONS['ErdosRenyi'](self.edge_density, self.n_vertices)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import sentencepiece as spm
self.sp = spm.SentencePieceProcessor()
self.sp.Load(sentencepiece_model)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
log_interval = max((len(iterator) // 20), 10)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
o.print_profile(stream, prof, (level + 2))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return self.__dep_map
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from mmcv.onnx.symbolic import register_extra_symbolics
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
float_value = float(value)
int_value = int(float(value))
if (float_value != int_value):
    raise ValueError
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
next(self.data_generator)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
frame = FRAMES[(i % len(FRAMES))]
color = COLORS[(i % len(COLORS))]
i += 1
sys.stdout.write(CLEAR_SCREEN)
sys.stdout.write(color)
sys.stdout.write('\n\n    ')
sys.stdout.write(frame.replace('\n', '\n    '))
sys.stdout.write(COLORS[(((i * 3) + 1) % len(COLORS))])
sys.stdout.write('\n\n              P A R T Y    P A R R O T\n')
sys.stdout.write(RESET)
time.sleep((75 / 1000))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
err_msg = 'Inference tensors do not track version counter'
with self.assertRaisesRegex(RuntimeError, err_msg):
    tensor._version
return True
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
proc = subprocess.Popen(cmd, env=env)
proc.wait()
exitcode = proc.returncode
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
u = getattr(self.module, (self.name + '_u'))
v = getattr(self.module, (self.name + '_v'))
w = getattr(self.module, (self.name + '_bar'))
return True
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
classifier = classify.MaxentClassifier.train(TRAIN, algorithm, trace=0, max_iter=1000)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(tensorboard)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.__root
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with open(str((Path.home() / '.configs_dir.txt')), 'rb') as f:
    configs_dir = f.readline().decode('utf8').strip()
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
nn.utils.remove_weight_norm(module)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
predictions = mmcv.load(result_files[metric])
if (iou_type == 'segm'):
    for x in predictions:
        x.pop('bbox')
    warnings.simplefilter('once')
    warnings.warn('The key ""bbox"" is deleted for more accurate mask AP of small/medium/large instances since v2.12.0. This does not change the overall mAP calculation.', UserWarning)
cocoDt = cocoGt.loadRes(predictions)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from .convert_tf_checkpoint_to_pytorch import convert_tf_checkpoint_to_pytorch
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(cmd, data) = remote.recv()
if (cmd == 'step'):
    (observation, reward, done, info) = env.step(data)
    if done:
        info['terminal_observation'] = observation
        observation = env.reset()
    remote.send((observation, reward, done, info))
elif (cmd == 'reset'):
    observation = env.reset()
    remote.send(observation)
elif (cmd == 'render'):
    remote.send(env.render(*data[0], **data[1]))
elif (cmd == 'close'):
    remote.close()
    break
elif (cmd == 'get_spaces'):
    remote.send((env.observation_space, env.action_space))
elif (cmd == 'env_method'):
    method = getattr(env, data[0])
    remote.send(method(*data[1], **data[2]))
elif (cmd == 'get_attr'):
    remote.send(getattr(env, data))
elif (cmd == 'set_attr'):
    remote.send(setattr(env, data[0], data[1]))
else:
    raise NotImplementedError
",0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(psuedo_imgs, pseudo_texts) = next(self.pseudo_dataloader_iter)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
shape = trn_data.data.shape
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
location_string = (((results_folder + 'netG_') + str(epoch)) + '_fc1.0_ngf120_ndf120_dep5-5_WGAN.pth')
gen_network.load_state_dict(torch.load(location_string))
print(location_string)
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return klass(data)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0
"
message['text'] = 'rofl'
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
lvis_dt = LVISResults(lvis_gt, result_files[metric])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex import amp
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
i2file = np.loadtxt('img2.csv', delimiter=',')
self.images2 = int(i2file.shape[0])
self.Xraw = torch.cat((torch.Tensor(ifile.reshape(self.images, sz, sy, sx)), torch.Tensor(i2file.reshape(self.images2, sz, sy, sx))))
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
offsets.indices[offset]
return offset
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import numpy as np
import tensorflow as tf
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if torchscript:
    print('Tracing model with sequence size', sequence.shape)
    inference = torch.jit.trace(model, sequence)
    inference(sequence)
else:
    inference = model
    inference(sequence)
print('Going through model with sequence of shape', sequence.shape)
runtimes = timeit.repeat((lambda : inference(sequence)), repeat=average_over, number=3)
average_time = ((sum(runtimes) / float(len(runtimes))) / 3.0)
dictionary[model_name]['results'][batch_size][slice_size] = average_time
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import kwarray
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
g_PathManager.register_handler(handler)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import nltk
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.mask = self.mask.bool()
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
axis = self._validate_number_sequence(kwargs['axis'], 3)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (cur_stats['kl'] < min_dist):
    min_dist = cur_stats['kl']
    argmin_dist = file
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
for (line_no, line) in enumerate(fd, 1):
    line = transform(line)
    strippedline = line.split('#', 1)[0].strip()
    if (not strippedline):
        continue
    tup = strippedline.split(':', 1)
    if (len(tup) != 2):
        _log.warning('Missing colon in file %r, line %d (%r)', fname, line_no, line.rstrip('\n'))
        continue
    (key, val) = tup
    key = key.strip()
    val = val.strip()
    if (key in rc_temp):
        _log.warning('Duplicate key in file %r, line %d (%r)', fname, line_no, line.rstrip('\n'))
    rc_temp[key] = (val, line, line_no)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0
"
if (len(val) > 19):
    if (val[19] == '.'):
        if (val[(- 1)].upper() == 'Z'):
            subsecondval = val[20:(- 1)]
            tzval = 'Z'
        else:
            subsecondvalandtz = val[20:]
            if ('+' in subsecondvalandtz):
                splitpoint = subsecondvalandtz.index('+')
                subsecondval = subsecondvalandtz[:splitpoint]
                tzval = subsecondvalandtz[splitpoint:]
            elif ('-' in subsecondvalandtz):
                splitpoint = subsecondvalandtz.index('-')
                subsecondval = subsecondvalandtz[:splitpoint]
                tzval = subsecondvalandtz[splitpoint:]
            else:
                tzval = None
                subsecondval = subsecondvalandtz
        if (tzval is not None):
            tz = TomlTz(tzval)
        microsecond = int((int(subsecondval) * (10 ** (6 - len(subsecondval)))))
    else:
        tz = TomlTz(val[19:])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
self.corpus = io.open(corpus_path, 'r', encoding='utf-8')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
tzoffset = int(tz)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
y = (x + x)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from fairseq import libnat
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
addr = socket.gethostbyname(rawHost)
if (addr != rawHost):
    host.append(addr)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import re
import numpy as np
import tensorflow as tf
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return infer_dtype_from_object(getattr(np, dtype))
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
value = ast.literal_eval(value)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
number = float(strNumber)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
base_name = node_name[:(- 1)]
suffix = str((int(node_name[(- 1)]) + 1))
return (base_name + suffix)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
assert (pointer.shape == array.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
global fused_adam_cuda
import importlib
fused_adam_cuda = importlib.import_module('fused_adam_cuda')
return FusedAdamV1
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import cupy
print(f'[x] cupy={cupy.__version__}')
try:
    from cupy.cuda import nccl
    print('[x] cupy nccl')
except ImportError:
    print('[ ] cupy nccl')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
j = word.index(first, i)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
archive.extractall(path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
batch = next(iterator)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
true_score_position = self.cur_perf['interpolation_fnc'](perf_frame)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
return next(self.itr)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
del p_dic[node1_value][node2_value]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
lr = '{:.6f}'.format(storage.history('lr').latest())
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
checkpoint_suffix = args.model_name_or_path.split('-')[(- 1)].split('/')[0]
global_step = int(checkpoint_suffix)
epochs_trained = (global_step // (len(train_dataloader) // args.gradient_accumulation_steps))
steps_trained_in_current_epoch = (global_step % (len(train_dataloader) // args.gradient_accumulation_steps))
logger.info('  Continuing training from checkpoint, will skip to saved global_step')
logger.info('  Continuing training from epoch %d', epochs_trained)
logger.info('  Continuing training from global step %d', global_step)
logger.info('  Will skip the first %d steps in the first epoch', steps_trained_in_current_epoch)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
PathManager.mkdirs(cache_path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(directory)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return c(lhs, rhs)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
hash(val)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
from spacy.lang.en import English
spacy_nlp._nlp = English()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
label = line[(- 1)]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with open(filename, 'wb') as fp:
    pickle.dump(dtset, fp)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
w = self.idx2token(i)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
import cityscapesscripts.helpers.labels as CSLabels
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
original_filter = getattr(self, original_filter_name)
return self.negate_filter(original_filter, initial_set)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
p = getattr(m, buffer_name)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import cityscapesscripts.evaluation.evalInstanceLevelSemanticLabeling as CSEval
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import ftfy
import spacy
self.nlp = spacy.load('en', disable=['parser', 'tagger', 'ner', 'textcat'])
self.fix_text = ftfy.fix_text
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
data = next(self._train_data_loader_iter)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import pyarrow.plasma as plasma
self._plasma = plasma
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
start_time = row['start_time']
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
token = tokens[i.i]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_config_file = cached_path(config_file, cache_dir=cache_dir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (pointer.shape == array.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
theta.load_state_dict(w.module.state_dict())
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with open(filename, mode='rb') as config_file:
    exec(compile(config_file.read(), filename, 'exec'), d.__dict__)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
int(s)
return True
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
writer.add_histogram(tag, np.array(val), it)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
sd = torch.load(path, map_location='cpu')['state_dict']
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with open(filename, mode) as f:
    pass
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
format = EXTENSION[ext]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
httpd.serve_forever()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import re
import numpy as np
import tensorflow as tf
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
sort = inferType(term, lib)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
from transformers import load_tf2_checkpoint_in_pytorch_model
model = load_tf2_checkpoint_in_pytorch_model(model, resolved_archive_file, allow_missing_keys=True)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
mol = Chem.MolFromSmiles(smiles)
features = []
(atom_features, atom_descriptors) = (None, None)
if (self.features_generator is not None):
    for fg in self.features_generator:
        features_generator = get_features_generator(fg)
        if ((mol is not None) and (mol.GetNumHeavyAtoms() > 0)):
            features.extend(features_generator(mol))
    features = np.array(features)
if (len(features) == 0):
    features = None
if (features is not None):
    replace_token = 0
    features = np.where(np.isnan(features), replace_token, features)
if (self.atom_descriptors == 'feature'):
    atom_features = self.get_atom_features(smiles)
elif (self.atom_descriptors == 'descriptor'):
    atom_descriptors = self.get_atom_descriptors(smiles)
smiles_all.append(smiles)
x_all.append([features, atom_features, atom_descriptors])
if isinstance(label, np.ndarray):
    y_all.append(label)
else:
    y_all.append([label])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
import cpuinfo
info = cpuinfo.get_cpu_info()
cpu_info['cpu_info'] = info['brand']
cpu_info['mhz_per_cpu'] = (info['hz_advertised_raw'][0] / 1000000.0)
run_info['machine_config']['cpu_info'] = cpu_info
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
word_list = voc[0][1].base_field.vocab.itos
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from transformers.data.processors.squad import SquadV1Processor
self.processor = SquadV1Processor()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
item.load_state_dict(item_state)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
if (filename == '-'):
    lines = codecs.StreamReaderWriter(sys.stdin, codecs.getreader('utf8'), codecs.getwriter('utf8'), 'replace').read().split('\n')
else:
    lines = codecs.open(filename, 'r', 'utf8', 'replace').read().split('\n')
carriage_return_found = False
for linenum in range(len(lines)):
    if lines[linenum].endswith('\r'):
        lines[linenum] = lines[linenum].rstrip('\r')
        carriage_return_found = True
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
for (p, avg_p) in zip(module.parameters(), avg_param):
    p.data.copy_(avg_p)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
result = factory(**kwargs)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
seperators = Separator(word=' ', phone='')
phonemes = phonemize(text, separator=seperators, backend='espeak', language=language)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
for attr in args.attr.split('.'):
    if attr.isdigit():
        attr = int(attr)
    indict = indict[attr]
print(indict)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
chunk_left = self._read_next_chunk_size()
if (chunk_left == 0):
    break
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
codec = lookup(encoding)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
z2_symmetries = self._gsc.transformation.molecule_info['z2_symmetries']
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
text_a = line[3]
text_b = line[4]
label = line[5]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
shutil.rmtree(rm_dir)
break
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
for attr in args.attr.split('.'):
    if attr.isdigit():
        attr = int(attr)
    indict = indict[attr]
print(indict)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.bias = Parameter(linear.bias.data.clone())
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
_ = self.unnecessary_tags.index(child.tag)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
module = importlib.import_module(('parlai.scripts.' + script_name))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
checkpoint_suffix = args.model_name_or_path.split('-')[(- 1)].split('/')[0]
global_step = int(checkpoint_suffix)
epochs_trained = (global_step // (len(train_dataloader) // args.gradient_accumulation_steps))
steps_trained_in_current_epoch = (global_step % (len(train_dataloader) // args.gradient_accumulation_steps))
logger.info('  Continuing training from checkpoint, will skip to saved global_step')
logger.info('  Continuing training from epoch %d', epochs_trained)
logger.info('  Continuing training from global step %d', global_step)
logger.info('  Will skip the first %d steps in the first epoch', steps_trained_in_current_epoch)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
pointer = getattr(pointer, scope_names[0])
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
ex_to_add._used_vars = set((used for used in expression._used_vars))
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
response = requests.head(url, allow_redirects=True, proxies=proxies, timeout=etag_timeout)
if (response.status_code != 200):
    etag = None
else:
    etag = response.headers.get('ETag')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return (is_path_exists(pathname) or is_path_creatable(pathname))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import tensorflow_datasets as tfds
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
array = np.reshape(saved_weight_value, K.int_shape(symbolic_weight))
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(images, targets) = next(batch_iterator)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
while (len(fields) > 0):
    value = re.sub(',$', '', fields.pop().strip())
    key = fields.pop()
    parsed_string[key.strip()] = value.strip()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
height = segm.shape[0]
width = segm.shape[1]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(yield)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(log_dir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return hashlib.md5(msg).hexdigest()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
return models.__dict__[configs['arch']]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
fp = self.open_local_file(url1)
hdrs = fp.info()
fp.close()
return (url2pathname(splithost(url1)[1]), hdrs)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
result = me.compute_action(x_tilde, act, vocab=self.vocab)
break
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
(inputs, labels) = next(iterator)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
processor = processors[data_args.task_name]()
label_list = processor.get_labels()
num_labels = len(label_list)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with open(temp_file_path, 'w'):
    pass
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (model.tokens_embed.weight.shape == init_params[1].shape)
assert (model.positions_embed.weight.shape == init_params[0].shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
iterator = iter(first_field)
first_field_iterator = True
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
import apex
apex.amp.register_half_function(torch, 'einsum')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (len(pred_val) == len(current_data[start_idx:end_idx]))
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.compiler.compiler_so.remove('-Wstrict-prototypes')
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
from nltk.tokenize import word_tokenize
self.word_tokenize = word_tokenize
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (not self._module.batch_first):
    raise ConfigurationError('Our encoder semantics assumes batch is always first!')
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
batch_outputs[key] = tf.constant(value)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
cocoDt = cocoGt.loadRes(result_files[metric])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
bb = workspace.FetchBlob(name)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
return self._strat_ids_to_specs[strat_id]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
while True:
    (img_path, label_path, height, width) = next(f).strip().split()
    print(img_path)
    label_path = ('./data/' + label_path)
    h = int(height)
    w = int(width)
    (bbs, labels, bbs_ignore, labels_ignore) = _load_gt(label_path, h, w, min_scale_percen)
    if (bbs.size == 0):
        continue
    roidb = {'filename': img_path, 'width': w, 'height': h, 'ann': {'bboxes': bbs.astype(np.float32), 'labels': labels.astype(np.int64), 'bboxes_ignore': bbs_ignore.astype(np.float32), 'labels_ignore': labels_ignore.astype(np.int64)}}
    if is_valid(roidb):
        _roidb.append(roidb)
        cnt += 1
    if ((cnt % 100) == 0):
        print('processed {}'.format(cnt))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with open(str(filename), 'rb') as f:
    obj = pickle.load(f)
",0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
x = attack.send(result)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (pointer.shape == array.shape), f'Pointer shape {pointer.shape} and array shape {array.shape} mismatched'
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return mapping[key]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from transformers import GPT2Config, GPT2LMHeadModel
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
gpu_rank = distributed.multi_init(device_id, args.world_size, args.gpu_ranks)
print(('gpu_rank %d' % gpu_rank))
if (gpu_rank != args.gpu_ranks[device_id]):
    raise AssertionError('An error occurred in                   Distributed initialization')
train_abs_single(args, device_id)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(ver, data) = data.split(b',', 1)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
nn.utils.remove_weight_norm(module)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
repo_dpath = dirname(dirname(__file__))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
tzoffset = int(tz)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
last_lr = self.lr_scheduler.get_last_lr()[0]
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
for i in range(1, (num_jobs + 1)):
    os.remove('{0}/{1}.{2}.raw'.format(dir, (iter + 1), i))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
grid_shape = agent.mdp.original_shape
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
isEqual = np.allclose(self.q, other.q, rtol=r_tol, atol=a_tol)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
act = {'id': 'safeLocalHuman', 'label_candidates': None, 'episode_done': False, 'text': str(turn_each)}
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return self.data[item]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
scores = utils.rouge_all(hyps, refer)
pairs['hyps'].append(hyps)
pairs['refer'].append(refer)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
line1.encode('latin1')
line2.encode('latin1')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0
"
import sentencepiece as spm
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(subject, property, value, _) = line
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
init.constant_(m.bias, 0)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(_, line) = next(audio_data)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (list(pt_weight.shape) == list(array.shape))
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
p_object = (self if (id(p_object) == self.box_org_ref) else BoxList(p_object))
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
t(C.T, A[:2, :], B[:, :2].T)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
resolved_archive_file = cached_path(archive_file)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (hasattr(val, 'fgraph') and (val.type == ret.type)):
    return val
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return self.metadata[key]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
wl = self._en_wordlist
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return self._move_towards((r, c), obs.actions)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
h = hd(pred, target, voxelspacing)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
optimizer_state_dict = torch.load(os.path.join(opt.start_from, 'optimizer.pth'))
if (len(optimizer_state_dict['state']) > 0):
    optimizer.load_state_dict(torch.load(os.path.join(opt.start_from, 'optimizer.pth')))
else:
    print('Optimizer state dict has empty state, using new optimizer.')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import regex as re
self.re = re
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return (value == float(value))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
tokenizer = MecabTokenizer(mecab_dic='unidic_lite')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self._gcd_import(from_name)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
scores = [x['score'] for x in sinfo]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (p_i.shape == arr_i.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with open(f, 'r', encoding='utf-8') as fd:
    self.add_from_file(fd)
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return float(s)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
repo_dpath = dirname(dirname(__file__))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
for name in attribute['attributes']:
    names.add(name)
attribute_name_counter.update(names)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
cache.popitem(False)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with maybe_no_sync():
    (loss, sample_size, logging_output) = self.task.train_step(sample, self.model, self.criterion, self.optimizer, ignore_grad)
if (not ignore_grad):
    logging_outputs.append(logging_output)
    sample_sizes.append(sample_size)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
pointer = getattr(pointer, l[0])
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_vocab_files = {}
for (file_id, file_path) in vocab_files.items():
    if (file_path is None):
        resolved_vocab_files[file_id] = None
    else:
        resolved_vocab_files[file_id] = cached_path(file_path, cache_dir=cache_dir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import nltk
assert (valid['nltk_bleu1'] > 0.9)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
end = context.index('__null__')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
if (len(actions) == self.num_envs):
    listify = False
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
with io.open(file, 'r', encoding='utf-8') as f:
    original = f.readlines()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
iterator = iter(first_field)
first_field_iterator = True
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
value = next(self._iterator)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (pointer.shape == array.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.remove(fname)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if torchscript:
    print('Tracing model with sequence size', sequence.shape)
    inference = torch.jit.trace(model, sequence)
    inference(sequence)
else:
    inference = model
    inference(sequence)
if (not no_memory):
    trace = start_memory_tracing('transformers')
    inference(sequence)
    summary = stop_memory_tracing(trace)
    if verbose:
        print_summary_statistics(summary)
    dictionary[model_name]['memory'][batch_size][slice_size] = str(summary.total)
else:
    dictionary[model_name]['memory'][batch_size][slice_size] = 'N/A'
if (not no_speed):
    print('Going through model with sequence of shape', sequence.shape)
    runtimes = timeit.repeat((lambda : inference(sequence)), repeat=average_over, number=3)
    average_time = ((sum(runtimes) / float(len(runtimes))) / 3.0)
    dictionary[model_name]['results'][batch_size][slice_size] = average_time
else:
    dictionary[model_name]['results'][batch_size][slice_size] = 'N/A'
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
i = obs_know.index(checked_sentence)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
response = requests.head(url, allow_redirects=True, proxies=proxies, timeout=etag_timeout)
if (response.status_code == 200):
    etag = response.headers.get('ETag')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
get_client(self.master_address)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0
"
from apex import amp
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if isinstance(expected, tuple):
    self.assertLen(actual, len(expected))
    for (expected_item, actual_item) in zip(expected, actual):
        self.assertIndexExpressionEqual(expected_item, actual_item)
elif isinstance(expected, (list, np.ndarray)):
    np.testing.assert_array_equal(expected, actual)
else:
    self.assertEqual(expected, actual)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
fd = open(file_or_fd, 'w')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
change_points = map((lambda x: int(x.strip())), values)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
import re
import numpy as np
import tensorflow as tf
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
obj = torch.load(ckp_path, map_location=(lambda storage, loc: storage.cuda()))
logger.info(('Load checkpoint %s' % ckp_path))
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import cityscapesscripts.evaluation.evalInstanceLevelSemanticLabeling as CSEval
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
module = sys.modules[moduleOrReq]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
negloglikelihood = F.nll_loss(F.log_softmax(logit, dim=1).view((- 1), 1), label)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import psutil
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
p = p.relative_to(Path('.').resolve())
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
resolved_vocab_file = cached_path(vocab_file, cache_dir=cache_dir)
resolved_merges_file = cached_path(merges_file, cache_dir=cache_dir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
embedding_table[v] = vectors[word2idx[k]]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (p_i.shape == arr_i.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
f_iter = iter(field)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
mask_color = [(x / 255) for x in self.metadata.stuff_colors[label]]
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(w, V) = numpy.linalg.eig(M33)
i = numpy.where((abs((numpy.real(w) - factor)) < 1e-08))[0][0]
direction = numpy.real(V[:, i]).squeeze()
direction /= vector_norm(direction)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
min_row = min([r for r in my_rows if (r >= b)])
b_start = block_allocs[min_row].start
cuda_memcpy2d_async(dst=whole_col_b.data_ptr(), dpitch=(max_block_size * dts), src=A[(b_start, bb.start)].data_ptr(), spitch=(A.shape[1] * dts), width=(bb.length * dts), height=(N - b_start), stream=s1_cuda)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
from apex.parallel import DistributedDataParallel as DDP
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_archive_file = cached_path(archive_file, cache_dir=cache_dir)
resolved_config_file = cached_path(config_file, cache_dir=cache_dir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from fairseq.modules.lightconv_layer import LightconvLayer
return LightconvLayer(input_size, kernel_size=kernel_size, padding_l=padding_l, num_heads=num_heads, weight_dropout=weight_dropout, weight_softmax=weight_softmax, bias=bias)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex import amp
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (pointer.shape == array.shape), f'Pointer shape {pointer.shape} and array shape {array.shape} mismatched'
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
sizeval2 = float(size2)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
preds.remove(pred)
succs.remove(succ)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
new_directives = Options.parse_directive_list(directives_string, ignore_unknown=True)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
numpy_include = np.get_include()
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
labels = np.array(self.targets)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
z.__name__ = f.__name__
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
auc_val = roc_auc_score(labels.cpu(), torch.sigmoid(class_pred).cpu())
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
self.func = _binary_ops_dict[op]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
classname = classpath
module = __import__(hint, globals(), locals(), [classname])
return getattr(module, classname)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from transformers.convert_xlnet_original_tf_checkpoint_to_pytorch import convert_xlnet_checkpoint_to_pytorch
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from __main__ import __requires__
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import tensorflow_datasets as tfds
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
data.append(('torchvision', ((str(torchvision.__version__) + ' @') + os.path.dirname(torchvision.__file__))))
if has_cuda:
    try:
        torchvision_C = importlib.util.find_spec('torchvision._C').origin
        msg = detect_compute_compatibility(CUDA_HOME, torchvision_C)
        data.append(('torchvision arch flags', msg))
    except ImportError:
        data.append(('torchvision._C', 'failed to find'))
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
h = self.activation_function((F.linear(theta, torch.t(self.Wx)) + F.linear(x, torch.t((self.Ms[0] * self.Ws[0])), self.bs[0])))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
shutil.rmtree(os.path.join(datapath, 'models/unittest'))
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
np = npath.index(nloc, (p + 1))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
parser.add_argument('--depth', dest='depth', type=int, default=defaults.DEPTH)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
n_batches = len(data_loader)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
self.preprocessor = sklearn.preprocessing.PowerTransformer(method=self.method, standardize=self.standardize, copy=False)
self.preprocessor.fit(X, Y)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
from nltk.tokenize import word_tokenize
self.word_tokenize = word_tokenize
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
img = np.float32(images)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
print(((('Downloading ' + url) + ' to ') + fpath))
urllib.request.urlretrieve(url, fpath, reporthook=gen_bar_updater())
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
response = requests.head(url, allow_redirects=True, proxies=proxies, timeout=etag_timeout)
if (response.status_code != 200):
    etag = None
else:
    etag = response.headers.get('ETag')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
scores = trainer.train_epochs(settings.epochs, devset=devset)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
pointer = getattr(pointer, scope_names[0])
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
shared_batch = next(shared_iterator)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
delattr(_MovedItems, name)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import cityscapesscripts.evaluation.evalInstanceLevelSemanticLabeling as CSEval
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
while 1:
    model = model.module
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(filename, label) = line.split(',')
label = label.strip('\n')
with open(os.path.join(img_dir, filename), 'rb') as file_reader:
    img = file_reader.read()
data_json = {'id': i, 'file_name': filename, 'data': img, 'label': int(label)}
data_list.append(data_json)
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
accu = ((tp + tn) / (((tp + tn) + fp) + fn))
precision = (tp / (tp + fp))
recall = (tp / (tp + fn))
f_score = (((2 * precision) * recall) / (precision + recall))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1
"
global fused_adam_cuda
import importlib
fused_adam_cuda = importlib.import_module('fused_adam_cuda')
return FusedAdamV1
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return self.known_modules[fullname]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
state = torch.load(checkpoint_fname)
model.load_state_dict(state['model'])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
job: SubprocessArgs = self.worker_endpoint.recv()
",0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
model = self.torch.hub.load('facebookresearch/WSL-Images', self.image_mode)
self.netCNN = self.nn.Sequential(*list(model.children())[:(- 1)])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.bias = Parameter(conv.bias.data.clone())
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import numpy as np
import tensorflow as tf
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return list(map(type, x))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
loss = (loss + (metrics.reg.mean * g.reg_hyper))
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
potential_date_string = str(Date.make_date(cell_value))
if (potential_date_string != '-1'):
    cell_data['date'] = cell_value
    column_name_type_mapping[column_name].add('date')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
float(cell_parts[0])
float(cell_parts[1])
cell_data['number'] = cell_parts[0]
cell_data['num2'] = cell_parts[1]
column_name_type_mapping[column_name].add('number')
column_name_type_mapping[column_name].add('num2')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
result_dir_path.mkdir(parents=True)
",0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
rec = (TP / (TP + FN))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1
"
output_label.append(tokenizer.vocab[token])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import numexpr as ne
visualized_image = ne.evaluate('img * (1 - alpha / 255.0) + rgb * (alpha / 255.0)')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import nltk
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
shutil.copy(f, gt_nifti_folder)
success = True
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
metrics = trainer.train()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (pointer.shape == array.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
stats = os.stat(localname)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
for e in range(self.nepochs):
    clock0 = time.time()
    self.train_epoch(t, xtrain, ytrain)
    clock1 = time.time()
    (train_loss, train_acc) = self.eval(t, xtrain, ytrain, args)
    clock2 = time.time()
    print('| Epoch {:3d}, time={:5.1f}ms/{:5.1f}ms | Train: loss={:.3f}, acc={:5.1f}% |'.format((e + 1), (((1000 * self.sbatch) * (clock1 - clock0)) / xtrain.size(0)), (((1000 * self.sbatch) * (clock2 - clock1)) / xtrain.size(0)), train_loss, (100 * train_acc)), end='')
    (valid_loss, valid_acc) = self.eval(t, xvalid, yvalid, args)
    print(' Valid: loss={:.3f}, acc={:5.1f}% |'.format(valid_loss, (100 * valid_acc)), end='')
    if (valid_loss < best_loss):
        best_loss = valid_loss
        best_model = utils.get_model(self.model)
        patience = self.lr_patience
        print(' *', end='')
    else:
        patience -= 1
        if (patience <= 0):
            lr /= self.lr_factor
            print(' lr={:.1e}'.format(lr), end='')
            if (lr < self.lr_min):
                print()
                break
            patience = self.lr_patience
            self.optimizer = self._get_optimizer(lr)
    print()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
lookup_tuple = (participant, str(Action(label_id).name), '', '', score)
kb_boost = (self.kb.prob_of(process_id, lookup_tuple) if (participant and (label_id >= 0) and (process_id >= 0)) else 1.0)
kb_boosts[parti_id] = (1.0 if (math.isnan(kb_boost) or (kb_boost < 0.0)) else kb_boost)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
for (node_index, node) in ast.nodes.items():
    if (node.node_type in method_node_type):
        function_name_idx = node_index
        if (func_name is not None):
            if (func_name == ''):
                function_name_idx = (- 1)
                break
            else:
                while True:
                    if (function_name_idx >= len(ast.nodes)):
                        function_name_idx = None
                        break
                    if ((ast.nodes[function_name_idx].value == func_name) and (ast.nodes[function_name_idx].node_type == method_name_node_type)):
                        break
                    function_name_idx += 1
        else:
            while True:
                if (function_name_idx >= len(ast.nodes)):
                    function_name_idx = None
                    break
                if (ast.nodes[function_name_idx].node_type == method_name_node_type):
                    break
                function_name_idx += 1
        if (function_name_idx is None):
            raise ValueError(f'Could not find function name {func_name} in sample. Abandoning sample')
        sample = __collect_sample(ast, node_index, args, language, function_name_idx=function_name_idx)
        if (sample is not None):
            samples.append(sample)
            break
        else:
            raise ValueError(f'No code2seq paths were generated for sample {func_name}')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
m.clear_buffer()
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from mmdet.version import __version__
sha = __version__.split('+')[(- 1)]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
best_val_loss = math.inf
best_val_acc = 0
for epoch in range(config['hyperparameters']['epochs']):
    self.epoch = epoch
    self.train(model, lossfunction, optimizer, train_iter, config)
    log_results = (epoch > 5)
    (train_loss, train_acc, _) = self.validate(model, lossfunction, train_iter, config, log_results=False)
    (validation_loss, validation_acc, val_acc_per_level) = self.validate(model, lossfunction, dev_iter, config, log_results=False)
    sorted_val_acc_pl = sorted(val_acc_per_level.items(), key=(lambda x: int(x[0])))
    if (validation_loss < best_val_loss):
        best_val_loss = validation_loss
    if (validation_acc > best_val_acc):
        best_val_acc = validation_acc
    logging.info(f'Epoch {epoch}, Training loss|acc: {train_loss:.6f}|{train_acc:.6f}')
    logging.info(f'Epoch {epoch}, Validation loss|acc: {validation_loss:.6f}|{validation_acc:.6f} - (Best {best_val_loss:.4f}|{best_val_acc:4f})')
    logging.debug(f'Epoch {epoch}, Validation loss|acc: {validation_loss:.6f}|{validation_acc:.6f} - (Best {best_val_loss:.4f}|{best_val_acc:4f})')
    logging.debug('\n'.join([f'{k} - {v:.2f}' for (k, v) in sorted_val_acc_pl]))
    if (validation_acc > self.save_treshold):
        model.to(torch.device('cpu'))
        torch.save(model, f'saved/checkpoint_{str(self.__class__)}_ACC_{validation_acc:.5f}_{get_timestamp()}.pt')
        model.to(device)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
X = np.ones((NB, sample_dims), dtype=np.float32)
action = ('Fitting' if transformer.batch_support else 'Collecting')
for gi in trange(0, N, NB, desc=f'{action} batches (NB={NB})', ascii=True):
    for mb in range(0, NB, B):
        z = torch.from_numpy(latents[(gi + mb):((gi + mb) + B)]).to(device)
        if samples_are_latents:
            batch = z.reshape((B, (- 1)))
        else:
            with torch.no_grad():
                model.partial_forward(z, layer_key)
            batch = inst.retained_features()[layer_key].reshape((B, (- 1)))
        space_left = min(B, (NB - mb))
        X[mb:(mb + space_left)] = batch.cpu().numpy()[:space_left]
    if transformer.batch_support:
        if (not transformer.fit_partial(X.reshape((- 1), sample_dims))):
            break
    else:
        samples[gi:(gi + NB), :] = X.copy()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
record = json.loads(line)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
result_designpoint = open(path_to_result, 'r')
lines = result_designpoint.readlines()
eval_loss = float(lines[9].split(' ')[2][:(- 2)])
f1_score = float(lines[10].split(' ')[2][:(- 2)])
precision = float(lines[11].split(' ')[2][:(- 2)])
recall = float(lines[12].split(' ')[2][:(- 2)])
result_designpoint.close()
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
attribute_callable = _SCALAR_TYPE_MAP[attribute_type]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
g = grp.getgrnam(tarinfo.gname)[2]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
f0_mse = metrics.lf0_mean_squared_error(lf0, vuv, lf0_hat, vuv_hat, lengths=lengths, linear_domain=True)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1
"
candidate = self._extras_candidate_cache[cache_key]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (not self.args.use_bmuf):
    multiplier = self.data_parallel_world_size
    self.optimizer.multiply_grads((multiplier / sample_size))
elif (sample_size > 0):
    num = (self.data_parallel_world_size if self._sync_stats() else 1)
    self.optimizer.multiply_grads((num / sample_size))
grad_norm = self.clip_grad_norm(self.args.clip_norm)
if (not self.args.use_bmuf):
    self._check_grad_norms(grad_norm)
self.optimizer.step()
self.set_num_updates((self.get_num_updates() + 1))
logging_output = self._reduce_and_log_stats(logging_outputs, sample_size, grad_norm)
if ((self.args.empty_cache_freq > 0) and ((((self.get_num_updates() + self.args.empty_cache_freq) - 1) % self.args.empty_cache_freq) == 0) and torch.cuda.is_available() and (not self.args.cpu)):
    torch.cuda.empty_cache()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (gender is None):
    gender = self.thegender
elif (gender not in singular_pronoun_genders):
    raise BadGenderError
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
with open(url, 'rb') as f:
    content = auto_decode(f.read())
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
__IPYTHON__
return True
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
word_idx = data['dict'][word]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(dir_path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
proving_step = steps[conclusion2step[assumption.name]]
proving_step[0]['observation']['objectives'] = [objective]
trajectories.append(proving_step[0])
if proving_step[1]:
    tracebacks.extend(proving_step[1])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
img = cv.imread(full_path)
(bounding_boxes, landmarks) = detector.detect_faces(img)
if (len(landmarks) > 0):
    landmarks = [int(round(x)) for x in landmarks[0]]
    return (True, landmarks)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import nltk
assert (valid['nltk_bleu1'] > 0.9)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (p_i.shape == arr_i.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
buff = self.handle.recv(sz)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (not os.path.exists(directory)):
    os.makedirs(directory)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self._num_examples_cache: int = self.data.num_examples()
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from mmdet.version import __version__
sha = __version__.split('+')[(- 1)]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
objective_function_class = objective_mapping[objective_short_title]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with open(save_file, 'r') as f:
    last_saved = f.read()
    last_saved = last_saved.strip()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return raw_xml.title.text
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return self.idxToLabel[idx]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_archive_file = cached_path(archive_file, cache_dir=cache_dir, force_download=force_download, proxies=proxies, resume_download=resume_download, local_files_only=local_files_only)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_corpus_file = cached_path(corpus_file, cache_dir=cache_dir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (parser == 'spacy'):
    if use_gpu:
        spacy.prefer_gpu()
    else:
        spacy.require_cpu()
    exclude = (['senter', 'sentencizer'] if is_tokenized else [])
    try:
        nlp = spacy.load(model_or_lang, exclude=exclude, **kwargs)
    except OSError as exc:
        try:
            model_name = next((m for m in get_installed_models() if m.startswith(f'{model_or_lang}_')))
        except StopIteration:
            raise OSError(f""Could not find a spaCy model that is called '{model_or_lang}' or that starts with '{model_or_lang}_'. See the error trace above for more info."") from exc
        logger.info(f""Specified spaCy model '{model_or_lang}' not found. Using {model_name} instead."")
        nlp = spacy.load(model_name, exclude=exclude, **kwargs)
    if is_tokenized:
        nlp.tokenizer = SpacyPretokenizedTokenizer(nlp.vocab)
        nlp.add_pipe('prevent_sbd', name='prevent-sbd', before='parser')
elif (parser == 'stanza'):
    if auto_download:
        stanza.download(model_or_lang, verbose=False)
    nlp = StanzaPipeline(processors='tokenize,pos,lemma,depparse', lang=model_or_lang, tokenize_pretokenized=is_tokenized, use_gpu=use_gpu, **kwargs)
elif STANZA_AVAILABLE:
    return load_parser(model_or_lang, parser='stanza', is_tokenized=is_tokenized, use_gpu=use_gpu, **kwargs)
elif SPACY_AVAILABLE:
    return load_parser(model_or_lang, parser='spacy', is_tokenized=is_tokenized, use_gpu=use_gpu, **kwargs)
else:
    raise ImportError
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex.contrib.optimizers import FP16_Optimizer
from apex.contrib.optimizers import FusedAdam
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
dummy_config.set(((self.embedder_type + '.') + key), value)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
from sacremoses import MosesPunctNormalizer
self.punc_normalizer = MosesPunctNormalizer(self.source_lang).normalize
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
dot_product = float(static_model.similarity(target, candidate_tokens[j]))
assert ((- 1) <= dot_product <= 1), dot_product
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import sentencepiece as spm
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(os.path.join(self.root, self.raw_folder))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
datasets = _get_datasets(self.path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0
"
entity_vector = vectors[cand]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (pointer.shape == array.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (model.tokens_embed.weight.shape == init_params[1].shape)
assert (model.positions_embed.weight.shape == init_params[0].shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
exp_path = exp
params_json_path = os.path.join(exp_path, 'params.pkl')
variant_json_path = os.path.join(exp_path, params_filename)
progress_csv_path = os.path.join(exp_path, progress_filename)
progress = log_reader.read_log(exp_path, progress_csv_path)
if disable_variant:
    params = core.load_params(params_json_path)
else:
    try:
        params = core.load_params(variant_json_path)
    except IOError:
        params = core.load_params(params_json_path)
exps_data.append(AttrDict(progress=progress, params=params, flat_params=core.flatten_dict(params)))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
is_bidirectional = self._module.bidirectional
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
branch_name = repo.active_branch.name
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
return mod.code
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from test_forward import _get_detector_cfg
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (w.text.strip() != ''):
    start_char = (w.idx + (len(w.text) - len(w.text.lstrip())))
    end_char = ((w.idx + len(w)) - (len(w.text) - len(w.text.rstrip())))
    i_start = [i for (i, e) in enumerate(offsets_mapping) if (e[0] == start_char)][0]
    i_end = [i for (i, e) in enumerate(offsets_mapping) if (e[1] == end_char)][0]
    for j in range(i_start, (i_end + 1)):
        token_offset[j] = (w.pos_, w.tag_, w.is_stop, w.is_punct)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(_loss, sample_size, logging_output) = self.task.valid_step(sample, self.model, self.criterion)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
cpu_input = self._get_input()
type_map = {torch.DoubleTensor: torch.cuda.FloatTensor}
gpu_input = to_gpu(cpu_input, type_map=type_map)
cpu_module = self.constructor(*self.constructor_args)
gpu_module = self.constructor(*self.constructor_args).float().cuda()
cpu_param = test_case._get_parameters(cpu_module)
gpu_param = test_case._get_parameters(gpu_module)
for (cpu_p, gpu_p) in zip(cpu_param[0], gpu_param[0]):
    if isinstance(cpu_p, Variable):
        cpu_p = cpu_p.data
    if isinstance(gpu_p, Variable):
        gpu_p = gpu_p.data
    gpu_p.copy_(cpu_p)
test_case._zero_grad_input(cpu_input)
test_case._zero_grad_input(gpu_input)
test_case._zero_grad_parameters(cpu_module)
test_case._zero_grad_parameters(gpu_module)
cpu_output = test_case._forward(cpu_module, cpu_input)
gpu_output = test_case._forward(gpu_module, gpu_input)
test_case.assertEqual(cpu_output, gpu_output, 0.0002)
for i in range(5):
    cpu_output_t = (cpu_output.data if isinstance(cpu_output, Variable) else cpu_output)
    cpu_gradOutput = cpu_output_t.clone().bernoulli_()
    gpu_gradOutput = cpu_gradOutput.type('torch.cuda.FloatTensor')
    cpu_gradInput = test_case._backward(cpu_module, cpu_input, cpu_output, cpu_gradOutput)
    gpu_gradInput = test_case._backward(gpu_module, gpu_input, gpu_output, gpu_gradOutput)
    test_case.assertEqual(cpu_gradInput, gpu_gradInput, 0.0002)
    for (cpu_d_p, gpu_d_p) in zip(cpu_param[1], gpu_param[1]):
        test_case.assertEqual(cpu_d_p, gpu_d_p, 0.0002)
self.test_noncontig(test_case, gpu_module, gpu_input)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
j = word.index(first, i)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
f = open(text)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (not ignore_utf_errors):
    with open(f, 'r', encoding='utf-8') as fd:
        self.add_from_file(fd)
else:
    with open(f, 'r', encoding='utf-8', errors='ignore') as fd:
        self.add_from_file(fd)
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
subprocess.check_call(['gs', '--version'], stdout=subprocess.DEVNULL)
return True
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
args = parser.parse_args(args)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0
"
while (n_filled < self.bptt):
    if ((streams[i] is None) or (len(streams[i]) <= 1)):
        streams[i] = next(sent_stream)
    n_new = min((len(streams[i]) - 1), (self.bptt - n_filled))
    data[(n_retain + n_filled):((n_retain + n_filled) + n_new), i] = streams[i][:n_new]
    target[n_filled:(n_filled + n_new), i] = streams[i][1:(n_new + 1)]
    streams[i] = streams[i][n_new:]
    n_filled += n_new
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return canonical_heat_type(type(obj[0]))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
im = np.asarray(Image.open(os.path.join(path, ('src/%d.png' % i))))
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (pointer.shape == array.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return getattr(sys.modules[mod_str], class_str)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex import amp
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
res = idx._get_string_slice(str(key))
warnings.warn('Indexing a DataFrame with a datetimelike index using a single string to slice the rows, like `frame[string]`, is deprecated and will be removed in a future version. Use `frame.loc[string]` instead.', FutureWarning, stacklevel=3)
return res
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
import sentencepiece as spm
self.sp = spm.SentencePieceProcessor()
self.sp.Load(vocab)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
accuracy = eval(f'test_{mode}')(net, testloader, device)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
lvis_dt = LVISResults(lvis_gt, result_files[metric])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
ws.RunNetOnce(predict_net)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex.optimizers import FP16_Optimizer
from apex.optimizers import FusedAdam
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
_check_orth(n, np.float64, skip_big=True)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
output = torch.cat([output[i] for i in range(len(output))])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
download_url = TRAINED_WEIGHT_URLS[weights_type]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import tensorflow_datasets as tfds
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
data = next(self.iter_loader)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(_loss, sample_size, logging_output) = self.task.valid_step(sample, self.model, self.criterion)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
tbatch = next(t_loader)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
modifier_table_entry = modifiers_table[term]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (x in data):
    to_filter.append(x)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
(r, c) = self._farthest_food(obs, start=farthest_player)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
tf_cuda_available = tf.test.is_gpu_available()
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with open(temp_file_path, 'w'):
    pass
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
seq_len = (None if (not self.multigpu) else batch.text_vec.size(1))
out = self.model(batch.text_vec, batch.label_vec, seq_len=seq_len)
scores = out[0]
(_, preds) = scores.max(2)
score_view = scores.view((- 1), scores.size((- 1)))
loss = self.criterion(score_view, batch.label_vec.view((- 1)))
notnull = batch.label_vec.ne(self.NULL_IDX)
target_tokens = notnull.long().sum().item()
correct = ((batch.label_vec == preds) * notnull).sum().item()
self.metrics['correct_tokens'] += correct
self.metrics['loss'] += loss.item()
self.metrics['num_tokens'] += target_tokens
loss /= target_tokens
loss.backward()
self.update_params()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.sent_tok = nltk.data.load(st_path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
f = [x for x in files if ((f'{e_args.raw_data}' in x) and ('.zip' not in x))][0]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
ss2_index = seed_cluster_sents2.index(ss1)
ss3_index = seed_cluster_sents3.index(ss1)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
import sentencepiece as spm
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.graphs[gt['scan']][prev[0]][curr[0]]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
tf_cuda_available = tf.test.is_gpu_available()
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
f(numpy.array([1, 2, 3, 4], dtype='int32'))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
import requests
response = requests.head(url, allow_redirects=True)
if (response.status_code != 200):
    etag = None
else:
    etag = response.headers.get('ETag')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from .modeling_tf_pytorch_utils import load_tf2_checkpoint_in_pytorch_model
model = load_tf2_checkpoint_in_pytorch_model(model, resolved_archive_file, allow_missing_keys=True)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
node_feat = pd.read_csv(osp.join(subdir, (additional_file + '.csv.gz')), compression='gzip', header=None).values
if ('int' in str(node_feat.dtype)):
    node_feat = node_feat.astype(np.int64)
else:
    node_feat = node_feat.astype(np.float32)
assert (len(node_feat) == sum(num_node_dict[nodetype]))
additional_feat_dict[nodetype] = node_feat
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
dataset = self.all()[key]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
global_step = int(args.model_name_or_path.split('-')[(- 1)].split('/')[0])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
import apex
apex.amp.register_half_function(torch, 'einsum')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return cls(*args)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
return (math.log(math.expm1((logx - logy))) + logy)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
tree = iter(node)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
dispcmd = str(([c] + args))
p = subprocess.Popen(([c] + args), cwd=cwd, env=env, stdout=subprocess.PIPE, stderr=(subprocess.PIPE if hide_stderr else None))
break
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
nvml.nvmlInit()
devices = (list(range(nvml.nvmlDeviceGetCount())) if (gpus_to_trace is None) else gpus_to_trace)
nvml.nvmlShutdown()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(temp_dir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (p_i.shape == arr_i.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
mask_color = [(x / 255) for x in self.metadata.stuff_colors[label]]
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with maybe_no_sync():
    (loss, sample_size_i, logging_output) = self.task.train_step(sample=sample, model=self.model, criterion=self.criterion, optimizer=self.optimizer, update_num=self.get_num_updates(), ignore_grad=is_dummy_batch)
    del loss
logging_outputs.append(logging_output)
sample_size += sample_size_i
if (self.cuda and (self.get_num_updates() == 0)):
    torch.cuda.empty_cache()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
nn.utils.remove_weight_norm(module)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
labels.append(int(row[(- 1)].replace('\n', '')))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
for layer in self.hidden_layers:
    x = self.activation(layer(x))
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
value = os.environ[key]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import ftfy
from spacy.lang.en import English
_nlp = English()
self.nlp = _nlp.Defaults.create_tokenizer(_nlp)
self.fix_text = ftfy.fix_text
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
settings = encoders[name]['pretrained_settings'][weights.lower()]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import d4rl
env = gym.make(env_name)
dataset = env.get_dataset()
observations = dataset['observations']
actions = dataset['actions']
rewards = dataset['rewards']
terminals = np.logical_and(dataset['terminals'], np.logical_not(dataset['timeouts']))
episode_terminals = np.logical_or(dataset['terminals'], dataset['timeouts'])
mdp_dataset = MDPDataset(observations=observations, actions=actions, rewards=rewards, terminals=terminals, episode_terminals=episode_terminals, create_mask=create_mask, mask_size=mask_size)
return (mdp_dataset, env)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import editdistance as ed
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
try:
    inn.load((model_fname[:(- 3)] + '.avg.pt'))
except FileNotFoundError:
    inn.load((model_fname[:(- 3)] + '.00.avg.pt'))
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
value = self[key.encode('us-ascii')]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
traced_gpt2 = torch.jit.trace(model, inputs)
torch.jit.save(traced_gpt2, 'traced_model.pt')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
realizer = Realizer(**domain.templates_modifier, validate=True)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
from py3nvml import py3nvml
py3nvml.nvmlInit()
devices = (list(range(py3nvml.nvmlDeviceGetCount())) if (gpus_to_trace is None) else gpus_to_trace)
py3nvml.nvmlShutdown()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (self.num_incorrect_words == other.num_incorrect_words)
assert (self.num_tainted_words == other.num_tainted_words)
assert (abs((self.incorrect_words_length - other.incorrect_words_length)) < 0.01)
assert (abs((self.tainted_nonsilence_length - other.tainted_nonsilence_length)) < 0.01)
assert (abs((self.silence_length - other.silence_length)) < 0.01)
assert (self.num_words == other.num_words)
assert (abs((self.total_length - other.total_length)) < 0.01)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import re
import numpy as np
import tensorflow as tf
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex import amp
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import sentencepiece as spm
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from torchvision import _C as C
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return bool(eval(x))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
return (math.log(2) + special.log_ndtr(((- x) * (2 ** 0.5))))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
value = self._loads(line)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
from fairscale.nn import Pipe
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
src_dict = getattr(task, 'source_dictionary', None)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
matcher = self.version_match
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
varsNames.append(currentVar.VarName)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (pointer.shape == array.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
poppable_tensors[name] = skip_tracker.load(batch, ns, name)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(path, mode=mode)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if six.PY2:
    sdist_add_defaults._add_defaults_data_files(self)
else:
    super()._add_defaults_data_files()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
from apex.optimizers import FP16_Optimizer
from apex.optimizers import FusedAdam
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
_spacy_tokenizer = _load_spacy_tokenizer()
get_tokens = (lambda inp: _spacy_tokenizer(inp))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from fairscale.nn import Pipe
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex import amp
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (filename == '-'):
    lines = codecs.StreamReaderWriter(sys.stdin, codecs.getreader('utf8'), codecs.getwriter('utf8'), 'replace').read().split('\n')
else:
    lines = codecs.open(filename, 'r', 'utf8', 'replace').read().split('\n')
carriage_return_found = False
for linenum in range(len(lines)):
    if lines[linenum].endswith('\r'):
        lines[linenum] = lines[linenum].rstrip('\r')
        carriage_return_found = True
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
metric_kernels = [hc.profile(runnable, metric) for metric in self._metrics]
assert all(map((lambda ks: (len(ks) == len(metric_kernels[0]))), metric_kernels))
transposed = map(list, zip(*metric_kernels))
return list(zip(time_kernels, transposed))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if self.args.cuda:
    model.cuda()
optimizer = torch.optim.Adam(model.parameters(), lr=self.args.lr, weight_decay=self.args.weight_decay)
(model, val_acc) = self.run_model(model, optimizer, self.loss_fn, self.data, epochs=1, cuda=self.args.cuda, evaluate=True)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from_config_func = type(self).from_config
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (self.config.mode == 'test'):
    print('-------test------------')
    start = time.process_time()
    self.test('test')
    self.time_record = (time.process_time() - start)
else:
    self.train()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
logits = model(images, update_batch_stats=False)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
t = n[(0, 0)]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
from mmcv.onnx.symbolic import register_extra_symbolics
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
ws.RunNetOnce(predict_net)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
overload = self.virtual_parent_callers[name]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
to_return_images = self.generator(z, self.generator.module.shared(y))
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
col_idx = int(lbl[1])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
return self.span_predictor.encoder.bert_model.get_input_embeddings()
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with g_pathmgr.open(subset_path, 'r') as f:
    subset = f.read().split('\n')
    subset_ids = [class2idx[name] for name in subset if (class2idx.get(name) is not None)]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_archive_file = cached_path(archive_file, cache_dir=cache_dir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
pickle.dumps(obj)
return True
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (p_i.shape == arr_i.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from qiskit import Aer
backend = Aer.get_backend('qasm_simulator')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import pymongo
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(dir2save)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.writeln((TITLE_UNDERLINES[self.section] * len(title)))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
pass_expr_memo_ctrl = fn.pass_expr_memo_ctrl
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
iter(axes[0])
iterable = True
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
stats = os.stat(localfile)
size = stats.st_size
modified = email_utils.formatdate(stats.st_mtime, usegmt=True)
mtype = mimetypes.guess_type(filename)[0]
headers = email.message_from_string(('Content-type: %s\nContent-length: %d\nLast-modified: %s\n' % ((mtype or 'text/plain'), size, modified)))
if host:
    (host, port) = splitport(host)
if ((not host) or ((not port) and (_safe_gethostbyname(host) in self.get_names()))):
    if host:
        origurl = (('file://' + host) + filename)
    else:
        origurl = ('file://' + filename)
    return addinfourl(open(localfile, 'rb'), headers, origurl)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
tmp = next(r_i)
tmp += next(r_ii)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import moviepy
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return str(r.content, encoding, errors='replace')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
shell = get_ipython().__class__.__name__
if (shell == 'ZMQInteractiveShell'):
    return True
elif (shell == 'TerminalInteractiveShell'):
    return False
else:
    return False
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
lr = '{:.6f}'.format(storage.history('lr').latest())
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
img_id = int(shotname)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
checkpoint_suffix = args.model_name_or_path.split('-')[(- 1)].split('/')[0]
global_step = int(checkpoint_suffix)
epochs_trained = (global_step // (len(train_dataloader) // args.gradient_accumulation_steps))
steps_trained_in_current_epoch = (global_step % (len(train_dataloader) // args.gradient_accumulation_steps))
logger.info('  Continuing training from checkpoint, will skip to saved global_step')
logger.info('  Continuing training from epoch %d', epochs_trained)
logger.info('  Continuing training from global step %d', global_step)
logger.info('  Will skip the first %d steps in the first epoch', steps_trained_in_current_epoch)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
from apex import amp
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
while (n_filled < self.bptt):
    if ((streams[i] is None) or (len(streams[i]) <= 1)):
        streams[i] = next(sent_stream)
    n_new = min((len(streams[i]) - 1), (self.bptt - n_filled))
    data[(n_retain + n_filled):((n_retain + n_filled) + n_new), i] = streams[i][:n_new]
    target[n_filled:(n_filled + n_new), i] = streams[i][1:(n_new + 1)]
    streams[i] = streams[i][n_new:]
    n_filled += n_new
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with open((filename + '.pkl'), 'rb') as file:
    ga_in = pickle.load(file)
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import numpy as np
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
while (n_filled < self.bptt):
    if ((streams[i] is None) or (len(streams[i]) <= 1)):
        streams[i] = next(sent_stream)
    n_new = min((len(streams[i]) - 1), (self.bptt - n_filled))
    data[(n_retain + n_filled):((n_retain + n_filled) + n_new), i] = streams[i][:n_new]
    target[n_filled:(n_filled + n_new), i] = streams[i][1:(n_new + 1)]
    streams[i] = streams[i][n_new:]
    n_filled += n_new
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import tensorflow as tf
import torch
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.remove(cls.path_token)
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
data = next(self.iters[split])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import re
import numpy as np
import tensorflow as tf
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (len(line) == 0):
    continue
tokens = line.split()
if (len(tokens) < embedd_dim):
    continue
if (embedd_dim < 0):
    embedd_dim = (len(tokens) - 1)
embedd = np.empty([1, embedd_dim], dtype=np.float32)
start = (len(tokens) - embedd_dim)
word = ' '.join(tokens[0:start])
embedd[:] = tokens[start:]
word = (DIGIT_RE.sub('0', word) if normalize_digits else word)
embedd_dict[word] = embedd
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0
"
cocoDt = cocoGt.loadRes(result_files[res_type])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from transformers.convert_xlnet_original_tf_checkpoint_to_pytorch import convert_xlnet_checkpoint_to_pytorch
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import ctypes
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
iter_stats = stat_tables_per_component_per_dir[dir][component_name]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from sacremoses import MosesTokenizer, MosesDetokenizer
self.tok = MosesTokenizer(args.moses_source_lang)
self.detok = MosesDetokenizer(args.moses_target_lang)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
i = rstack.index(r)
sd = (l - i)
stack_distances.insert(0, sd)
rstack.pop(i)
rstack.insert((l - 1), r)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
f = open(filename, 'r')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(model_dir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
loss_value = loss_model(features, labels)
loss_value.backward()
torch.nn.utils.clip_grad_norm_(loss_model.parameters(), max_grad_norm)
optimizer.step()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
sock.connect(('10.255.255.255', 1))
ip_addr = sock.getsockname()[0]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
bottom = (y - (height / 2))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
(s, t) = backlinks[position]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
assert (pointer.shape == array.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
rv = self[key]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
for parse in parser.parse([word_L, word_R]):
    (token, _) = parse.label()
    (category, semantics) = (token.categ(), token.semantics())
    memory_key = ((str(category) + '_') + str(semantics))
    if (memory_key not in memory):
        memory.append(memory_key)
        word_index += 1
        form.append((parse, category, semantics, word_index))
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0
"
import Mykytea
self.ja_word_tokenizer = Mykytea.Mykytea(('-model %s/local/share/kytea/model.bin' % os.path.expanduser('~')))
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
num_targets = int(variables['num_targets'])
if (common_lib.get_feat_dim_from_scp(args.targets_scp) != num_targets):
    raise Exception('Mismatch between num-targets provided to script vs configs')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
outputs = self.get_atomic_sequence(input_event, self._model, sampler, self._data_loader, self._text_encoder, category)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
next(module.parameters())
return True
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import cv2
data.append(('cv2', cv2.__version__))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
model.load_state_dict(state_dict)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.batch = next(self.loader)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
setattr(self, key, value)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
tables_to_interpolate[s][element_name] = self.sn1a_yields[metallicity_key][element_name]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import requests
response = request_wrap_timeout(partial(requests.head, url, allow_redirects=True), url)
if (response.status_code != 200):
    etag = None
else:
    etag = response.headers.get('ETag')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
attr = object.__getattr__(name)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import ftfy
from spacy.lang.en import English
_nlp = English()
self.nlp = _nlp.Defaults.create_tokenizer(_nlp)
self.fix_text = ftfy.fix_text
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
nvml.nvmlInit()
devices = (list(range(nvml.nvmlDeviceGetCount())) if (gpus_to_trace is None) else gpus_to_trace)
nvml.nvmlShutdown()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
for next in nexts:
    (yield next())
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
ckpt = torch.load(model_path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
lengths = set([int(val) for val in length.split(',')])
if (len(lengths) > 1):
    raise InvalidHeader(('Content-Length contained multiple unmatching values (%s)' % length))
length = lengths.pop()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
with open(cls.path_token, 'r') as f:
    return f.read()
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
data[key] = np.array([float(x) for x in value.split()])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
from transformers import GPT2Config, GPT2LMHeadModel
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.main.set_hbp_approximation(average_input_jacobian=average_input_jacobian, average_parameter_jacobian=average_parameter_jacobian)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
shutil.copy2(file_path, task_directory_path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (pointer.shape == array.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import regex as re
self.re = re
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_archive_file = cached_path(archive_file, cache_dir=cache_dir)
resolved_config_file = cached_path(config_file, cache_dir=cache_dir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.get_label(0)
return True
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
global_step = int(args.model_name_or_path.split('-')[(- 1)].split('/')[0])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
with open(pickle_file, 'rb') as f:
    pickle_data = pickle.load(f)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0
"
return bpe.is_beginning_of_word(tok)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
import moviepy
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
neigh = edges[point_id]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.network.integration_unit.set_headstart_weight(headstart[2])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
save_dir = self._save_dirs[head]
break
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
p = (self.tp / (self.tp + self.fp))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1
"
from keras_contrib.layers.normalization import InstanceNormalization
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
edge_feat = pd.read_csv(osp.join(subdir, 'edge-feat.csv.gz'), compression='gzip', header=None).values
if ('int' in str(edge_feat.dtype)):
    edge_feat = edge_feat.astype(np.int64)
else:
    edge_feat = edge_feat.astype(np.float32)
edge_feat_dict[triplet] = edge_feat
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(base_path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
console = distribution.get_entry_map('console_scripts')
gui = distribution.get_entry_map('gui_scripts')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
print('Match from molAtomMapNum {}'.format(mol.GetAtomWithIdx(atom_idx).GetProp('molAtomMapNumber')))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
mol.GetAtomWithIdx(0).GetExplicitValence()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return self.base_model(self.transform(self.input_image.sigmoid()).unsqueeze(0), state)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
(valid_inds, exs) = zip(*[(i, ex) for (i, ex) in enumerate(observations) if valid(ex)])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
import sentencepiece as spm
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
trans = self.axes.transAxes.inverted()
(xaxes, yaxes) = trans.transform((x, y))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
lm_head.set_bias(value)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (img_dev_data_iter is not None):
    bleu = self.eval_bleu(img_dev_data_iter, saving_path)
    print('Captioning BLEU:', bleu)
if (mt_dev_iter is not None):
    bleu = super().eval_bleu(mt_dev_iter, saving_path)
    print('MT BLEU:', bleu)
print(('Total loss in this epoch: %f' % (total_loss / total_tokens)))
model.save((saving_path + '.latest'))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
tokenizer = cls(*init_inputs, **init_kwargs)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
repo_dpath = dirname(dirname(__file__))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
__IPYTHON__
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
acts[index] = agent.act(timeout=None)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
img = Image.open(path).convert('RGB')
got_img = True
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
augment_traj(env, json_file)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
os.remove(os.path.join(self.datapath, d))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import spacy
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
repo_dpath = dirname(dirname(dirname(__file__)))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
val = [dtype(float(x))]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
tickvalues = props['axes'][index]['tickvalues']
tick0 = tickvalues[0]
dticks = [round((tickvalues[i] - tickvalues[(i - 1)]), 12) for i in range(1, (len(tickvalues) - 1))]
if all([(dticks[i] == dticks[(i - 1)]) for i in range(1, (len(dticks) - 1))]):
    dtick = (tickvalues[1] - tickvalues[0])
else:
    warnings.warn(""'linear' {0}-axis tick spacing not even, ignoring mpl tick formatting."".format(ax_type))
    raise TypeError
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
ret = self._unpack(EX_CONSTRUCT)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from .convert_gpt2_original_tf_checkpoint_to_pytorch import convert_gpt2_checkpoint_to_pytorch
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
margin = (y_true * pred_decision)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
os.makedirs(dirname)
",0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
setattr(namespace, self.dest, str_to_bool(values))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
num_labels = glue_tasks_num_labels[data_args.task_name]
output_mode = glue_output_modes[data_args.task_name]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with PathManager.open(f, 'r', encoding='utf-8') as fd:
    self.add_from_file(fd)
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from spacy.lang.en import English
spacy_nlp._nlp = English()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
mask_pred.save(dataset.images[i].replace(imname, (('parsings/' + imname[:(- 4)]) + '.png')))
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert_warns(UserWarning, f)
failed = True
",0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(w, V) = numpy.linalg.eig(M33)
i = numpy.where((abs((numpy.real(w) - factor)) < 1e-08))[0][0]
direction = numpy.real(V[:, i]).squeeze()
direction /= vector_norm(direction)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
img = Image.open(img_path).convert('RGB')
got_img = True
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
class_names = MetadataCatalog.get(dataset_names[0]).thing_classes
check_metadata_consistency('thing_classes', dataset_names)
print_instances_class_histogram(dataset_dicts, class_names)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
params['model']['class_list'] = ast.literal_eval(params['model']['class_list'])
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
npars = pl_module.model.model.num_parameters()
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
del self.observers[cid]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
DEVICE_ID_LIST = GPUtil.getFirstAvailable()
DEVICE_ID = DEVICE_ID_LIST[0]
os.environ['CUDA_VISIBLE_DEVICES'] = str(DEVICE_ID)
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with open(save_file, 'r') as f:
    last_saved = f.read()
    last_saved = last_saved.strip()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
labels = [class_names[i] for i in classes]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import datasets
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (pointer.shape == array.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
stream.seek(stream.tell())
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
_ = activemri.envs.util.import_object_from_str(reconstructor_cfg['transform'])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
text_a = line[3]
text_b = line[4]
label = line[5]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
cur_stream[i] = list(next(generator))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(r, c) = self._farthest_food(obs)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
assert simplex(u_star, axis=0)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex import amp
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
tokenizer = MecabTokenizer(do_lower_case=True, normalize_text=False, mecab_option='-d /usr/local/lib/mecab/dic/jumandic')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from mmdet.version import __version__
sha = __version__.split('+')[(- 1)]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
cocoDt = cocoGt.loadRes(result_files[metric])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(src_sents, tgt_sents) = next(self.data_gen_eval)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (pointer.shape == array.shape), f'Pointer shape {pointer.shape} and array shape {array.shape} mismatched'
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
loss = self.compute_loss(self._dummy_batch(batchsize, maxlen))
self.backward(loss)
self.buffer_initialized = True
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with open(save_file, 'r') as f:
    last_saved = f.read()
    last_saved = last_saved.strip()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex import amp
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import chainer
print(f'[x] chainer={chainer.__version__}')
if (LooseVersion(chainer.__version__) != LooseVersion('6.0.0')):
    print(f'Warning! chainer={chainer.__version__} is not supported. Supported version is 6.0.0')
if chainer.backends.cuda.available:
    print('[x] chainer cuda')
else:
    print('[ ] chainer cuda')
if chainer.backends.cuda.cudnn_enabled:
    print('[x] chainer cudnn')
else:
    print('[ ] chainer cudnn')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(root)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
found_files.extend(config.read(filename))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0
"
ims = src.pop()
imr = rec.pop()[0]
ims = ims.cpu().detach().numpy()
imr = imr
res = int((initial_resolution / (2 ** i)))
ims = resize(ims, (3, (initial_resolution / (2 ** i)), (initial_resolution / (2 ** i))))
imr = resize(imr, (3, (initial_resolution / (2 ** i)), (initial_resolution / (2 ** i))))
place(canvas, ims, (current_padding + (x * ((2 * res) + current_padding))), (((i * initial_resolution) + height_padding) + (y * (res + current_padding))))
place(canvas, imr, ((current_padding + res) + (x * ((2 * res) + current_padding))), (((i * initial_resolution) + height_padding) + (y * (res + current_padding))))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
coords[coords.index(tuple(MAX))] = None
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
flow_gt = next(self.homography_dataloader_iterator)['flow_map'].to(self.device).requires_grad_(False)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
tokenizer = cls(*init_inputs, **init_kwargs)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
j = word.index(first, i)
new_word.extend(word[i:j])
i = j
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
key = winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, 'Software\\Microsoft\\VisualStudio\\SxS\\VC7', 0, (winreg.KEY_READ | winreg.KEY_WOW64_32KEY))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex.optimizers import FP16_Optimizer
from apex.optimizers import FusedAdam
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.__setattr__(key, value, create_if_not_exist=False)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
edge = pd.read_csv(osp.join(raw_dir, 'edge.csv.gz'), compression='gzip', header=None).values.T.astype(np.int64)
num_node_list = pd.read_csv(osp.join(raw_dir, 'num-node-list.csv.gz'), compression='gzip', header=None).astype(np.int64)[0].tolist()
num_edge_list = pd.read_csv(osp.join(raw_dir, 'num-edge-list.csv.gz'), compression='gzip', header=None).astype(np.int64)[0].tolist()
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
int(elements[0])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
return getattr(self, key)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with maybe_no_sync():
    (loss, sample_size, logging_output) = self.task.train_step(sample, self.model, self.criterion, self.optimizer, ignore_grad)
if (not ignore_grad):
    logging_outputs.append(logging_output)
    sample_sizes.append(sample_size)
    if self.fast_stat_sync:
        self._all_reduce_list[0] += sample_size
        self._all_reduce_list[1] += logging_output.get('nsentences', 0.0)
        self._all_reduce_list[2] += logging_output.get('loss', 0.0)
        self._all_reduce_list[3] += logging_output.get('nll_loss', 0.0)
        self._all_reduce_list[4] += logging_output.get('ntokens', 0.0)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(self.batch_idx, batch) = self.get_next_batch()
if (self.collate_fn == default_collate):
    batch = [b[1] for b in batch]
batch = process(batch)
epoch_done = False
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (sample_size > 0):
    self.optimizer.multiply_grads((self.args.distributed_world_size / float(sample_size)))
grad_norm = self.optimizer.clip_grad_norm(self.args.clip_norm)
self._prev_grad_norm = grad_norm
self.optimizer.step()
self.set_num_updates((self.get_num_updates() + 1))
self.task.update_step(self._num_updates)
ntokens = logging_output.get('ntokens', 0)
nsentences = logging_output.get('nsentences', 0)
self.meters['wps'].update(ntokens)
self.meters['ups'].update(1.0)
self.meters['wpb'].update(ntokens)
self.meters['bsz'].update(nsentences)
self.meters['gnorm'].update(grad_norm)
self.meters['clip'].update((1.0 if ((grad_norm > self.args.clip_norm) and (self.args.clip_norm > 0)) else 0.0))
self.meters['train_loss'].update(logging_output.get('loss', 0), sample_size)
if ('train_acc' in self.meters):
    self.meters['train_acc'].update(logging_output.get('acc', 0), sample_size)
if ('nll_loss' in logging_output):
    self.meters['train_nll_loss'].update(logging_output.get('nll_loss', 0), ntokens)
if ((self.args.empty_cache_freq > 0) and ((((self.get_num_updates() + self.args.empty_cache_freq) - 1) % self.args.empty_cache_freq) == 0) and torch.cuda.is_available() and (not self.args.cpu)):
    torch.cuda.empty_cache()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"

class Test(foo.SomeObject):
    pass
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
extr = _EXTRACTOR_FACTORY[extractor.upper()]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
logging.debug('Try to load dataset as images')
(train_ds, val_ds, test_ds) = image_folder_dataset.load_dataset(dataset_folder, inmem, workers)
(mean, std) = _load_mean_std_from_file(dataset_folder, inmem, workers)
logging.debug('Setting up dataset transforms')
transform = transforms.Compose([transforms.Resize(model_expected_input_size), transforms.ToTensor(), transforms.Normalize(mean=mean, std=std)])
train_ds.transform = transform
val_ds.transform = transform
test_ds.transform = transform
(train_loader, val_loader, test_loader) = _dataloaders_from_datasets(batch_size, train_ds, val_ds, test_ds, workers)
logging.info('Dataset loaded as images')
_verify_dataset_integrity(dataset_folder, disable_dataset_integrity, enable_deep_dataset_integrity)
return (train_loader, val_loader, test_loader, len(train_ds.classes))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with h5py.File(fname, 'r') as viewpoint:
    assert (len(viewpoint.keys()) == 36)
    long_id = ((scanId + '_') + viewpointId_h5[:(- 3)])
    temp = np.zeros((view_size, feature_size))
    for image_id in range(36):
        item = viewpoint[str(image_id)]
        temp[image_id, :] = np.mean(item['features'][()], 0)
    features[long_id] = temp
break
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
clip.write_gif(filename, verbose=False, logger=None)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
out = _minimal_ext_cmd(['git', 'rev-parse', 'HEAD'])
sha = out.strip().decode('ascii')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
MyConfig()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
(dist, idx) = kdtree.query(query_pts, sqr_dists=True)
assert False
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
(symbol, idx) = symbol_and_id.split(':')
idx = int(idx)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
model_dict = model.module.state_dict()
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
while (vid.isOpened() and running):
    while (frame_buffer.qsize() > 100):
        time.sleep(0.001)
    start_time = time.time()
    if (not vid_done):
        next_frames = pool.apply_async(get_next_frame, args=(vid,))
    else:
        next_frames = None
    if (not (vid_done and (len(active_frames) == 0))):
        for frame in active_frames:
            _args = [frame['value']]
            if (frame['idx'] == 0):
                _args.append(fps_str)
            frame['value'] = pool.apply_async(sequence[frame['idx']], args=_args)
        for frame in active_frames:
            if (frame['idx'] == 0):
                frame_buffer.put(frame['value'].get())
        active_frames = [x for x in active_frames if (x['idx'] > 0)]
        for frame in list(reversed(active_frames)):
            frame['value'] = frame['value'].get()
            frame['idx'] -= 1
            if (frame['idx'] == 0):
                active_frames += [{'value': extract_frame(frame['value'], i), 'idx': 0} for i in range(1, len(frame['value'][0]))]
                frame['value'] = extract_frame(frame['value'], 0)
        if (next_frames is not None):
            frames = next_frames.get()
            if (len(frames) == 0):
                vid_done = True
            else:
                active_frames.append({'value': frames, 'idx': (len(sequence) - 1)})
        frame_times.add((time.time() - start_time))
        fps = (args.video_multiframe / frame_times.get_avg())
    else:
        fps = 0
    fps_str = ('Processing FPS: %.2f | Video Playback FPS: %.2f | Frames in Buffer: %d' % (fps, video_fps, frame_buffer.qsize()))
    if (not args.display_fps):
        print((('\r' + fps_str) + '    '), end='')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return int(recursive)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
cmd = ('lsb_release', '-a')
stdout = subprocess.check_output(cmd, stderr=devnull)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (self.args.model_type == 'electra'):
    model_to_resize = (self.model.generator_model.module if hasattr(self.model.generator_model, 'module') else self.model.generator_model)
    model_to_resize.resize_token_embeddings(len(self.tokenizer))
    model_to_resize = (self.model.discriminator_model.module if hasattr(self.model.discriminator_model, 'module') else self.model.discriminator_model)
    model_to_resize.resize_token_embeddings(len(self.tokenizer))
model_to_resize = (self.model.module if hasattr(self.model, 'module') else self.model)
model_to_resize.resize_token_embeddings(len(self.tokenizer))
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
current_index = (- 1)
for (i, (name, pipe)) in enumerate(self.nlp.pipeline):
    if (self == pipe):
        current_index = i
        break
subsequent_pipes = [pipe for pipe in self.nlp.pipe_names[(current_index + 1):]]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
return pickle.load(open(path, 'rb'))
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return (True, open(stream, (read_or_write[0] + 'b')))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
return functools.reduce(getattr, self.attrs, module)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (pointer.shape == array.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
meth_node = overridden[function.name]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
param = signature(func).parameters
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
index = predict.index(val)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
(self.next_states, self.next_actions, self.next_action_log_probs, self.next_returns, self.next_advantages) = next(self.loader)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
__import__(module)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
nn.utils.remove_weight_norm(module)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
return self[name]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
file_proto = self._internal_db.FindFileByName(file_name)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
has_attr_readonly = (not (os.stat(path).st_mode & stat.S_IWRITE))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with warnings.catch_warnings():
    warnings.simplefilter('ignore', DeprecationWarning)
    from simtk import openmm, unit
    from openmmtools import testsystems
    Testsystem = getattr(testsystems, testsystem_name)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return V(self.values.index(val))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
self.model.load_state_dict(torch.load(base_model_path))
print(f'[Model] loaded model from {base_model_path}')
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.dropout_prob = float(settings['dropout_prob'])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
sig.bind(object(), pathlib.Path('testpath'), device=None)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
dtype = np.result_type(intermediate_dtype, default_array)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
(afm, adj, adjTensor_TypeAtt, adjTensor_OrderAtt, adjTensor_AromAtt, adjTensor_ConjAtt, adjTensor_RingAtt, nodeSubtypes) = molToGraph(mol, filted_bondtype_list_order, filted_atomtype_list_order).dump_as_matrices_Att()
mol_sizes.append(adj.shape[0])
if (self.name != 'NIH'):
    label = [data[i][j] for j in self.label_col_num]
    if (self.type == 'class'):
        label = [('-1' if (ele == '') else ele) for ele in label]
    labels.append(np.float32(label))
else:
    label = []
    for j in self.label_col_num:
        if (data[i][j] == 'Inactive'):
            label.append(0)
        elif (data[i][j] == 'Active'):
            label.append(1)
        elif (data[i][j] == ''):
            label.append((- 1))
        else:
            label.append((- 1))
    labels.append(np.float32(label))
    pass
x_all.append([afm, adj, adjTensor_TypeAtt, adjTensor_OrderAtt, adjTensor_AromAtt, adjTensor_ConjAtt, adjTensor_RingAtt, nodeSubtypes, count_2])
smile_list.append(smile)
count_2 += 1
correct_row.append(i)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
sent_tok = nltk.data.load(st_path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
config = Config.init(c_file, only_known_args=True)
if isinstance(config, configargparse.ArgParser):
    (config, unknown) = config.parse_known_args(['-c', c_file])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0
"
trainer.train_step(raw_batch)
trainer.iter()
torch.distributed.barrier()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
result_set_id = int(result_set_id)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
array = numpy.reshape(array, symbolic_weight.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return self.select([sorted(glob.glob((path + '/intrinsic/*.txt'))) for path in self.paths])
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(score, aligned) = get_matching_scores(dataset, i)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
for _ in range(self.chunk_size):
    chunk.append(next(self.itr))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from fairseq.data.data_utils_fast import batch_by_size_fast
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(rir_waveform, length) = next(self.rir_data).at_position(0)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(net, views, labels, cfg) = from_file(cfg_name, tag, run, ckpt='best', return_data=True, return_config=True)
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(model, criterion) = get_trained_model(task, seed, coefficient, attention, BEST_EPOCHS[epoch_key])
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
u = getattr(self.module, (self.name + '_u'))
v = getattr(self.module, (self.name + '_v'))
w = getattr(self.module, (self.name + '_bar'))
return True
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
result = a.shape
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
del child.y
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
del allTypes[t]
del sctypeDict[t]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import spacy
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with open(self.statefile_path) as statefile:
    self.state = json.load(statefile)[sys.prefix]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_corpus_file = cached_path(corpus_file, cache_dir=cache_dir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from fairseq import libbleu
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
expires = int((time.time() + int(morsel['max-age'])))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
out = _minimal_ext_cmd(['git', 'rev-parse', 'HEAD'])
sha = out.strip().decode('ascii')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
MySpecConfig.MY_VAR = val
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import psutil
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
raise NotImplementedError()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with maybe_no_sync():
    (loss, sample_size, logging_output) = self.task.train_step(sample, self.model, self.criterion, self.optimizer, ignore_grad)
if (not ignore_grad):
    logging_outputs.append(logging_output)
    sample_sizes.append(sample_size)
    if self.fast_stat_sync:
        self._all_reduce_list[0] += sample_size
        self._all_reduce_list[1] += logging_output.get('nsentences', 0.0)
        self._all_reduce_list[2] += logging_output.get('loss', 0.0)
        self._all_reduce_list[3] += logging_output.get('nll_loss', 0.0)
        self._all_reduce_list[4] += logging_output.get('ntokens', 0.0)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return ord(token)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
tokenizer = MecabTokenizer(mecab_dic='unidic')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
del sys.modules[name]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
cls_wrapper = self._registered_classes[cls]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
val = globals()[key]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_vocab_files = {}
for (file_id, file_path) in vocab_files.items():
    if (file_path is None):
        resolved_vocab_files[file_id] = None
    else:
        resolved_vocab_files[file_id] = cached_path(file_path, cache_dir=cache_dir, force_download=force_download, proxies=proxies, resume_download=resume_download)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
nn.utils.remove_weight_norm(module)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
out = metric.get_metric(reset)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
scores = self.instance.score_h(batch)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
result = self._get_value(key)
return result
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
self.player_color = colormap[player_color]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
print('begin training')
for epoch in range(1, (args.epochs + 1)):
    epoch_start_time = time.time()
    train_hidden = get_train_hidden(Data, Data.train[0], Data.train[1], model, args.hidden_batch_size)
    train_loss = train(Data, Data.train[0], Data.train[1], model, criterion, optim, args.batch_size, train_hidden)
    (val_loss, val_rae, val_corr, _, _) = evaluate(Data, Data.valid[0], Data.valid[1], model, evaluateL2, evaluateL1, args.batch_size, train_hidden)
    pprint('| end of epoch {:3d} | time: {:5.2f}s | train_loss {:5.4f} | valid rse {:5.4f} | valid rae {:5.4f} | valid corr  {:5.4f}'.format(epoch, (time.time() - epoch_start_time), train_loss, val_loss, val_rae, val_corr))
    (test_acc, test_rae, test_corr, _, _) = evaluate(Data, Data.test[0], Data.test[1], model, evaluateL2, evaluateL1, args.batch_size, train_hidden)
    if (val_loss < best_val):
        with open(args.save, 'wb') as f:
            torch.save(model, f)
        best_val = val_loss
        (test_acc, test_rae, test_corr, _, _) = evaluate(Data, Data.test[0], Data.test[1], model, evaluateL2, evaluateL1, args.batch_size, train_hidden)
        pprint('test rse {:5.4f} | test rae {:5.4f} | test corr {:5.4f}'.format(test_acc, test_rae, test_corr))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import accimage
return accimage.Image(path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from .convert_tf_checkpoint_to_pytorch import convert_tf_checkpoint_to_pytorch
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
pointer = getattr(pointer, m_name)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
v = literal_eval(v)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
return [self.protocol_parser[x] for x in filenames]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
i = old_word.index(first, i)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
import Mykytea
self.ja_word_tokenizer = Mykytea.Mykytea(('-model %s/local/share/kytea/model.bin' % os.path.expanduser('~')))
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
short_label = eval(f'conf.validation.short_names.{label}')
short_forms[label] = short_label
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
axis = tuple(axis)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
del self.__dict__[d]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
module = importlib.import_module(module_name)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
with open(output, 'rb') as f:
    return pickle.load(f)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0
"
early_stop.patience += 0
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return super(SafeFileCache, self).get(*args, **kwargs)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with open(save_file, 'r') as f:
    last_saved = f.read().strip()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
res = fielddict[attr][:2]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
if remove_egs:
    remove_nnet_egs(egs_dir)
for iter in range(num_iters):
    remove_model(nnet_dir, iter, num_iters, None, preserve_model_interval, get_raw_nnet_from_am=get_raw_nnet_from_am)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
_a[:, :, 1] = _b
assert False
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
assert (pointer.shape == array.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (val <= 0):
    raise ValueError('{} must be > 0, got {}'.format(key, val))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
import nltk
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from fairseq.data.token_block_utils_fast import _get_slice_indices_fast, _get_block_to_dataset_index_fast
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
batch_data = next(self.iterators[i])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
beta1_res = sop.root_scalar(func, x0=init_guess, bracket=[1e-10, (base_imp_np.max() * 10)], fprime=func_order1, rtol=0.02)
beta1 = np.maximum(beta1_res.root, 1e-10)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import sentencepiece as spm
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
i = obs_know.index(checked_sentence)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
while True:
    sys.stdout.write('>> ')
    sys.stdout.flush()
    line = sys.stdin.readline()
    stripped_line = line.rstrip()
    if (stripped_line == ''):
        continue
    bc.send_message(stripped_line)
    bc.fetch_messages()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
make_challenge(k, ignore_verification=False)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
import re
import numpy as np
import tensorflow as tf
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
iter(size)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
resolved_vocab_file = cached_path(vocab_file, cache_dir=cache_dir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
lvis_dt = LVISResults(lvis_gt, result_files[metric])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.mkdir(train_path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return '{}({}, {})'.format(self.__class__.__name__, self.n_samples, self.theta)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return accimage.Image(path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
strainer = Hyperopt(estimator=sample, max_evals=3, scoring='r2')
strained = strainer.fit(self.train_X, self.train_y)
assert isinstance(strained.get_pipeline(), TrainedOperator)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
mask = module.mask
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
x_val[b_v:e_v:s_v][i_v]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
for epoch in range(cfg.training.epochs):
    train(epoch, cfg)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
may_share_memory(a_, b_)
raise Exception('An error was expected')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
assert (pointer.shape == array.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
es = self.es
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
colors = [self._jitter([(x / 255) for x in self.metadata.thing_colors[c]]) for c in category_ids]
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with maybe_no_sync():
    (loss, sample_size_i, logging_output) = self.task.train_step(sample=sample, model=self.model, criterion=self.criterion, optimizer=self.optimizer, update_num=self.get_num_updates(), ignore_grad=is_dummy_batch)
    del loss
logging_outputs.append(logging_output)
sample_size += sample_size_i
if (self.cuda and (self.get_num_updates() == 0)):
    torch.cuda.empty_cache()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
model_class = model_classes.get('pt', AutoModel)
model = model_class.from_pretrained(model, **model_kwargs)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
del self[key]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return o2d2flow[oa_origin][oa_destination]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import cityscapesscripts.evaluation.evalInstanceLevelSemanticLabeling as CSEval
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
loss = self.compute_loss(batch)
self.backward(loss)
self.update_params()
oom_sync = False
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from sphinx.ext import apidoc
apidoc.main(argv)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
img = '../data/dataset/apple.jpg'
img = C.Decode()(img)
assert False
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
return getattr(module, class_name)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with open(path, 'rb') as f:
    img = cv2.imread(path)
    if (len(img.shape) == 2):
        img = np.stack(([img] * 3), 2)
    return img
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if match.group(2):
    number = int(entity_body, 16)
else:
    number = int(entity_body, 10)
if (128 <= number <= 159):
    return bytes((number,)).decode('cp1252')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
prec = self._pygen_classifier.get_section_precedence(section)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import apex.optimizers.fused_adam as fused_adam
optims['fused_adam'] = fused_adam.FusedAdam
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
alpha = (1 / nrm2(cx))
if (not np.isfinite(alpha)):
    raise FloatingPointError()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1
"
mode = Split[mode]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
f = open(script, 'rb')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(fd, path) = tempfile.mkstemp(suffix='.c', prefix=tmp_prefix)
exe_path = path[:(- 2)]
try:
    try:
        src_code = b(src_code)
    except Exception:
        pass
    os.write(fd, src_code)
    os.close(fd)
    fd = None
    (out, err, p_ret) = output_subprocess_Popen(([compiler, path, '-o', exe_path] + flags))
    if (p_ret != 0):
        compilation_ok = False
    elif try_run:
        (out, err, p_ret) = output_subprocess_Popen([exe_path])
        run_ok = (p_ret == 0)
finally:
    try:
        if (fd is not None):
            os.close(fd)
    finally:
        if os.path.exists(path):
            os.remove(path)
        if os.path.exists(exe_path):
            os.remove(exe_path)
        if os.path.exists((exe_path + '.exe')):
            os.remove((exe_path + '.exe'))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
target_tok_idx = tokens.index(stoken, s, e)
return target_tok_idx
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
font_bytes_path.decode('ascii')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0
"
from habitat.tasks.coverage.coverage import CoverageTask
has_covtask = True
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
no_copy = kwargs['no_copy']
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
j = word.index(first, i)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
f_gpumax = theano.function([guard_input], T.max(guard_input), mode='FAST_RUN')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
allLosses['alpha'] = self.getOriginalD().alpha
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return accimage.Image(path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
pointer = getattr(pointer, l[0])
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (self.ct2_model is not None):
    self.translator = CTranslate2Translator(self.ct2_model, device=('cuda' if self.opt.cuda else 'cpu'), device_index=(self.opt.gpu if self.opt.cuda else 0), batch_size=self.opt.batch_size, beam_size=self.opt.beam_size, n_best=self.opt.n_best, preload=preload)
else:
    self.translator = build_translator(self.opt, report_score=False, out_file=codecs.open(os.devnull, 'w', 'utf-8'))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
sent_tok = nltk.data.load(st_path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if self.start:
    parts.append(self.start)
if self.prec:
    parts.append(''.join([''.join(p) for p in self.prec]))
if self.tokens:
    parts.append(' '.join(self.tokens))
for f in self.pfuncs:
    if f[3]:
        parts.append(f[3])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0
"
assert (p_i.shape == arr_i.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
tmp_d = self.f_load_data(file_path, t_dim)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_archive_file = cached_path(archive_file, cache_dir=cache_dir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
xyz_tar = tarfile.open((script_dir + '/data/xyz_files.tar.gz'), 'r:gz')
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
while (n_filled < self.bptt):
    if ((streams[i] is None) or (len(streams[i]) <= 1)):
        streams[i] = next(sent_stream)
    n_new = min((len(streams[i]) - 1), (self.bptt - n_filled))
    data[(n_retain + n_filled):((n_retain + n_filled) + n_new), i] = streams[i][:n_new]
    target[n_filled:(n_filled + n_new), i] = streams[i][1:(n_new + 1)]
    streams[i] = streams[i][n_new:]
    n_filled += n_new
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return int(val)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
self._pusher.push(prefix=self._prefix)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex import amp
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
repo_dpath = dirname(dirname(__file__))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
a = float(x)
b = int(a)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0
"
run.observers.append(SlackObserver.from_config(run.config['slack_json_file']))
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
layer_pooling = int(layer_pooling)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
c2d = meta.stuff_dataset_id_to_contiguous_id
self._contiguous_id_to_dataset_id = {v: k for (k, v) in c2d.items()}
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
global_step = int(args.model_name_or_path.split('-')[(- 1)].split('/')[0])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
repo = git.Repo(search_parent_directories=True)
repo_infos = {'repo_id': str(repo), 'repo_sha': str(repo.head.object.hexsha), 'repo_branch': str(repo.active_branch), 'hostname': str(socket.gethostname())}
return repo_infos
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
gameid = os.listdir(f'{TRACKING_DIR}/{game_name}')[0].split('.')[0]
gameid2event_stream[gameid] = get_event_stream(gameid)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
format_name = WAVE_FORMAT(format_tag).name
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
return safe_round((base ** loss), round)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
cls = globals()[cls_name]
return cls(config)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
model_class = config.architectures[0]
transformers_module = __import__('transformers', fromlist=[model_class])
model_cls = getattr(transformers_module, model_class)
model = model_cls(config)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return self._sum
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return (Conf(config) if (key is None) else Conf(config[key]))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
nice = self.__nice__()
classname = self.__class__.__name__
return f'<{classname}({nice}) at {hex(id(self))}>'
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
load_tensorrt_plugin()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import re
import numpy as np
import tensorflow as tf
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
response = requests.head(url, allow_redirects=True, proxies=proxies, timeout=etag_timeout)
if (response.status_code != 200):
    etag = None
else:
    etag = response.headers.get('ETag')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (pointer.shape == array.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
data[key] = np.array([float(x) for x in value.split()])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
from sklearn.model_selection import train_test_split
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(url, filename) = args_tuple
if (not os.path.exists(filename)):
    urllib.urlretrieve(url, filename)
with open(filename) as f:
    assert (hashlib.sha1(f.read()).hexdigest() != MISSING_IMAGE_SHA1)
test_read_image = io.imread(filename)
return True
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
response = requests.head(url, allow_redirects=True, proxies=proxies)
if (response.status_code != 200):
    etag = None
else:
    etag = response.headers.get('ETag')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_archive_file = cached_path(archive_file, cache_dir=cache_dir, force_download=force_download, proxies=proxies, resume_download=resume_download, local_files_only=local_files_only)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return _cache[filename]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if self.tpu_name:
    tpu = tf.distribute.cluster_resolver.TPUClusterResolver(self.tpu_name, zone=self.tpu_zone, project=self.gcp_project)
else:
    tpu = tf.distribute.cluster_resolver.TPUClusterResolver()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
(new_conn, address) = self._sock_server.accept()
new_conn.setblocking(True)
epoll.register(new_conn.fileno(), (select.EPOLLIN | select.EPOLLHUP))
conns[new_conn.fileno()] = new_conn
logging.info('create new connection:client-ip:%s, client-port:%s, fd:%s', address[0], address[1], new_conn.fileno())
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
out = _minimal_ext_cmd(['git', 'rev-parse', 'HEAD'])
sha = out.strip().decode('ascii')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
filename = self.images[frame]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
acc = accuracy(preds, label)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
features = MAPPING[smiles]
assert (np.shape(features)[0] == 196)
return features
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
means[dataset][mean_key] = np.mean(np.array([v[mean_key] for v in flattened.values()]))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return random.choice(seq)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return self._shortid_to_longid[shortid]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
reference = IndirectReference((max(self.xref_table.keys()) + 1), 0)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
import re
import numpy as np
import tensorflow as tf
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (pointer.shape == array.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_config_file = cached_path(config_file, cache_dir=cache_dir, force_download=force_download, proxies=proxies)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(path, exist_ok=True)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return construct_arg(str(arg_annotation), argument_name, popped_params, arg_annotation, default, **extras)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0
"
import pyarrow.plasma as plasma
self._plasma = plasma
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
mol.GetAtomWithIdx(0).GetExplicitValence()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
state.wait_list.remove(dead_node)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
tm.set_time(torch.linspace(0, 10, 100)[None, :].repeat(6, 1))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
for file_name in os.listdir(os.path.join(task_directory_path, 'html')):
    self.task_files_to_copy.append(os.path.join(task_directory_path, 'html', file_name))
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
mode = Split[mode]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
nn.utils.remove_weight_norm(module)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
repo_dpath = dirname(dirname(__file__))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
old[attr] = getattr(roi_heads, attr)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
oldval = getattr(self, key)
assert (oldval == val), ""Attribute '{}' in the metadata of '{}' cannot be set to a different value!\n{} != {}"".format(key, self.name, oldval, val)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import cityscapesscripts.evaluation.evalInstanceLevelSemanticLabeling as CSEval
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import re
import numpy as np
import tensorflow as tf
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
last_state_index = (2 if self._module.bidirectional else 1)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
model[u'který']
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (a[i] != b[i]):
    dif_seq.append(i)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
model = meta['model']
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
bits = int(self.rawmode[2:])
if (bits not in [8, 16, 32]):
    self.tile = [('bit', ((0, 0) + self.size), offs, (bits, 8, 3, 0, (- 1)))]
    return
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
import cityscapesscripts.helpers.labels as CSLabels
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(self.root)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
result = getgrnam(name)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
n = _np.fromfile(stream, len_t, 1)[0]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if self.tpu_name:
    tpu = tf.distribute.cluster_resolver.TPUClusterResolver(self.tpu_name)
else:
    tpu = tf.distribute.cluster_resolver.TPUClusterResolver()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
x = zmatrix()
function([x], cast(x, 'float64'))(numpy.ones((2, 3), dtype='complex128'))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
self.stop_words = (set(stop_words) if (stop_words is not None) else None)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
from fairseq.modules.lightconv_layer import LightconvLayer
return LightconvLayer(input_size, kernel_size=kernel_size, padding_l=padding_l, num_heads=num_heads, weight_dropout=weight_dropout, weight_softmax=weight_softmax, bias=bias, with_linear=with_linear, out_dim=out_dim)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if ((self.affinity.get('master_cpus', None) is not None) and self.affinity.get('set_affinity', True)):
    p.cpu_affinity(self.affinity['master_cpus'])
cpu_affin = p.cpu_affinity()
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(features, dataset, examples) = (features_and_dataset['features'], features_and_dataset['dataset'], features_and_dataset['examples'])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with open(config_path) as f_config:
    config = yaml.safe_load(f_config)
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
A_ub = _format_A_constraints(A_ub, n_x, sparse_lhs=sparse_lhs)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
from apex.optimizers import FP16_Optimizer
from apex.optimizers import FusedAdam
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
text_a = line[3]
text_b = line[4]
label = line[5]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(yield)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(root)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return (self.network == other.network)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import tensorflow as tf
import torch
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
last_lr = self.lr_scheduler.get_last_lr()[0]
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import kwarray
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
stats = os.stat(pathname)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
prompt_idx = self.prompt_label_idx[classrowid][colid]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(firstaxis, parity, repetition, frame) = _AXES2TUPLE[axes.lower()]
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
for o in range(1, (num_objects + 1)):
    frame_batch.append(frame)
    mask_batch.append(masks[:, o])
for o in range(1, (num_objects + 1)):
    bg_batch.append(torch.clamp((1.0 - masks[:, o]), min=0.0, max=1.0))
frame_batch = torch.cat(frame_batch, dim=0)
mask_batch = torch.cat(mask_batch, dim=0)
bg_batch = torch.cat(bg_batch, dim=0)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
location = dlimport_workdir(self.dirname)
module = lnk.compile_cmodule(location)
name = module.__file__
assert name.startswith(location)
assert (name not in self.module_from_name)
self.module_from_name[name] = module
nocleanup = True
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.exprs = list(exprs)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
tag = next((tag for tag in available_tags if (tag.name == tag_name)))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
httpd.serve_forever()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
m.bias.data.zero_()
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (self.config.mode == 'test'):
    print('-------test------------')
    start = time.time()
    self.test('test')
    self.time_record = (time.time() - start)
else:
    self.train()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex.normalization import FusedProphetNetLayerNorm
return FusedProphetNetLayerNorm(normalized_shape, eps, elementwise_affine)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.writer = importlib.import_module('tensorboardX').SummaryWriter(log_dir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from fairseq.data.token_block_utils_fast import _get_slice_indices_fast, _get_block_to_dataset_index_fast
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
out = _minimal_ext_cmd(['git', 'rev-parse', 'HEAD'])
sha = out.strip().decode('ascii')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (pointer.shape == array.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
extant = (prefix + target)
__import__(extant)
mod = sys.modules[extant]
sys.modules[fullname] = mod
if (sys.version_info >= (3,)):
    del sys.modules[extant]
return mod
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
pointer = getattr(pointer, l[0])
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
line = line.decode('utf-8')
if (len(line) == 0):
    continue
tokens = line.split()
if (len(tokens) < embedd_dim):
    continue
if (embedd_dim < 0):
    embedd_dim = (len(tokens) - 1)
embedd = np.empty([1, embedd_dim], dtype=np.float32)
start = (len(tokens) - embedd_dim)
word = ' '.join(tokens[0:start])
embedd[:] = tokens[start:]
word = (DIGIT_RE.sub(b'0', word) if normalize_digits else word)
embedd_dict[word] = embedd
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0
"
os.remove(self._fileid)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (not punkt_data_path):
    punkt_data_path = self.lang2datapath[language]
self.sent_detector = nltk.data.load(punkt_data_path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (os.environ.get('WERKZEUG_RUN_MAIN') == 'true'):
    ensure_echo_on()
    t = threading.Thread(target=main_func, args=())
    t.setDaemon(True)
    t.start()
    reloader.run()
else:
    sys.exit(reloader.restart_with_reloader())
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
nice = self.__nice__()
classname = self.__class__.__name__
return f'<{classname}({nice}) at {hex(id(self))}>'
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.n_components = int(self.n_components)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
with torch.no_grad():
    '\n                NEW: batch_predictions can now be of shape (batch_size,batch_max_seq_len,topk) if topk>1, else (batch_size,batch_max_seq_len)\n                '
    (batch_loss, batch_predictions) = model(batch_idxs, inverted_mask, batch_lengths, batch_elmo_inp, targets=batch_labels, topk=topk)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
sampler = CircuitSampler(quantum_instance)
result = sampler.convert(exp).eval()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
os.makedirs(ARGS.output_dir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
observation.force_set('text', (config['prefix'] + observation['text']))
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import cityscapesscripts.evaluation.evalInstanceLevelSemanticLabeling as CSEval
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex.parallel import DistributedDataParallel as DDP
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
nn.init.xavier_uniform_(m.weight.data)
m.bias.data.fill_(0)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
float(div_height)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0
"
img = Image.open(img_path).convert('RGB')
got_img = True
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
label = name2label[label_name]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
value = int(unparsed_args[(i + 1)])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
repo_dpath = dirname(dirname(__file__))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
state_dict = torch.load(pretrain_path, map_location=torch.device('cpu'))['model_state']
logger.info(f'Loading pretrained model from {pretrain_path}')
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self._data = json.loads(data)
self._validate_mapping(self._data, scheme)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
DEPvec.append(validDEPS.index(w.dep_.lower()))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
os.chmod(targetpath, tarinfo.mode)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
shape_dtype_device_match = ((a.size() == b.size()) and (a.dtype == b.dtype) and (a.device == b.device))
if (not shape_dtype_device_match):
    if raise_exception:
        msg = f'sizes: {a.size()} vs. {b.size()}, '
        msg += f'types: {a.dtype} vs. {b.dtype}, '
        msg += f'device: {a.device} vs. {b.device}'
        raise AssertionError(msg)
    else:
        return False
torch.testing.assert_allclose(a, b)
return True
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
model_left_context = variables['model_left_context']
model_right_context = variables['model_right_context']
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with maybe_no_sync():
    (loss, sample_size_i, logging_output) = self.task.train_step(sample=sample, model=self.model, criterion=self.criterion, optimizer=self.optimizer, update_num=self.get_num_updates(), ignore_grad=is_dummy_batch, **extra_kwargs)
    del loss
logging_outputs.append(logging_output)
sample_size += sample_size_i
if (self.cuda and (self.get_num_updates() == 0)):
    torch.cuda.empty_cache()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_corpus_file = cached_path(corpus_file, cache_dir=cache_dir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (pointer.shape == array.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
_args_pair = [cs.split('=') for cs in _list[1:]]
_args = {k: float(v) for (k, v) in _args_pair}
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
import requests
response = requests.head(url, allow_redirects=True)
if (response.status_code != 200):
    etag = None
else:
    etag = response.headers.get('ETag')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
path = self.road.network.shortest_path(self.lane_index[1], destination)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (p_i.shape == arr_i.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex import amp
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
nvml.nvmlInit()
devices = (list(range(nvml.nvmlDeviceGetCount())) if (gpus_to_trace is None) else gpus_to_trace)
nvml.nvmlShutdown()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
img = self.game.get_state().screen_buffer
img = np.transpose(img, [1, 2, 0])
(h, w) = img.shape[:2]
render_w = 640
if (w < render_w):
    render_h = int(((640 * h) / w))
    img = cv2.resize(img, (render_w, render_h))
if (self.viewer is None):
    from gym.envs.classic_control import rendering
    self.viewer = rendering.SimpleImageViewer(maxwidth=800)
self.viewer.imshow(img)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (pointer.shape == array.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with open(name, 'rb') as fh:
    return fh.read()
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
shell = get_ipython().__class__.__name__
if (shell == 'ZMQInteractiveShell'):
    return True
elif (shell == 'TerminalInteractiveShell'):
    return False
else:
    return False
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import nltk
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex import amp
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
label = name2label[label_name]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
f = h5py.File(self.detections_path, 'r')
det_cls_probs = f[('%s_cls_prob' % id_image)][()]
det_features = f[('%s_features' % id_image)][()]
det_boxes = f[('%s_boxes' % id_image)][()]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
opt.gpu_rank = onmt.utils.distributed.multi_init(opt)
single_main(opt)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
""\n            for dtype in ['int8', 'uint8', 'short', 'ushort', 'intc', 'uintc',\n                          'longlong', 'ulonglong', 'single', 'double',\n                          'longdouble', 'csingle', 'cdouble', 'clongdouble',\n                          'float32', 'float64', 'int8', 'int16', 'int32',\n                          'int64', 'uint8', 'uint16', 'uint32', 'uint64',\n                          'complex64', 'complex128', 'float', 'double',\n                          'int', 'uint']:\n                print(dtype, np.zeros(1, dtype=dtype).dtype.num)\n            ""
return {'float16': (numpy.float16, 'npy_float16', 'Float16'), 'float32': (numpy.float32, 'npy_float32', 'Float32'), 'float64': (numpy.float64, 'npy_float64', 'Float64'), 'complex128': (numpy.complex128, 'theano_complex128', 'Complex128'), 'complex64': (numpy.complex64, 'theano_complex64', 'Complex64'), 'uint8': (numpy.uint8, 'npy_uint8', 'UInt8'), 'int8': (numpy.int8, 'npy_int8', 'Int8'), 'uint16': (numpy.uint16, 'npy_uint16', 'UInt16'), 'int16': (numpy.int16, 'npy_int16', 'Int16'), 'uint32': (numpy.uint32, 'npy_uint32', 'UInt32'), 'int32': (numpy.int32, 'npy_int32', 'Int32'), 'uint64': (numpy.uint64, 'npy_uint64', 'UInt64'), 'int64': (numpy.int64, 'npy_int64', 'Int64')}[self.dtype]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
colors = [self._jitter([(x / 255) for x in self.metadata.thing_colors[c]]) for c in category_ids]
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
nonlinearity = {'RNN_TANH': 'tanh', 'RNN_RELU': 'relu'}[rnn_type]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
subprocess.call(['doxygen', '--version'])
retcode = subprocess.call(['doxygen'], cwd=app.confdir)
if (retcode < 0):
    sys.stderr.write('doxygen error code: {}\n'.format((- retcode)))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(features, dataset, examples) = (features_and_dataset['features'], features_and_dataset['dataset'], features_and_dataset['examples'])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.odtype
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
mask_color = [(x / 255) for x in self.metadata.stuff_colors[label]]
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from .convert_tf_checkpoint_to_pytorch import convert_tf_checkpoint_to_pytorch
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from multidict import CIMultiDict
return CIMultiDict(*args, **kwargs)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
embeddings.append(torch.cat((h, u_k[n_inners[j]:n_level[j]]), 0))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
from transformers.convert_gpt2_original_tf_checkpoint_to_pytorch import convert_gpt2_checkpoint_to_pytorch
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (not ignore_utf_errors):
    with open(f, 'r', encoding='utf-8') as fd:
        self.add_from_file(fd)
else:
    with open(f, 'r', encoding='utf-8', errors='ignore') as fd:
        self.add_from_file(fd)
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(log_dir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import tensorflow as tf
import torch
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(folder_output)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
img = misc.imread(image_path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
ps_font_info_weight = (font.get_ps_font_info()['weight'].replace(' ', '') or '')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
with open(datafile, 'rb') as open_file:
    npzfile = np.load(open_file)
    ground_truth = npzfile['ground_truth'].squeeze()
    predictions = npzfile['predictions'].squeeze()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return f.readline()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0
"
text_a = line[3]
text_b = line[4]
label = line[5]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
selection = input_array[selector]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0
"
config_dict = yaml.load(config_file, Loader=yaml.FullLoader)
return config_dict
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
(t_imgs, t_pids) = next(self.target)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_vocab_files = {}
for (file_id, file_path) in vocab_files.items():
    if (file_path is None):
        resolved_vocab_files[file_id] = None
    else:
        resolved_vocab_files[file_id] = cached_path(file_path, cache_dir=cache_dir, force_download=force_download, proxies=proxies, resume_download=resume_download, local_files_only=local_files_only)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from espnet_model_zoo.downloader import ModelDownloader
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
token_classification_task_clazz = getattr(module, model_args.task_type)
token_classification_task: TokenClassificationTask = token_classification_task_clazz()
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_corpus_file = cached_path(corpus_file, cache_dir=cache_dir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
value = type(value)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
resolved_archive_file = cached_path(archive_file, cache_dir=cache_dir, force_download=force_download, proxies=proxies, resume_download=resume_download)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_vocab_file = cached_path(vocab_file, cache_dir=cache_dir)
resolved_merges_file = cached_path(merges_file, cache_dir=cache_dir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
view_names = inspector.get_view_names()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from transformers import load_tf2_checkpoint_in_pytorch_model
model = load_tf2_checkpoint_in_pytorch_model(model, resolved_archive_file, allow_missing_keys=True)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
number = int(no_comma_word)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
bleu = corpus_bleu(self.refs, self.hyps, weights=weights, smoothing_function=SmoothingFunction().method3)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1
"
import re
import numpy as np
import tensorflow as tf
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return (kernal // 3)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
self.value = float(self.param_str)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
i = rstack.index(r)
sd = (l - i)
stack_distances.insert(0, sd)
rstack.pop(i)
rstack.insert((l - 1), r)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
import regex as re
self.re = re
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
line = next(self.random_file).strip()
if (line == ''):
    self.current_random_doc = (self.current_random_doc + 1)
    line = next(self.random_file).strip()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (not deployment_path):
    GrassOnPremisesExecutor.leave(leave_cluster_deployment={})
else:
    with open(deployment_path, 'r') as fr:
        leave_cluster_deployment = yaml.safe_load(stream=fr)
    if (leave_cluster_deployment['mode'] == 'grass/on-premises'):
        GrassOnPremisesExecutor.leave(leave_cluster_deployment=leave_cluster_deployment)
    else:
        raise BadRequestError(f""Unsupported operation in mode '{leave_cluster_deployment['mode']}'."")
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
server_name = socket.gethostname()
return server_name
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import instaboostfast as instaboost
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
value = int(value)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
val_loss_dict[key] += value
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return self._dirindex
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
_ = iter(items)
for item in items:
    self.T = type(item)
    if (self.T not in (Entity, Source)):
        raise TypeError()
    break
self.add(items)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
delattr(cls, ('_pyro_' + type))
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (pointer.shape == array.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
cy_thresh = (np.finfo(M.dtype).eps * 4)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
import kwarray
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (p_i.shape == arr_i.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
expr_parse(instring, tmploc, doActions=False, callPreParse=False)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
actual_shape = dist.entropy().size()
expected_shape = (dist.batch_shape if dist.batch_shape else torch.Size())
message = '{} example {}/{}, shape mismatch. expected {}, actual {}'.format(Dist.__name__, (i + 1), len(params), expected_shape, actual_shape)
self.assertEqual(actual_shape, expected_shape, msg=message)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
db = apsw.Connection(':memory:')
db.createscalarfunction('foo', (lambda x: u('another unicode string')))
for row in db.cursor().execute('select foo(3)'):
    pass
(1 / 0)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex.parallel import DistributedDataParallel as DDP
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
my_module = load_task_module(opt['task'])
task_agents = my_module.create_agents(opt)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import sentencepiece as spm
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (k['address'] == 0):
    continue
elif (k['head'] == 0):
    triple.append((('ROOT', (k['head'] - 1)), (words[(k['address'] - 1)], (k['address'] - 1)), k['rel']))
else:
    triple.append(((words[(k['head'] - 1)], (k['head'] - 1)), (words[(k['address'] - 1)], (k['address'] - 1)), k['rel']))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex import amp
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.cur_dataset = next(dataset_iter)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return super().__getattr__(name)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
item['target_text'] = self.data['target'][index]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import re
import numpy as np
import tensorflow as tf
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if hasattr(self, 'cur_dataset'):
    self.cur_dataset = None
    gc.collect()
    del self.cur_dataset
    gc.collect()
self.cur_dataset = next(dataset_iter)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (list(pt_weight.shape) == list(array.shape))
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
for _ in range(self.chunk_size):
    chunk.append(next(self.itr))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from pavi import modelcloud
from pavi.exception import NodeNotFoundError
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
pointer = getattr(pointer, l[0])
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
font = ImageFont.truetype('/usr/share/fonts/truetype/freefont/FreeSans.ttf', (im_height / 10))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
char = char.encode('ascii', errors='ignore').decode('ascii')
if (char != ''):
    inputs[((idx - empty_count), string_map[char])] = 1
else:
    empty_count += 1
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from fairseq.data.data_utils_fast import batch_by_size_fast
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
fig.canvas._draw()
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
hd_image = self.nicer.single_image_pass_can(self.reference_img1_fullSize.resize((width, height)), abn=True)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
traced_gpt2 = torch.jit.trace(model, inputs)
torch.jit.save(traced_gpt2, 'traced_model.pt')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.use_upsample_conv = bool(config['use_upsample_conv'])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
compression_scheduler.load_state_dict(checkpoint['compression_sched'], normalize_keys)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
fst_period_idx = words.index('.')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
numpy_include = np.get_include()
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import editdistance as ed
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
classname = self.__class__.__name__
nice = self.__nice__()
return '<{0}({1})>'.format(classname, nice)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with open(filename, 'r') as f:
    cfg_dict = yaml.load(f, Loader)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex.optimizers import FP16_Optimizer
from apex.optimizers import FusedAdam
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
span_label = labels_[idx_].split('_')[1]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
while (epoch < opt.train_num_batches):
    epoch += 1
    fcn.train()
    start_time = datetime.now()
    (train_auc_epoch, train_auc_std_epoch, train_loss_epoch) = do_epoch(epoch=epoch, repetitions=1, opt=opt, data_loader=train_loader, fcn=fcn, logger=logger, optimizer=optimizer)
    time_elapsed = (datetime.now() - start_time)
    print('[train]', 'epoch: ', epoch, ', loss: ', train_loss_epoch, ', auc: ', train_auc_epoch, ', auc_std: ', train_auc_std_epoch, ', time: ', time_elapsed.seconds, 's:', (time_elapsed.microseconds / 1000))
    logger.log_value('train_auc', train_auc_epoch)
    logger.log_value('train_auc_std', train_auc_std_epoch)
    logger.log_value('train_loss', train_loss_epoch)
    scheduler.step(train_loss_epoch)
    if ((epoch % opt.val_freq) == 0):
        fcn.eval()
        start_time = datetime.now()
        (val_auc_epoch, val_auc_std_epoch, val_loss_epoch) = do_epoch(epoch=epoch, repetitions=opt.val_num_batches, opt=opt, data_loader=val_loader, fcn=fcn, logger=logger, optimizer=None)
        time_elapsed = (datetime.now() - start_time)
        print(('====' * 20), '\n', ((('[' + multiprocessing.current_process().name) + ']') + '[VAL]'), 'epoch: ', epoch, ', loss: ', val_loss_epoch, ', auc: ', val_auc_epoch, ', auc_std: ', val_auc_std_epoch, ', time: ', time_elapsed.seconds, 's:', (time_elapsed.microseconds / 1000), 'ms\n', ('====' * 20))
        logger.log_value('val_auc', val_auc_epoch)
        logger.log_value('val_auc_std', val_auc_std_epoch)
        logger.log_value('val_loss', val_loss_epoch)
        is_model_saved = False
        if (best_auc < (saving_threshold * val_auc_epoch)):
            print('[{}] Significantly improved validation loss from {} --> {}. accuracy from {} --> {}. Saving...'.format(multiprocessing.current_process().name, best_validation_loss, val_loss_epoch, best_auc, best_auc))
            torch.save(fcn.state_dict(), opt.wrn_save)
            torch.save(optimizer.state_dict(), opt.arc_optimizer_path)
            best_validation_loss = val_loss_epoch
            best_auc = val_auc_epoch
            is_model_saved = True
        if is_model_saved:
            fcn.eval()
            start_time = datetime.now()
            (test_auc_epoch, test_auc_std_epoch, _) = do_epoch(epoch=epoch, repetitions=opt.test_num_batches, opt=opt, data_loader=test_loader, fcn=fcn, logger=logger, optimizer=None)
            time_elapsed = (datetime.now() - start_time)
            print(('====' * 20), '\n', ((('[' + multiprocessing.current_process().name) + ']') + '[TEST] SET1'), 'epoch: ', epoch, ', auc: ', test_auc_epoch, ', auc_std: ', test_auc_std_epoch, ', time: ', time_elapsed.seconds, 's:', (time_elapsed.microseconds / 1000), 'ms\n', ('====' * 20))
            logger.log_value('test_set1_auc', test_auc_epoch)
            logger.log_value('test_set1_auc_std', test_auc_epoch)
            start_time = datetime.now()
            test_loader2.dataset.mode = 'generator_processor'
            (test_auc_epoch, test_auc_std_epoch, _) = do_epoch(epoch=epoch, repetitions=opt.test_num_batches, opt=opt, data_loader=test_loader2, fcn=fcn, logger=logger)
            time_elapsed = (datetime.now() - start_time)
            print(('====' * 20), '\n', ((('[' + multiprocessing.current_process().name) + ']') + '[TEST] SET2. '), 'epoch: ', epoch, ', auc: ', test_auc_epoch, ', auc_std: ', test_auc_std_epoch, ', time: ', time_elapsed.seconds, 's:', (time_elapsed.microseconds / 1000), 'ms\n', ('====' * 20))
            logger.log_value('test_set2_auc', test_auc_epoch)
            logger.log_value('test_set2_auc_std', test_auc_std_epoch)
    train_loader.dataset.remove_path_tmp_epoch(epoch)
    val_loader.dataset.remove_path_tmp_epoch(epoch)
    test_loader.dataset.remove_path_tmp_epoch(epoch)
    logger.step()
print(('[%s] ... training done' % multiprocessing.current_process().name))
print(('[%s], best validation accuracy: %.2f, best validation loss: %.5f' % (multiprocessing.current_process().name, best_auc, best_validation_loss)))
print(('[%s] ... exiting training regime ' % multiprocessing.current_process().name))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (utt[:(len(prefix) + 1)] == (prefix + ' '))
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
offset = nti(buf[pos:(pos + 12)])
numbytes = nti(buf[(pos + 12):(pos + 24)])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
state_dict[weight_name] = adapt_input_conv(in_chans, state_dict[weight_name], agg='avg')
print(f'Converted input conv {input_conv_name} pretrained weights from 3 to {in_chans} channel(s)')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (not isinstance(profile, ImageCmsProfile)):
    profile = ImageCmsProfile(profile)
return ((profile.profile.profile_description or '') + '\n')
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0
"
value = super(ConfigDict, self).__getattr__(name)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
nobody = pwd.getpwnam('nobody')[2]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
tokenizer = cls(*init_inputs, **init_kwargs)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
for (token, ix) in self.token2ix_data.items():
    if (self.ix2token_data[ix] != token):
        return False
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
mask = np.array([getmaskarray(np.asanyarray(m, dtype=mdtype)) for m in data], dtype=mdtype)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
del self.imageCache[self.imageId]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
mask = np.array(mask, copy=copy, dtype=mdtype)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
(mesh, stats_dict) = out
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
import regex as re
self.re = re
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
null[:] = self._null_value
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
last_line = encoded_lines.pop()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if re.search('^(ark|scp)(,scp|,b|,t|,n?f|,n?p|,b?o|,n?s|,n?cs)*:', file):
    (prefix, file) = file.split(':', 1)
if re.search(':[0-9]+$', file):
    (file, offset) = file.rsplit(':', 1)
if (file[(- 1)] == '|'):
    fd = popen(file[:(- 1)], 'rb')
elif (file[0] == '|'):
    fd = popen(file[1:], 'wb')
elif (file.split('.')[(- 1)] == 'gz'):
    fd = gzip.open(file, mode)
else:
    fd = open(file, mode)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
true_transcript = transcript_dict[audio_file_json_key]
true_transcript = true_transcript.lower()
true_transcript = true_transcript.replace('.', '')
true_transcript = true_transcript.replace('é', 'e')
true_transcript = true_transcript.replace('\\', ' ')
true_transcript = true_transcript.replace(',', '')
true_transcript = true_transcript.replace('?', '')
true_transcript = true_transcript.replace('!', '')
true_transcript = regex.sub(' +', ' ', true_transcript)
WER = jiwer.wer(true_transcript, danspeech_transcript)
WER_list.append(WER)
sentence_lenght.append(len(true_transcript.split()))
possiible_true_transcript.append(true_transcript)
possiible_danspeech_transcript.append(danspeech_transcript)
possiible_audio_file.append(audio_file)
speaker_id_list.append(speaker_id[:(- 5)])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(args.save_dir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return dialect._type_memos[self]['literal']
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import torch
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import requests
response = requests.head(url, allow_redirects=True)
if (response.status_code != 200):
    etag = None
else:
    etag = response.headers.get('ETag')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import accimage
return accimage.Image(path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
is_version = isinstance(parsed_version, packaging.version.Version)
spec = ('%s==%s' if is_version else '%s===%s')
list(parse_requirements((spec % (self.egg_name, self.egg_version))))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
setattr(self, key, value)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return self.reward_normalizer.evaluate(self.q_max)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
s = next(os.walk(path))[1]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return float(frac_str)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
resolved_vocab_files = {}
for (file_id, file_path) in vocab_files.items():
    if (file_path is None):
        resolved_vocab_files[file_id] = None
    else:
        resolved_vocab_files[file_id] = cached_path(file_path, cache_dir=cache_dir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
result = lib.maybe_convert_numeric(values, na_values, False)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0
"
major_version = cv2.__version__.split('.')[0]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
if (not self._module.batch_first):
    raise ConfigurationError('Our encoder semantics assumes batch is always first!')
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return l.index(index)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
table_rho = np.load(rho_fname)
table_radii = np.load(radii_fname)
print(('Found and loaded saved table: ' + basename))
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
loss = self.compute_loss(self._dummy_batch(batchsize, maxlen))
self.backward(loss)
self.buffer_initialized = True
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_archive_file = cached_path(archive_file, cache_dir=cache_dir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
value = ast.literal_eval(value)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
from torch.utils.tensorboard import SummaryWriter
self._SummaryWriter = SummaryWriter
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from ..models.t5.convert_t5_original_tf_checkpoint_to_pytorch import convert_tf_checkpoint_to_pytorch
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (not sprite_or_drape.visible):
    return None
return tuple(sprite_or_drape.position)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
cmd_name = args[0]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex import amp
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
get_lab_example(hparams, lab, expt)
hparams['animal'] = animal
hparams['session'] = session
(hparams['session_dir'], sess_ids) = get_session_dir(hparams)
hparams['expt_dir'] = get_expt_dir(hparams)
(_, version) = experiment_exists(hparams, which_version=True)
print(('loading results with alpha=%i, beta=%i, (version %i)' % (hparams['ps_vae.alpha'], hparams['ps_vae.beta'], version)))
metrics_dfs_frame_bg.append(load_metrics_csv_as_df(hparams, lab, expt, metrics_list, version=None, test=True))
metrics_dfs_frame_bg[(- 1)]['beta'] = beta
(model, data_gen) = get_best_model_and_data(hparams, Model=None, load_data=True, version=version)
metrics_df_ = get_label_r2(hparams, model, data_gen, version, label_names, dtype='val')
metrics_df_['beta'] = beta
metrics_dfs_marker_bg.append(metrics_df_[(metrics_df_.Model == 'PS-VAE')])
latents = load_latents(hparams, version, dtype='test')
if (batch_size is None):
    corr = np.corrcoef(latents[:, (n_labels + np.array([0, 1]))].T)
    metrics_dfs_corr_bg.append(pd.DataFrame({'loss': 'corr', 'dtype': 'test', 'val': np.abs(corr[(0, 1)]), 'beta': beta}, index=[0]))
else:
    n_batches = int(np.ceil((latents.shape[0] / batch_size)))
    for i in range(n_batches):
        corr = np.corrcoef(latents[(i * batch_size):((i + 1) * batch_size), (n_labels + np.array([0, 1]))].T)
        metrics_dfs_corr_bg.append(pd.DataFrame({'loss': 'corr', 'dtype': 'test', 'val': np.abs(corr[(0, 1)]), 'beta': beta}, index=[0]))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
expr_parse(instring, tmploc, doActions=False, callPreParse=False)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(os.path.join(opt.outf, 'mix_images'))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import re
import numpy as np
import tensorflow as tf
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from nltk.tokenize import word_tokenize
self.word_tokenize = word_tokenize
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
m.clear_buffer()
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex import amp
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import re
import numpy as np
import tensorflow as tf
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
while (vid.isOpened() and running):
    while (frame_buffer.qsize() > 100):
        time.sleep(0.001)
    start_time = time.time()
    if (not vid_done):
        next_frames = pool.apply_async(get_next_frame, args=(vid,))
    else:
        next_frames = None
    if (not (vid_done and (len(active_frames) == 0))):
        for frame in active_frames:
            _args = [frame['value']]
            if (frame['idx'] == 0):
                _args.append(fps_str)
            frame['value'] = pool.apply_async(sequence[frame['idx']], args=_args)
        for frame in active_frames:
            if (frame['idx'] == 0):
                frame_buffer.put(frame['value'].get())
        active_frames = [x for x in active_frames if (x['idx'] > 0)]
        for frame in list(reversed(active_frames)):
            frame['value'] = frame['value'].get()
            frame['idx'] -= 1
            if (frame['idx'] == 0):
                active_frames += [{'value': extract_frame(frame['value'], i), 'idx': 0} for i in range(1, len(frame['value'][0]))]
                frame['value'] = extract_frame(frame['value'], 0)
        if (next_frames is not None):
            frames = next_frames.get()
            if (len(frames) == 0):
                vid_done = True
            else:
                active_frames.append({'value': frames, 'idx': (len(sequence) - 1)})
        frame_times.add((time.time() - start_time))
        fps = (args.video_multiframe / frame_times.get_avg())
    else:
        fps = 0
    fps_str = ('Processing FPS: %.2f | Video Playback FPS: %.2f | Frames in Buffer: %d' % (fps, video_fps, frame_buffer.qsize()))
    if (not args.display_fps):
        print((('\r' + fps_str) + '    '), end='')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
model_class = config.architectures[0]
transformers_module = __import__('transformers', fromlist=[model_class])
model_cls = getattr(transformers_module, model_class)
model = model_cls(config)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(rawmode, mode) = _OUTMODES[mode]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
rby = right.groupby(by, sort=False)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
item_chunk = next(self._data)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
clip.write_gif(filename, verbose=False, progress_bar=False)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
BType = self._cached_btypes[type]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from onmt.inputters.inputter import _old_style_vocab
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex.parallel import DistributedDataParallel as DDP
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
for epoch in range(start_epoch, num_epochs):
    if (args.distributed and hasattr(loader_train.sampler, 'set_epoch')):
        loader_train.sampler.set_epoch(epoch)
    train_metrics = train_one_epoch(epoch, model, loader_train, optimizer, train_loss_fn, args, lr_scheduler=lr_scheduler, saver=saver, output_dir=output_dir, amp_autocast=amp_autocast, loss_scaler=loss_scaler, model_ema=model_ema, mixup_fn=mixup_fn)
    if (args.distributed and (args.dist_bn in ('broadcast', 'reduce'))):
        if (args.local_rank == 0):
            _logger.info('Distributing BatchNorm running means and vars')
        distribute_bn(model, args.world_size, (args.dist_bn == 'reduce'))
    eval_metrics = validate(model, loader_eval, validate_loss_fn, args, amp_autocast=amp_autocast)
    if ((model_ema is not None) and (not args.model_ema_force_cpu)):
        if (args.distributed and (args.dist_bn in ('broadcast', 'reduce'))):
            distribute_bn(model_ema, args.world_size, (args.dist_bn == 'reduce'))
        ema_eval_metrics = validate(model_ema.module, loader_eval, validate_loss_fn, args, amp_autocast=amp_autocast, log_suffix=' (EMA)')
        eval_metrics = ema_eval_metrics
    if (lr_scheduler is not None):
        lr_scheduler.step((epoch + 1), eval_metrics[eval_metric])
    if (output_dir is not None):
        update_summary(epoch, train_metrics, eval_metrics, os.path.join(output_dir, 'summary.csv'), write_header=(best_metric is None), log_wandb=(args.log_wandb and has_wandb))
    if (saver is not None):
        save_metric = eval_metrics[eval_metric]
        (best_metric, best_epoch) = saver.save_checkpoint(epoch, metric=save_metric)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
selection = 'sele, chain {} and resi {}'.format(*residue_id)
with silence_stdout(), silence_stderr():
    selections = freesasa.selectArea([selection], sasa_struct, sasa)
    residue_area = selections['sele']
self.residue_asa[residue_id] = residue_area
return residue_area
",0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
t = next(it)
for i in range(len(max_shape)):
    max_shape[i] = int(max(max_shape[i], t.shape[i]))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
z = z2Name.index(sz.strip('-'))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
assert (pointer.shape == array.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from lvis import LVISResults, LVISEval
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if self.start:
    parts.append(self.start)
if self.prec:
    parts.append(''.join([''.join(p) for p in self.prec]))
if self.tokens:
    parts.append(' '.join(self.tokens))
for f in self.pfuncs:
    if f[3]:
        parts.append(f[3])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0
"
subprocess.check_call(['gs', '--version'], stdout=subprocess.DEVNULL)
return True
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
agents_mask = self.dataset.root[f'agents_mask/{agent_prob}']
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from torchvision import _C as C
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from pandas import DataFrame
types.append(DataFrame)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (pointer.shape == array.shape), f'Pointer shape {pointer.shape} and array shape {array.shape} mismatched'
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from fairseq import libnat_cuda
return (libnat_cuda, True)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.nuisance_mode_default = str(settings['nuisance_mode_default'])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
nonlinearity = {'RNN_TANH': 'tanh', 'RNN_RELU': 'relu'}[rnn_type]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(eval_log_dir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
float(target)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
require_version_core(req)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
f_iter = iter(f)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
print(f'  loss: {self.loss_fn.__name__}')
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
repo_dpath = dirname(dirname(__file__))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
for p in zip(x, y):
    pxy[p] += 1
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
return self._pkg_info
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (pointer.shape == array.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
print('Epoch {}'.format((epoch + 1)))
self.model.train()
avg_losses[epoch] = self.train_epoch()
print('Average loss = {:.3f}'.format(avg_losses[epoch]))
if ((min_loss is None) or (min_loss >= avg_losses[epoch])):
    min_loss = avg_losses[epoch]
    best_model = self.model.state_dict()
if (((epoch + 1) % 5) == 0):
    self.save_model(best_model, path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with open(name, 'rb') as fh:
    return fh.read()
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return next(self.finite_iterable)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
sig = inspect.signature(self.__init__)
classname = type(self).__name__
argstr = []
for (name, param) in sig.parameters.items():
    assert ((param.kind != param.VAR_POSITIONAL) and (param.kind != param.VAR_KEYWORD)), ""The default __repr__ doesn't support *args or **kwargs""
    assert hasattr(self, name), 'Attribute {} not found! Default __repr__ only works if attributes match the constructor.'.format(name)
    attr = getattr(self, name)
    default = param.default
    if (default is attr):
        continue
    argstr.append('{}={}'.format(name, pprint.pformat(attr)))
return '{}({})'.format(classname, ', '.join(argstr))
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import tensorflow_datasets as tfds
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return spaces.Box(shape=self.observe().shape, low=0, high=1, dtype=np.float32)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
batch = self.buffer.pop(0)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import cityscapesscripts.helpers.labels as CSLabels
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import torch.__config__
return torch.__config__.show()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return chr(number)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
return (self.model[word], word)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import sentencepiece as spm
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
stream.write(('%s\n' % msg))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0
"
while True:
    if epoch_done:
        if ((not opt.noamopt) and (not opt.reduce_on_plateau)):
            if ((epoch > opt.learning_rate_decay_start) and (opt.learning_rate_decay_start >= 0)):
                frac = ((epoch - opt.learning_rate_decay_start) // opt.learning_rate_decay_every)
                decay_factor = (opt.learning_rate_decay_rate ** frac)
                opt.current_lr = (opt.learning_rate * decay_factor)
            else:
                opt.current_lr = opt.learning_rate
            utils.set_lr(optimizer, opt.current_lr)
        if ((epoch > opt.scheduled_sampling_start) and (opt.scheduled_sampling_start >= 0)):
            frac = ((epoch - opt.scheduled_sampling_start) // opt.scheduled_sampling_increase_every)
            opt.ss_prob = min((opt.scheduled_sampling_increase_prob * frac), opt.scheduled_sampling_max_prob)
            model.ss_prob = opt.ss_prob
        if ((opt.self_critical_after != (- 1)) and (epoch >= opt.self_critical_after)):
            sc_flag = True
            init_scorer(opt.cached_tokens)
        else:
            sc_flag = False
        epoch_done = False
    start = time.time()
    if ((opt.use_warmup == 1) and (iteration < opt.noamopt_warmup)):
        opt.current_lr = ((opt.learning_rate * (iteration + 1)) / opt.noamopt_warmup)
        utils.set_lr(optimizer, opt.current_lr)
    data = loader.get_batch('train')
    print('Read data:', (time.time() - start))
    if ((iteration % acc_steps) == 0):
        optimizer.zero_grad()
    torch.cuda.synchronize()
    start = time.time()
    tmp = [data['fc_feats'], data['att_feats'], data['labels'], data['masks'], data['att_masks']]
    tmp = [(_ if (_ is None) else _.cuda()) for _ in tmp]
    (fc_feats, att_feats, labels, masks, att_masks) = tmp
    model_out = dp_lw_model(fc_feats, att_feats, labels, masks, att_masks, data['gts'], torch.arange(0, len(data['gts'])), sc_flag)
    loss = model_out['loss'].mean()
    loss_sp = (loss / acc_steps)
    loss_sp.backward()
    if (((iteration + 1) % acc_steps) == 0):
        utils.clip_gradient(optimizer, opt.grad_clip)
        optimizer.step()
    torch.cuda.synchronize()
    train_loss = loss.item()
    end = time.time()
    if (not sc_flag):
        print('iter {} (epoch {}), train_loss = {:.3f}, time/batch = {:.3f}'.format(iteration, epoch, train_loss, (end - start)))
    else:
        print('iter {} (epoch {}), avg_reward = {:.3f}, time/batch = {:.3f}'.format(iteration, epoch, model_out['reward'].mean(), (end - start)))
    iteration += 1
    if data['bounds']['wrapped']:
        epoch += 1
        epoch_done = True
    if ((iteration % opt.losses_log_every) == 0):
        add_summary_value(tb_summary_writer, 'train_loss', train_loss, iteration)
        if opt.noamopt:
            opt.current_lr = optimizer.rate()
        elif opt.reduce_on_plateau:
            opt.current_lr = optimizer.current_lr
        add_summary_value(tb_summary_writer, 'learning_rate', opt.current_lr, iteration)
        add_summary_value(tb_summary_writer, 'scheduled_sampling_prob', model.ss_prob, iteration)
        if sc_flag:
            add_summary_value(tb_summary_writer, 'avg_reward', model_out['reward'].mean(), iteration)
        loss_history[iteration] = (train_loss if (not sc_flag) else model_out['reward'].mean())
        lr_history[iteration] = opt.current_lr
        ss_prob_history[iteration] = model.ss_prob
    infos['iter'] = iteration
    infos['epoch'] = epoch
    infos['iterators'] = loader.iterators
    infos['split_ix'] = loader.split_ix
    if ((iteration % opt.save_checkpoint_every) == 0):
        eval_kwargs = {'split': 'val', 'dataset': opt.input_json, 'num_images': 1}
        eval_kwargs.update(vars(opt))
        (val_loss, predictions, lang_stats) = eval_utils.eval_split(dp_model, lw_model.crit, loader, eval_kwargs)
        if opt.reduce_on_plateau:
            if ((lang_stats is not None) and ('CIDEr' in lang_stats)):
                optimizer.scheduler_step((- lang_stats['CIDEr']))
            else:
                optimizer.scheduler_step(val_loss)
        add_summary_value(tb_summary_writer, 'validation loss', val_loss, iteration)
        if (lang_stats is not None):
            for (k, v) in lang_stats.items():
                add_summary_value(tb_summary_writer, k, v, iteration)
        val_result_history[iteration] = {'loss': val_loss, 'lang_stats': lang_stats, 'predictions': predictions}
        if (opt.language_eval == 1):
            current_score = lang_stats['CIDEr']
        else:
            current_score = (- val_loss)
        best_flag = False
        if ((best_val_score is None) or (current_score > best_val_score)):
            best_val_score = current_score
            best_flag = True
        infos['best_val_score'] = best_val_score
        histories['val_result_history'] = val_result_history
        histories['loss_history'] = loss_history
        histories['lr_history'] = lr_history
        histories['ss_prob_history'] = ss_prob_history
        save_checkpoint(model, infos, optimizer, histories)
        if opt.save_history_ckpt:
            save_checkpoint(model, infos, optimizer, append=str(iteration))
        if best_flag:
            save_checkpoint(model, infos, optimizer, append='best')
    if ((epoch >= opt.max_epochs) and (opt.max_epochs != (- 1))):
        break
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
while True:
    try:
        package: Union[(LoggingPackage, Union[(Tuple[(str, Any)], Tuple[(str, Any, Any)])])] = self.queues['results'].get(timeout=1)
        if isinstance(package, LoggingPackage):
            pkg_mode = package.mode
            if (pkg_mode == 'train'):
                collected.append(package)
                if (len(collected) >= nworkers):
                    collected = sorted(collected, key=(lambda pkg: (pkg.training_steps, pkg.off_policy_steps)))
                    if ((collected[(nworkers - 1)].training_steps == collected[0].training_steps) and (collected[(nworkers - 1)].off_policy_steps == collected[0].off_policy_steps)):
                        (last_train_steps, last_offpolicy_steps, last_train_time) = self.process_train_packages(log_writer=log_writer, pkgs=collected[:nworkers], last_steps=last_train_steps, last_offpolicy_steps=last_offpolicy_steps, last_time=last_train_time)
                        collected = collected[nworkers:]
                    elif (len(collected) > (2 * nworkers)):
                        get_logger().warning('Unable to aggregate train packages from all {} workersafter {} packages collected'.format(nworkers, len(collected)))
            elif (pkg_mode == 'valid'):
                if (package.training_steps is not None):
                    self.process_eval_package(log_writer=log_writer, pkg=package)
                if (finalized and self.queues['checkpoints'].empty()):
                    break
            elif (pkg_mode == 'test'):
                collected.append(package)
                if (len(collected) >= nworkers):
                    collected = sorted(collected, key=(lambda x: x.training_steps))
                    if (collected[(nworkers - 1)].training_steps == collected[0].training_steps):
                        self.process_test_packages(log_writer=log_writer, pkgs=collected[:nworkers], all_results=test_results)
                        collected = collected[nworkers:]
                        with open(metrics_file, 'w') as f:
                            json.dump(test_results, f, indent=4, sort_keys=True, cls=NumpyJSONEncoder)
                            get_logger().info('Updated {} up to checkpoint {}'.format(metrics_file, test_steps[(len(test_results) - 1)]))
            else:
                get_logger().error(f'Runner received unknown package of type {pkg_mode}')
        else:
            pkg_mode = package[0]
            if (pkg_mode == 'train_stopped'):
                if (package[1] == 0):
                    finalized = True
                    if (not self.running_validation):
                        get_logger().info('Terminating runner after trainer done (no validation)')
                        break
                else:
                    raise Exception('Train worker {} abnormally terminated'.format((package[1] - 1)))
            elif (pkg_mode == 'valid_stopped'):
                raise Exception('Valid worker {} abnormally terminated'.format((package[1] - 1)))
            elif (pkg_mode == 'test_stopped'):
                if (package[1] == 0):
                    unfinished_workers -= 1
                    if (unfinished_workers == 0):
                        get_logger().info('Last tester finished. Terminating')
                        finalized = True
                        break
                else:
                    raise RuntimeError('Test worker {} abnormally terminated'.format((package[1] - 1)))
            else:
                get_logger().error(f'Runner received invalid package tuple {package}')
    except queue.Empty as _:
        if all(((p.exitcode is not None) for p in itertools.chain(*self.processes.values()))):
            break
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_vocab_files = {}
for (file_id, file_path) in vocab_files.items():
    if (file_path is None):
        resolved_vocab_files[file_id] = None
    else:
        resolved_vocab_files[file_id] = cached_path(file_path, cache_dir=cache_dir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex.optimizers import FP16_Optimizer
from apex.optimizers import FusedAdam
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
j = word.index(first, i)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
import apex
apex.amp.register_half_function(torch, 'einsum')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with open(output_path, 'rb') as f:
    data = pickle.load(f)
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
gnu_get_libc_version = process_namespace.gnu_get_libc_version
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
fp.write(f' {self.palette[j]}')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from fairscale.nn import enable_wrap
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
oldval = getattr(self, key)
assert (oldval == val), ""Attribute '{}' in the metadata of '{}' cannot be set to a different value!\n{} != {}"".format(key, self.name, oldval, val)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
p.requires_grad_(generator)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from statsmodels.distributions.empirical_distribution import ECDF
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
model_class = config.architectures[0]
transformers_module = __import__('transformers', fromlist=[model_class])
model_cls = getattr(transformers_module, model_class)
model = model_cls(config)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return [self.protocol_parser[x] for x in filenames]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
remapped_result = remap_ptb_passage_and_answer_spans(ptb_tokens=datum['sentence_tokens'], answer_span=answer_tok_span, moses=moses, tokenizer_name=self.tokenizer_name)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
assert (pointer.shape == array.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(args.height, args.width) = parse('{}x{}', args.imgsize)
(args.height, args.width) = (int(args.height), int(args.width))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
import lvis
assert (lvis.__version__ >= '10.5.3')
from lvis import LVISResults, LVISEval
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex.optimizers import FP16_Optimizer
from apex.optimizers import FusedAdam
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex.parallel import DistributedDataParallel as DDP
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
prior_mean = [(float(t) / prior_mean_sum) for t in prior_mean]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1
"
if (name[:2] in ('#x', '#X')):
    return unichr(int(name[2:], 16))
elif name.startswith('#'):
    return unichr(int(name[1:]))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
return safe_round((base ** loss), round)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
results = list()
with open(file, 'r') as f:
    for l in f:
        if (l.strip() == ''):
            continue
        results.append(float(l.strip().split()[1]))
return max(results)
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (self.params.experiment.train_mode == 'orig'):
    raise TypeError
save_name = '{}_{}_{}_{}_{}_{}_{}_{}_{:.3f}'.format(self.params.experiment.origin, self.params.experiment.train_mode, self.params.experiment.num_folds, fold_index, self.params.data.num_class, self.params.data.num_inst, epoch_num, self.param_name, self.param_val)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
os.mkdir(folder_to_save_model)
print('Creating folder: {}'.format(folder_to_save_model))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
audio = file_finder(current_file)
current_file['audio'] = audio
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
import ipadic
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
template_name = sent_types[args.template]
batch_size_dict = batch_sizes[args.template]
masked_type = masked_types[args.template]
max_len = max_len_types[args.template]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import ctypes
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
while True:
    if epoch_done:
        if ((not opt.noamopt) and (not opt.reduce_on_plateau)):
            if ((epoch > opt.learning_rate_decay_start) and (opt.learning_rate_decay_start >= 0)):
                frac = ((epoch - opt.learning_rate_decay_start) // opt.learning_rate_decay_every)
                decay_factor = (opt.learning_rate_decay_rate ** frac)
                opt.current_lr = (opt.learning_rate * decay_factor)
            else:
                opt.current_lr = opt.learning_rate
            utils.set_lr(optimizer, opt.current_lr)
        if ((epoch > opt.scheduled_sampling_start) and (opt.scheduled_sampling_start >= 0)):
            frac = ((epoch - opt.scheduled_sampling_start) // opt.scheduled_sampling_increase_every)
            opt.ss_prob = min((opt.scheduled_sampling_increase_prob * frac), opt.scheduled_sampling_max_prob)
            model.ss_prob = opt.ss_prob
        if ((opt.self_critical_after != (- 1)) and (epoch >= opt.self_critical_after)):
            sc_flag = True
            init_scorer(opt.cached_tokens)
        else:
            sc_flag = False
        epoch_done = False
    start = time.time()
    if ((opt.use_warmup == 1) and (iteration < opt.noamopt_warmup)):
        opt.current_lr = ((opt.learning_rate * (iteration + 1)) / opt.noamopt_warmup)
        utils.set_lr(optimizer, opt.current_lr)
    data = loader.get_batch('train')
    print('Read data:', (time.time() - start))
    if ((iteration % acc_steps) == 0):
        optimizer.zero_grad()
    torch.cuda.synchronize()
    start = time.time()
    tmp = [data['attr'], data['img'], data['labels'], data['masks']]
    tmp = [(_ if (_ is None) else _.cuda()) for _ in tmp]
    (attrs, imgs, labels, masks) = tmp
    model_out = dp_lw_model(attrs, imgs, labels, masks, data['gts'], torch.arange(0, len(data['gts'])), sc_flag)
    loss = model_out['loss'].mean()
    loss_sp = (loss / acc_steps)
    loss_sp.backward()
    if (((iteration + 1) % acc_steps) == 0):
        utils.clip_gradient(optimizer, opt.grad_clip)
        optimizer.step()
    torch.cuda.synchronize()
    train_loss = loss.item()
    end = time.time()
    if (not sc_flag):
        print('{}: iter {} (epoch {}), train_loss = {:.3f}, time/batch = {:.3f}'.format(time.strftime('%Y-%m-%d %H:%M:%S', time.localtime()), iteration, epoch, train_loss, (end - start)))
    else:
        print('{}: iter {} (epoch {}), avg_reward = {:.3f}, time/batch = {:.3f}'.format(time.strftime('%Y-%m-%d %H:%M:%S', time.localtime()), iteration, epoch, model_out['reward'].mean(), (end - start)))
    iteration += 1
    if data['bounds']['wrapped']:
        epoch += 1
        epoch_done = True
    if ((iteration % opt.losses_log_every) == 0):
        add_summary_value(tb_summary_writer, 'train_loss', train_loss, iteration)
        if opt.noamopt:
            opt.current_lr = optimizer.rate()
        elif opt.reduce_on_plateau:
            opt.current_lr = optimizer.current_lr
        add_summary_value(tb_summary_writer, 'learning_rate', opt.current_lr, iteration)
        add_summary_value(tb_summary_writer, 'scheduled_sampling_prob', model.ss_prob, iteration)
        if sc_flag:
            add_summary_value(tb_summary_writer, 'avg_reward', model_out['reward'].mean(), iteration)
        loss_history[iteration] = (train_loss if (not sc_flag) else model_out['reward'].mean())
        lr_history[iteration] = opt.current_lr
        ss_prob_history[iteration] = model.ss_prob
    infos['iter'] = iteration
    infos['epoch'] = epoch
    infos['iterators'] = loader.iterators
    infos['split_ix'] = loader.split_ix
    if ((iteration % opt.save_checkpoint_every) == 0):
        eval_kwargs = {'split': 'val', 'dataset': opt.input_json}
        eval_kwargs.update(vars(opt))
        (val_loss, predictions, lang_stats) = eval_utils.eval_split(dp_model, lw_model.crit, loader, eval_kwargs)
        if opt.reduce_on_plateau:
            if ('CIDEr' in lang_stats):
                optimizer.scheduler_step((- lang_stats['CIDEr']))
            else:
                optimizer.scheduler_step(val_loss)
        add_summary_value(tb_summary_writer, 'validation loss', val_loss, iteration)
        if (lang_stats is not None):
            for (k, v) in lang_stats.items():
                add_summary_value(tb_summary_writer, k, v, iteration)
        val_result_history[iteration] = {'loss': val_loss, 'lang_stats': lang_stats, 'predictions': predictions}
        if (opt.language_eval == 1):
            current_score = lang_stats['CIDEr']
        else:
            current_score = (- val_loss)
        best_flag = False
        if ((best_val_score is None) or (current_score > best_val_score)):
            best_val_score = current_score
            best_flag = True
        infos['best_val_score'] = best_val_score
        histories['val_result_history'] = val_result_history
        histories['loss_history'] = loss_history
        histories['lr_history'] = lr_history
        histories['ss_prob_history'] = ss_prob_history
        save_checkpoint(model, infos, optimizer, histories)
        if opt.save_history_ckpt:
            save_checkpoint(model, infos, optimizer, append=str(iteration))
        if best_flag:
            save_checkpoint(model, infos, optimizer, append='best')
    if ((epoch >= opt.max_epochs) and (opt.max_epochs != (- 1))):
        break
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (len(iterable) == 0):
    return include_empty
for t in iter(iterable):
    if (not isinstance(t, torch.Tensor)):
        return False
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
model = super(FastText, cls).load(*args, **kwargs)
if ((not hasattr(model.trainables, 'vectors_vocab_lockf')) and hasattr(model.wv, 'vectors_vocab')):
    model.trainables.vectors_vocab_lockf = ones(len(model.trainables.vectors), dtype=REAL)
if ((not hasattr(model.trainables, 'vectors_ngrams_lockf')) and hasattr(model.wv, 'vectors_ngrams')):
    model.trainables.vectors_ngrams_lockf = ones(len(model.trainables.vectors), dtype=REAL)
return model
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
for r in result.stdout.split(b'\n'):
    if (len(r) == 0):
        continue
    split = r.split(b' ')
    if (len(split) < 3):
        results.append([float(split[0]), int(split[1]), '', ''])
    else:
        results.append([float(split[0]), int(split[1]), b' '.join(split[3:]).decode(), split[2].decode()])
return results
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
cpu_sum = float(x.float().sum())
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with PathManager.open(f, 'r', encoding='utf-8') as fd:
    self.add_from_file(fd)
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
u = getattr(self.module, (self.name + '_u'))
v = getattr(self.module, (self.name + '_v'))
w = getattr(self.module, (self.name + '_bar'))
return True
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return float(value)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
s.encode(encoding='utf-8').decode('ascii')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0
"
if (type(args) == dict):
    future = executor.submit(load_fn, **args)
else:
    future = executor.submit(load_fn, *args)
self.last_future = future
receive_fn(future)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import yaml
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from torch.utils.tensorboard import SummaryWriter
self._SummaryWriter = SummaryWriter
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
unicode_type = unicode
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
text_a = line[q1_index]
text_b = line[q2_index]
label = (None if test_mode else line[5])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(objects1, select_node_ids_1) = forward_single_view(tester, house_name, view1, meta_loader=meta_loader, mesh_dir=mesh_dir, prefix='1')
(objects2, select_node_ids_2) = forward_single_view(tester, house_name, view2, meta_loader=meta_loader, mesh_dir=mesh_dir, prefix='2')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
f = open(path, 'rb')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert isinstance(value, (list, tuple))
assert (''.join(value) != value)
",0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0
"
backbone_student_pth = os.path.join(cfg.student_pth, (str(cfg.student_global_step) + 'backbone.pth'))
backbone_student.load_state_dict(torch.load(backbone_student_pth, map_location=torch.device(local_rank)))
if (rank == 0):
    logging.info('backbone student loaded successfully!')
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (self.__fp != self.fp):
    self.__fp.close()
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (events[(ei + 1)].type == 'Velocity'):
    pitch = int(events[ei].value)
    vel = int(events[(ei + 1)].value)
    offset_tick = 0
    duration = 0
    for i in range((ei + 1), len(events)):
        if ((events[i].type == 'Note-Off') and (int(events[i].value) == pitch)):
            duration = offset_tick
            break
        elif (events[i].type == 'Time-Shift'):
            offset_tick += self._token_duration_to_ticks(events[i].value, time_division)
        elif (events[ei].type == 'Rest'):
            (beat, pos) = map(int, events[ei].value.split('.'))
            offset_tick += ((beat * time_division) + (pos * ticks_per_sample))
        if (offset_tick > max_duration):
            break
    if ((duration == 0) and (default_duration is not None)):
        duration = default_duration
    if (duration != 0):
        instrument.notes.append(Note(vel, pitch, current_tick, (current_tick + duration)))
    ei += 1
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self._reference_namespace.value = value_namespace
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
from apex import amp
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
dt[(d_int == NaT_int)] = np.nan
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
assert (pointer.shape == array.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return float(constant)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
self.tokenizer_fun = getattr(self, (self.tokenizer + '_tokenize'))
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import apex
apex.amp.register_half_function(torch, 'einsum')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from .convert_bert_original_tf_checkpoint_to_pytorch import convert_tf_checkpoint_to_pytorch
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from torchvision import _C as C
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
scores = [x['score'] for x in sinfo]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
tarinfo = self.tarfile.members[self.index]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import ftfy
from spacy.lang.en import English
_nlp = English()
self.nlp = _nlp.Defaults.create_tokenizer(_nlp)
self.fix_text = ftfy.fix_text
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from nltk.tokenize import word_tokenize
self.word_tokenize = word_tokenize
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import sentencepiece as spm
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_vocab_file = cached_path(vocab_file, cache_dir=cache_dir)
resolved_merges_file = cached_path(merges_file, cache_dir=cache_dir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
client = self.serverTransport.accept()
if (not client):
    continue
self.serveClient(client)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0
"
shutil.copyfile(copy_setup_from, filename)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
shutil.rmtree(logdir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from transformers.convert_transfo_xl_original_tf_checkpoint_to_pytorch import convert_transfo_xl_checkpoint_to_pytorch
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import apex
apex.amp.register_half_function(torch, 'einsum')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if ('pythainlp' not in sys.modules):
    from pythainlp.tokenize import word_tokenize as th_word_tokenize
else:
    th_word_tokenize = sys.modules['pythainlp'].word_tokenize
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
ctx.padding = _PADDING[padding]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if isinstance(s, str):
    return s
elif np.iterable(s):
    cbook.warn_deprecated('3.3', message=""Support for setting the 'text.latex.preamble' or 'pgf.preamble' rcParam to a list of strings is deprecated since %(since)s and will be removed %(removal)s; set it to a single string instead."")
    return '\n'.join(s)
else:
    raise TypeError
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
repo_dpath = dirname(dirname(__file__))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(self.root)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
item['partname'] = self.partname[index]
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
out = self.model(xs, ys, rank_during_training=(cands is not None))
(_preds, scores, cand_preds) = (out[0], out[1], out[2])
score_view = scores.view((- 1), scores.size((- 1)))
loss = self.criterion(score_view, ys.view((- 1)))
y_ne = ys.ne(self.NULL_IDX)
target_tokens = y_ne.long().sum().item()
correct = ((ys == _preds) * y_ne).sum().item()
self.metrics['correct_tokens'] += correct
self.metrics['loss'] += loss.item()
self.metrics['num_tokens'] += target_tokens
loss /= target_tokens
loss.backward()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if isinstance(key, str):
    key = (key,)
iter(key)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
val = strtobool(val)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
os.remove(input_path)
os.remove(output_path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
conditioning = int(block['condition'])
if (conditioning == 1):
    self.condition = True
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
logger.debug('Replacing %s from %s', new_path, path)
if (os.path.isfile(new_path) or os.path.islink(new_path)):
    os.unlink(new_path)
elif os.path.isdir(new_path):
    rmtree(new_path)
renames(path, new_path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import tensorflow as tf
import torch
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.remove(cls.path_token)
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(opt.save)
print(('Logging at: ' + opt.save))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex import amp
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (getattr(self, k) is None):
    setattr(self, k, v)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
cos_similarities_preds[layer][('correct' if true_pred else 'erroneous')]['freq'] += 1
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
get_ipython = sys.modules['IPython'].get_ipython
if ('IPKernelApp' not in get_ipython().config):
    raise ImportError('console')
if ('VSCODE_PID' in os.environ):
    raise ImportError('vscode')
return (importlib.util.find_spec('IPython') is not None)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
data_indices = label_data_map[max_y_hat]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.pool.put(conn, block=False)
return
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return kl_divergence(p, q)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
seq_node = seq_node.cf_state[0].rhs
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
sample[k] = ds.collater([s[k] for s in samples])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
enc = CNNDecoder()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.data['infos/angle'].append(info['angle'])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
tokens = self.enc.encode(sent)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
model.load_state_dict(weights)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
del self.imageCache[self.imageId]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
f2 = sp.simplify(f)
if any((s.is_Dummy for s in f2.free_symbols)):
    logger.warning(f'Detected Dummy symbol when simplifying {f} to {f2}')
    return f
else:
    return f2
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0
"
import numpy as np
import tensorflow as tf
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import re
import numpy as np
import tensorflow as tf
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
repo_dpath = dirname(dirname(__file__))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
temp_val.append(nfs_data[emoji])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
out = net(inp)
loss = out.sum()
loss.backward()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
raises(self.e)(self.does_not_raise_exception)()
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
image_paths = pickle.load(open('/h/19/jadeleiyu/frame_extension/data/img/imagenet_image_paths.p', 'rb'))
wnids = pickle.load(open('/h/19/jadeleiyu/frame_extension/data/img/imagenet_wnids.p', 'rb'))
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
mod = importlib.import_module((('parlai.tasks.' + task) + '.build'))
file_list = mod.RESOURCES
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return cls(**cfg)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
return float(value)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
self.__root
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import psutil
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
episode_done = message.pop('episode_done')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
for epoch in range(1, (num_epochs + 1)):
    self.train_epoch(epoch, train_data, verbose)
    if (valid_data is not None):
        assert (valid_metric is not None), ""In case of validation 'valid_metric' must be provided""
        valid_res = valid_func(self, valid_data, valid_metric)
        mu_val = np.mean(valid_res)
        std_err_val = (np.std(valid_res) / np.sqrt(len(valid_res)))
        logger.info('| epoch %d | %s %.3f (%.4f) |', epoch, valid_metric, mu_val, std_err_val)
        if (mu_val > best_val):
            best_val = mu_val
            self.save_model(save_path, epoch)
            early_stop_counter = 0
        elif ((epoch >= at_least) and early_stop_flag):
            early_stop_counter += 1
            if (early_stop_counter == early_stop):
                logger.info('Traing stopped at epoch %d due to early stopping', epoch)
                break
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(connect, read) = timeout
timeout = TimeoutSauce(connect=connect, read=read)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
self.data_length = int(task.split(':')[(- 1)])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
loaded_vars = torch.load(os.path.join(self.args.work_dir, model_name))
self.model.load_state_dict(loaded_vars['model_dict'])
self.orient_h = loaded_vars['orient_h']
self.quat_h = loaded_vars['quat_h']
best_model_found = True
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
val = self.__getattr__(name)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
response = requests.head(url, allow_redirects=True, proxies=proxies, timeout=etag_timeout)
if (response.status_code == 200):
    etag = response.headers.get('ETag')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
del os.environ[name]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
j = word.index(first, i)
new_word.extend(word[i:j])
i = j
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
return torch.cat([(self.W[None, :, :] - centroids_c[:, :, None]).norm(p=2, dim=1) for centroids_c in self.centroids.chunk(nb_centroids_chunks, dim=0)], dim=0)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return int(v)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0
"
return bool(_format_int(format, subtype, endian))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0
"
g = grp.getgrnam(tarinfo.gname)[2]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
tfe_layer_cls = getattr(tfe.keras.layers, keras_layer_type)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from fairseq.fb_pathmgr import fb_pathmgr
global fb_pathmgr_registerd
if (not fb_pathmgr_registerd):
    fb_pathmgr.register()
    fb_pathmgr_registerd = True
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(option, val) = arg[2:].split('=', 1)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
precision_init_args = self.config.get_extra_struct(QuantizationPrecisionInitArgs)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.exprs = list(exprs)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
c_list[(- 2)] = (c_list[(- 2)] * c_list[(- 1)])
del c_list[(- 1)]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
load_library('_multiarray_umath', np.core._multiarray_umath.__file__)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from transformers.convert_gpt2_original_tf_checkpoint_to_pytorch import convert_gpt2_checkpoint_to_pytorch
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
response = requests.head(url, allow_redirects=True, proxies=proxies)
if (response.status_code != 200):
    etag = None
else:
    etag = response.headers.get('ETag')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
sample_neg = self.train_iter_neg.__next__()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
cindex = cfunc_entries.index(self.entry)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
(lr_img, hr_img) = next(iter_loader)
step += ngpu
stats = train(lr_img, hr_img, feature, generator, discrmntr, f_inp, f_out, opt_g, opt_d, device, sign_loss, config['reg_coeff'])
n = lr_img.size(0)
Loss_content.update(stats[0], n)
Loss_adversarial.update(stats[1], n)
Loss_Dy.update(stats[2], n)
Loss_DGx.update(stats[3], n)
Loss_WM.update(stats[4], n)
Loss_S.update(stats[5], n)
print(f'Epoch {epoch}: [{Loss_Dy.count}/{len(loader.dataset)}] C: {Loss_content.avg:.4f} G: {Loss_adversarial.avg:.4f} D[R/F]: [{Loss_Dy.avg:.4f} / {Loss_DGx.avg:.4f}] S: {Loss_S.avg:.4f} WM: {Loss_WM.avg:.4f} ({(time.time() - start):.2f} s)', end='\r')
if ((step == ngpu) or ((step % args.sample_freq) < ngpu)):
    sample_image(step, generator, 'Set14')
    save_model(generator, os.path.join(args.path, f'overwrite/SRGAN.pt'))
    save_model(discrmntr, os.path.join(args.path, f'overwrite/Dis96.pt'))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(directory)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
result = subprocess.check_output(['nvidia-smi', '--query-gpu=memory.used', '--format=csv,nounits,noheader'], encoding='utf-8')
gpu_memory = [int(x) for x in result.strip().split('\n')]
return {gpu: memory for (gpu, memory) in enumerate(gpu_memory)}
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
ensure_dir(output_dir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_corpus_file = cached_path(corpus_file, cache_dir=cache_dir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
classname = self.__class__.__name__
nice = self.__nice__()
return f'<{classname}({nice})>'
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
alpha = np.minimum(np.maximum(scipy.sparse.linalg.spsolve(H, c), 0), 1).reshape(m, n)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0
"

@observable()
class NoObservableValues():
    pass
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex.normalization import FusedLayerNorm
return FusedLayerNorm(normalized_shape, eps, elementwise_affine)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
ret = next(self.iter)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
lvis_dt = LVISResults(lvis_gt, result_files[metric])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
filepath = os.path.join(os.environ.get('_MEIPASS2', os.path.abspath('.')), 'xsf', (str(symbol) + str('.nff')))
content = np.loadtxt(filepath, dtype=np.float, skiprows=1, usecols=(0, 1, 2))
xsf1 = np.interp(logger.xfs_energy, np.transpose(content)[0], np.transpose(content)[1])
xsf2 = np.interp(logger.xfs_energy, np.transpose(content)[0], np.transpose(content)[2])
success = 1.0
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
s = join(0, a, b)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
docs.append(yaml.load(raw_doc))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0
"
iter_seed = int(np.random.randint(10000))
gp_train_command = ['python', GP_TRAIN_FILE, f'--nZ={current_n_inducing_points}', f'--seed={iter_seed}', f'--data_file={str(gp_data_file)}', f'--save_file={str(new_gp_file)}', f'--logfile={str(log_path)}', f'--normal_inputs', f'--standard_targets']
gp_err_train_command = ['python', GP_TRAIN_FILE, f'--nZ={n_inducing_points}', f'--seed={iter_seed}', f'--data_file={str(gp_err_data_file)}', f'--save_file={str(new_gp_err_file)}', f'--logfile={str(err_log_path)}']
if gp_initial_train:
    gp_fit_desc = 'GP initial fit'
    gp_train_command += ['--init', '--kmeans_init']
    gp_err_train_command += ['--init', '--kmeans_init']
else:
    gp_fit_desc = 'GP incremental fit'
    gp_train_command += [f'--gp_file={str(curr_gp_file)}', f'--n_perf_measure=1']
    gp_err_train_command += [f'--gp_file={str(curr_gp_err_file)}', f'--n_perf_measure=1']
if (pbar is not None):
    old_desc = pbar.desc
    pbar.set_description(gp_fit_desc)
print_flush('Training objective GP...')
_run_command(gp_train_command, f'GP train {gp_iter}')
curr_gp_file = new_gp_file
if error_aware_acquisition:
    if gp_initial_train:
        _run_command(gp_err_train_command, f'GP err train {gp_iter}')
        curr_gp_err_file = new_gp_err_file
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
seq_len = (None if (not self.multigpu) else batch.text_vec.size(1))
out = self.model(batch.text_vec, batch.ctrl_vec, batch.label_vec, seq_len=seq_len)
scores = out[0]
(_, preds) = scores.max(2)
score_view = scores.view((- 1), scores.size((- 1)))
loss = self.criterion(score_view, batch.label_vec.view((- 1)))
notnull = batch.label_vec.ne(self.NULL_IDX)
target_tokens = notnull.long().sum().item()
correct = ((batch.label_vec == preds) * notnull).sum().item()
self.metrics['correct_tokens'] += correct
self.metrics['loss'] += loss.item()
self.metrics['num_tokens'] += target_tokens
loss /= target_tokens
loss.backward()
self.update_params()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
for file_name in os.listdir(os.path.join(task_directory_path, 'html')):
    self.task_files_to_copy.append(os.path.join(task_directory_path, 'html', file_name))
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_archive_file = cached_path(archive_file, cache_dir=cache_dir, force_download=force_download, proxies=proxies, resume_download=resume_download, local_files_only=local_files_only)
if (resolved_archive_file is None):
    raise EnvironmentError
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
data_shape.append(list(v.shape))
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
binding = self.scope.pop(node.name)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
np = npath.index(nloc, (p + 1))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
st['key'] = True
self.fail('cannot change removed key')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (not self._data):
    raise QiskitFinanceError('No data loaded, yet. Please run the method run() first to load the data.')
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
global_step = int(args.model_name_or_path.split('-')[(- 1)].split('/')[0])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
os.makedirs(log_dir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
write_tex(model)
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import numpy as np
import tensorflow.compat.v1 as tf
import tensorflow_hub as hub
import tensorflow_text
tf.disable_eager_execution()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with maybe_no_sync():
    (loss, sample_size_i, logging_output) = self.task.train_step(sample=sample, model=self.model, criterion=self.criterion, optimizer=self.optimizer, update_num=self.get_num_updates(), ignore_grad=is_dummy_batch)
    del loss
logging_outputs.append(logging_output)
if (not is_dummy_batch):
    sample_size += sample_size_i
if (self.cuda and (self.get_num_updates() == 0)):
    torch.cuda.empty_cache()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_vocab_files = {}
for (file_id, file_path) in vocab_files.items():
    if (file_path is None):
        resolved_vocab_files[file_id] = None
    else:
        resolved_vocab_files[file_id] = cached_path(file_path, cache_dir=cache_dir, force_download=force_download, proxies=proxies)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return ((self._version == other._version) and (self.network_address == other.network_address) and (int(self.netmask) == int(other.netmask)))
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if re.search('^(ark|scp)(,scp|,b|,t|,n?f|,n?p|,b?o|,n?s|,n?cs)*:', file):
    (prefix, file) = file.split(':', 1)
if re.search(':[0-9]+$', file):
    (file, offset) = file.rsplit(':', 1)
if (file[(- 1)] == '|'):
    fd = popen(file[:(- 1)], 'rb')
elif (file[0] == '|'):
    fd = popen(file[1:], 'wb')
elif (file.split('.')[(- 1)] == 'gz'):
    fd = gzip.open(file, mode)
else:
    fd = open(file, mode)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
rundir = _run.observers[0].dir
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
print(((('Downloading ' + url) + ' to ') + fpath))
urllib.request.urlretrieve(url, fpath, reporthook=gen_bar_updater())
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.vocab_size = g2read.vocab_size
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
cwd = os.getcwd()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if args.use_sep:
    (context, qa) = re.split(str(SPECIAL_TOKEN_IDS['sep_token']), data)
else:
    context = ''
    qa = data
(question, answer) = re.split(str(SPECIAL_TOKEN_IDS['ans_token']), qa)
context = [int(c) for c in context.strip().split()]
question = [int(q) for q in question.strip().split()]
answer = [int(a) for a in re.sub(str(SPECIAL_TOKEN_IDS['eos_token']), '', answer).strip().split()]
uid = uuid.uuid1().hex
data = self.parse_example(gen_token, context, question, answer, uid)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
seq_len = (None if (not self.multigpu) else batch.text_vec.size(1))
out = self.model(batch.text_vec, batch.ctrl_vec, batch.label_vec, seq_len=seq_len)
scores = out[0]
(_, preds) = scores.max(2)
score_view = scores.view((- 1), scores.size((- 1)))
loss = self.criterion(score_view, batch.label_vec.view((- 1)))
notnull = batch.label_vec.ne(self.NULL_IDX)
target_tokens = notnull.long().sum().item()
correct = ((batch.label_vec == preds) * notnull).sum().item()
self.metrics['correct_tokens'] += correct
self.metrics['loss'] += loss.item()
self.metrics['num_tokens'] += target_tokens
loss /= target_tokens
loss.backward()
self.update_params()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (not os.path.exists(main_directory)):
    os.makedirs(main_directory)
    time.sleep(0.2)
    path = str(dir_name)
    sub_directory = os.path.join(main_directory, path)
    if (not os.path.exists(sub_directory)):
        os.makedirs(sub_directory)
    if thumbnail:
        sub_directory_thumbnail = os.path.join(main_directory, dir_name_thumbnail)
        if (not os.path.exists(sub_directory_thumbnail)):
            os.makedirs(sub_directory_thumbnail)
else:
    path = str(dir_name)
    sub_directory = os.path.join(main_directory, path)
    if (not os.path.exists(sub_directory)):
        os.makedirs(sub_directory)
    if thumbnail:
        sub_directory_thumbnail = os.path.join(main_directory, dir_name_thumbnail)
        if (not os.path.exists(sub_directory_thumbnail)):
            os.makedirs(sub_directory_thumbnail)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
d = open(f, 'r')
return d
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
sh = geo.shape(m)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
from .convert_xlnet_original_tf_checkpoint_to_pytorch import convert_xlnet_checkpoint_to_pytorch
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (pointer.shape == array.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (len(chart_data[hadm_id]) > 0):
    pass
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
coverage_percentage = ((100.0 * covered_summary) / total_summary)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1
"
from fairseq.fb_pathmgr import fb_pathmgr
with fb_pathmgr.open(path, 'rb') as f:
    state = torch.load(f, map_location=(lambda s, l: default_restore_location(s, 'cpu')))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
data[key] = np.array([float(x) for x in value.split()])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
with open(url, 'rb') as f:
    content = auto_decode(f.read())
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (torch.cuda.device_count() > 1)
logging.info(('--> multi-gpu is available (#gpus = %d).' % torch.cuda.device_count()))
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import pyro.distributions as base_distributions
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import sentencepiece as spm
self.sp = spm.SentencePieceProcessor()
self.sp.Load(vocab)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return super(SafeFileCache, self).set(*args, **kwargs)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (new_op.num_parallel_workers > 1):
    valid_num_shards = 1
    if isinstance(self.sampler, samplers.DistributedSampler):
        valid_num_shards = self.sampler.num_shards
    elif (self.num_shards is not None):
        valid_num_shards = self.num_shards
    process = psutil.Process(os.getpid())
    process_memory = process.memory_info().rss
    sys_memory = psutil.virtual_memory().total
    total_memory_maybe_used = ((process_memory * (new_op.num_parallel_workers + 1)) * valid_num_shards)
    if ((total_memory_maybe_used / sys_memory) > 0.85):
        valid_num_worker = math.floor(((((sys_memory * 0.85) / valid_num_shards) / process_memory) - 1))
        valid_num_worker = (1 if (valid_num_worker <= 0) else valid_num_worker)
        if ((total_memory_maybe_used / sys_memory) > 1.0):
            info = (((('GeneratorDataset num_parallel_workers: ' + str(new_op.num_parallel_workers)) + ' is too large which maybe cause a lot of memory occupation (>100%) during multi process running. Therefore, it is recommended to reduce num_parallel_workers to ') + str(valid_num_worker)) + ' or smaller.')
            raise RuntimeError(info)
        info = (((('GeneratorDataset num_parallel_workers: ' + str(new_op.num_parallel_workers)) + ' is too large which maybe cause a lot of memory occupation (>85%) during multi process running. Therefore, it is recommended to reduce num_parallel_workers to ') + str(valid_num_worker)) + ' or smaller.')
        logger.warning(info)
    sample_fn = SamplerFn(self.source, new_op.num_parallel_workers, self.python_multiprocessing, self.max_rowsize)
    new_op.prepared_source = (lambda sample_ids: _cpp_sampler_fn_mp(sample_ids, sample_fn))
else:
    new_op.prepared_source = (lambda sample_ids: _cpp_sampler_fn(sample_ids, self.source))
new_op.sample_fn = sample_fn
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return loads(f.read(), _dict, decoder)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import sentencepiece as spm
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
data_dict = np.load(data_dict_file, allow_pickle=True)['data_dict'].item()
tag_categories = list(np.load(data_dict_file, allow_pickle=True)['tag_categories'])
max_text_length = np.load(data_dict_file, allow_pickle=True)['max_text_length'].item()
max_time_steps = np.load(data_dict_file, allow_pickle=True)['max_time_steps'].item()
print('Data file found. Returning data.')
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (pointer.shape == array.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (not self.args.use_bmuf):
    multiplier = self.data_parallel_world_size
    self.optimizer.multiply_grads((multiplier / sample_size))
elif (sample_size > 0):
    num = (self.data_parallel_world_size if self._sync_stats() else 1)
    self.optimizer.multiply_grads((num / sample_size))
grad_norm = self.clip_grad_norm(self.args.clip_norm)
if (not self.args.use_bmuf):
    self._check_grad_norms(grad_norm)
self.optimizer.step()
self.set_num_updates((self.get_num_updates() + 1))
logging_output = self._reduce_and_log_stats(logging_outputs, sample_size, grad_norm)
if ((self.args.empty_cache_freq > 0) and ((((self.get_num_updates() + self.args.empty_cache_freq) - 1) % self.args.empty_cache_freq) == 0) and torch.cuda.is_available() and (not self.args.cpu)):
    torch.cuda.empty_cache()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return datetime.strptime(t[0], fmt)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
import apex
apex.amp.register_half_function(torch, 'einsum')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
first_eos_idx = np.where((idxs == self.eos_idx))[0][0]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from .convert_gpt2_original_tf_checkpoint_to_pytorch import convert_gpt2_checkpoint_to_pytorch
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
FooBar(d=1)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
value = int(value)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
plogp = env.penalized_logp(mol)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (pointer.shape == array.shape), f'Pointer shape {pointer.shape} and array shape {array.shape} mismatched'
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
yopt = f.yopt.item()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
val = LAYERS_TO_COPY[n_teacher][n_student]
return val
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (list(symbolic_weight.shape) == list(array.shape))
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
res = getattr(ffi._backend, funcname)(*args)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
repo_dpath = dirname(dirname(__file__))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (pointer.shape == array.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from deepspeed.ops.sparse_attention import DenseSparsityConfig
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
args.distributed_rank = distributed_utils.distributed_init(args)
single_process_main(args)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.translator = build_translator(self.opt, report_score=False, out_file=open(os.devnull, 'w'))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import matplotlib.pyplot as plt
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
max_vocab = max_vocab_size[namespace]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(firstaxis, parity, repetition, frame) = _AXES2TUPLE[axes.lower()]
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
response = requests.head(url, allow_redirects=True)
if (response.status_code != 200):
    etag = None
else:
    etag = response.headers.get('ETag')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.Train_Epoch()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
hits1 = layer_groups.get_group(layer1)
hits2 = layer_groups.get_group(layer2)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (t['head'] == 'root'):
    root_child_funcs.append(t['deprel'])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
my_module = importlib.import_module(module_name)
download = getattr(my_module, 'download')
download(datapath)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
masked_index = current_ids.index(self._lm_tokenizer.mask_token_id)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
checkpoint = torch.load(open(mfile, 'rb'))
self.logger.info(f'Loaded model from {mfile} Correctly')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(default)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return int(value)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
res = pickle.load(f)
last_acc = res[(- 1)]['test']['acc']
key = tuple(cfg.values())
results2[key] = last_acc
",0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from keras_contrib.layers.normalization import InstanceNormalization
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
value = next(it)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
del self._item_cache[key]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex import amp
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
metrics = ((tp / (tp + (0.5 * (fp + fn)))), [(tn / (tn + fn)), (tp / (tp + fp))], [(tn / (tn + fp)), (tp / (tp + fn))], (((tp + tn) / (((tn + fn) + fp) + tp)) * 100), [[tn, fp], [fn, tp]])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1
"
config = configure(cla55)
if isinstance(config, Config):
    if cla55:
        print(f'''configuration stub for {cla55}:
''')
    else:
        print(f'''configuration stub for AllenNLP:
''')
    print(render_config(config))
else:
    print(f'''{class_name} is an abstract base class, choose one of the following subclasses:
''')
    for subclass in config:
        print('\t', subclass)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
link_from_name(body, name)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
keepParsing = method()
break
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return ord(token)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
from apex.optimizers import FP16_Optimizer
from apex.optimizers import FusedAdam
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
del edge_dictionary[node_1_type][node_1_value]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (p_i.shape == arr_i.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
ckpt = torch.load(model_path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
first_param = next(self.parameters())
return first_param.device
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.remove((eICU_path + 'preprocessed_timeseries.csv'))
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return SparseConstant(SparseType(format=x.format, dtype=x.dtype), x.copy(), name=name)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
from fairseq.modules.dynamicconv_layer import DynamicconvLayer
return DynamicconvLayer(input_size, kernel_size=kernel_size, padding_l=padding_l, num_heads=num_heads, weight_dropout=weight_dropout, weight_softmax=weight_softmax, renorm_padding=renorm_padding, bias=bias, conv_bias=conv_bias, query_size=query_size)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import yaml
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import fastBPE
self.bpe = fastBPE.fastBPE(codes)
self.bpe_symbol = '@@ '
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return torch.logerfc(x)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex.parallel import DistributedDataParallel as DDP
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
rescheduled = False
one_experiment(wid, budget[index], job)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from transformers.convert_albert_original_tf_checkpoint_to_pytorch import convert_tf_checkpoint_to_pytorch
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
for name in attribute['attributes']:
    names.add(name)
attribute_name_counter.update(names)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return self._key
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return next(self.parameters()).dtype
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
__import__(module)
return True
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with open(path, 'rb') as f:
    return f.read()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import kwarray
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import sentencepiece as spm
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex import amp
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
output_label.append(tokenizer.vocab[token])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(file,) = matching
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
assert (pointer.shape == array.shape), f'Pointer shape {pointer.shape} and array shape {array.shape} mismatched'
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (sample_size > 0):
    self.optimizer.multiply_grads((self.args.distributed_world_size / float(sample_size)))
grad_norm = self.optimizer.clip_grad_norm(self.args.clip_norm)
self._prev_grad_norm = grad_norm
self.optimizer.step()
self.set_num_updates((self.get_num_updates() + 1))
self.task.update_step(self._num_updates)
ntokens = logging_output.get('ntokens', 0)
nsentences = logging_output.get('nsentences', 0)
self.meters['wps'].update(ntokens)
self.meters['ups'].update(1.0)
self.meters['wpb'].update(ntokens)
self.meters['bsz'].update(nsentences)
self.meters['gnorm'].update(grad_norm)
self.meters['clip'].update((1.0 if ((grad_norm > self.args.clip_norm) and (self.args.clip_norm > 0)) else 0.0))
self.meters['train_loss'].update(logging_output.get('loss', 0), sample_size)
if ('train_acc' in self.meters):
    self.meters['train_acc'].update(logging_output.get('acc', 0), sample_size)
if ('nll_loss' in logging_output):
    self.meters['train_nll_loss'].update(logging_output.get('nll_loss', 0), ntokens)
if ((self.args.empty_cache_freq > 0) and ((((self.get_num_updates() + self.args.empty_cache_freq) - 1) % self.args.empty_cache_freq) == 0) and torch.cuda.is_available() and (not self.args.cpu)):
    torch.cuda.empty_cache()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
key = self._selector.get_key(fd)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
linop1.rmv(vec2)
assert False, errmsg
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (x == 0):
    return 0
return round(x, (- math.floor(((math.log10(abs(x)) - sigfigs) + 1))))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
if sparse:
    if lstsq:

        def solve(r, sym_pos=False):
            return sps.linalg.lsqr(M, r)[0]
    elif cholesky:
        try:
            _get_solver.cholmod_factor.cholesky_inplace(M)
        except Exception:
            _get_solver.cholmod_factor = cholmod_analyze(M)
            _get_solver.cholmod_factor.cholesky_inplace(M)
        solve = _get_solver.cholmod_factor
    elif (has_umfpack and sym_pos):
        solve = sps.linalg.factorized(M)
    else:
        solve = sps.linalg.splu(M, permc_spec=permc_spec).solve
elif lstsq:

    def solve(r):
        return sp.linalg.lstsq(M, r)[0]
elif cholesky:
    L = sp.linalg.cho_factor(M)

    def solve(r):
        return sp.linalg.cho_solve(L, r)
else:

    def solve(r, sym_pos=sym_pos):
        return sp.linalg.solve(M, r, sym_pos=sym_pos)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (self.args.is_tpu or self.args.torchscript):
    logger.info('Do inference on TPU or torchscript. Running model 5 times to stabilize compilation')
    timeit.repeat(func, repeat=1, number=5)
runtimes = timeit.repeat(func, repeat=self.args.repeat, number=10)
if (self.args.is_tpu and self.args.torch_xla_tpu_print_metrics):
    import torch_xla.debug.metrics as met
    self.print_fn(met.metrics_report())
return (min(runtimes) / 10.0)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
lr = float(input(f""Default LR     is {d['LR']:.3e}, please input LR:""))
lr_fin = float(input(f""Default LR_FIN is {d['LR_FIN']:.3e}, please input LR_FIN:""))
epochs = int(input(f""Default EPOCHS is {d['EPOCHS']}, please input EPOCHS:""))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
pickle.load(fp)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import psutil
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import numpy as np
import tensorflow as tf
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (text[(i + 1)] in tree[text[i]]):
    matched = (matched + self.__getNextChar(text, (i + 1), tree[text[i]]))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(dir2save)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.tryParse(instring, loc)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (p_i.shape == arr_i.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return getattr(child_cls, data.upper())
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
headerfile = io.open(filename, 'r', 'utf8', 'replace')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
result = float(m.group(1))
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
cocoDt = cocoGt.loadRes(result_files[metric])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
j = word.index(first, i)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
iter(data[0])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
source_ref = v_source.ref()
v_sink = replacements[source_ref]
return v_sink
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self._extract_member(tarinfo, os.path.join(path, tarinfo.name), set_attrs=set_attrs)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
fisher_information = self._ret['fisher_information']
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex import amp
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
i = word.index(new_pair, i)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
my_module = load_task_module(opt['task'])
task_agents = my_module.create_agents(opt)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.rnn = SRU(input_size, hidden_size, num_layers=n_layers, dropout=dropout, layer_norm=layer_norm, rescale=rescale, highway_bias=highway_bias, **kwargs)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
return _CACHE[commontype]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(self.next_input, self.next_target) = next(self.loader)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from tqdm._utils import _environ_cols_wrapper, _term_move_up
self._tty_ncols: Optional[Callable] = _environ_cols_wrapper()
self._tty_move_up: str = _term_move_up()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
optimizer_discriminator.load_state_dict(checkpoint['optimizer_discriminator'])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from espnet2.bin.asr_inference import Speech2Text
from espnet_model_zoo.downloader import ModelDownloader
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
nonlinearity = {'RNN_TANH': 'tanh', 'RNN_RELU': 'relu'}[rnn_type]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
gameid = os.listdir(f'{TRACKING_DIR}/{game_name}')[0].split('.')[0]
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with trange(n_steps, desc='[TRAIN] Linear Classifier', unit='steps', disable=(not verbose), ncols=150, position=0, leave=True) as pbar:
    model.train()
    step = 0
    for batch in train_dataloader:
        step += 1
        optimizer.zero_grad()
        outputs = model(batch)
        batch_idx = batch['ids'].to(device)
        target = y_train[batch_idx]
        loss = cross_entropy_with_probs(outputs, target, reduction='none')
        loss = torch.mean((loss * sample_weight[batch_idx]))
        loss.backward()
        optimizer.step()
        scheduler.step()
        if (valid_flag and ((step % evaluation_step) == 0)):
            (metric_value, early_stop_flag, info) = self._valid_step(step)
            if early_stop_flag:
                logger.info(info)
                break
            history[step] = {'loss': loss.item(), f'val_{metric}': metric_value, f'best_val_{metric}': self.best_metric_value, 'best_step': self.best_step}
            last_step_log.update(history[step])
        last_step_log['loss'] = loss.item()
        pbar.update()
        pbar.set_postfix(ordered_dict=last_step_log)
        if (step >= n_steps):
            break
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
repo_dpath = dirname(dirname(dirname(__file__)))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import sentencepiece as spm
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (p_i.shape == arr_i.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from ..models.funnel.convert_funnel_original_tf_checkpoint_to_pytorch import convert_tf_checkpoint_to_pytorch
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(_loss, sample_size, logging_output) = self.task.valid_step(sample, self.model, self.criterion)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
random_horizontal_op = c_vision.RandomHorizontalFlip(1.5)
data = data.map(operations=decode_op, input_columns=['image'])
data = data.map(operations=random_horizontal_op, input_columns=['image'])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
if self.normalize_taskonomy:
    x_taskonomy = self.groupnorm(x_taskonomy)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import re
import numpy as np
import tensorflow as tf
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
args.distributed_rank = distributed_utils.distributed_init(args)
single_process_main(args)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
confidence = float(m.group((numPoints + 1)))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
m['ppl'] = math.exp(m['loss'])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(data, label, _) = test_iter.next()
if (label is not None):
    data['roidb'] = label['roidb']
for (k, v) in data.items():
    data[k] = (v.pin_memory().to(gpu_id, non_blocking=True) if torch.is_tensor(v) else v)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
neigh = nl.create()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
LinearOperator.m(mat, is_hermitian=True)
assert False, msg
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (p_i.shape == arr_i.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(text, output) = dataset[worklist_tail]
worklist.append(worklist_tail)
in_queue.put((worklist_tail, text, output))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
for _ in range(self.take_at_a_time):
    instance = next(iterator)
    instance.fields[self.dataset_name_field] = MetadataField(name)
    (yield instance)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
lst = conf.get_python_variables([(""get_config_var('%s') or ''"" % x) for x in v])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return torch.load((('./checkpoints/' + hp.md5) + '.pkl'))
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
shutil.rmtree(self._full_path())
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
trainer.train_step(raw_batch)
trainer.iter()
torch.distributed.barrier()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
bpe_helper = HuggingFaceBpeHelper(opt, shared)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.logger.info('Loading taxonomic tree...')
tree = self.tt.load_taxfile(str((self.taxonomy_dir / 'taxdump.tar.gz')))
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
global _use_shared_memory
_use_shared_memory = True
_set_worker_signal_handlers()
torch.set_num_threads(1)
random.seed(seed)
torch.manual_seed(seed)
data_queue.cancel_join_thread()
if (init_fn is not None):
    init_fn(worker_id)
watchdog = ManagerWatchdog()
while watchdog.is_alive():
    try:
        r = index_queue.get(timeout=MP_STATUS_CHECK_INTERVAL)
    except queue.Empty:
        continue
    if (r is None):
        assert done_event.is_set()
        return
    elif done_event.is_set():
        continue
    (idx, batch_indices) = r
    try:
        idx_scale = 0
        if ((len(scale) > 1) and dataset.train):
            idx_scale = random.randrange(0, len(scale))
            dataset.set_scale(idx_scale)
        samples = collate_fn([dataset[i] for i in batch_indices])
        samples.append(idx_scale)
    except Exception:
        data_queue.put((idx, ExceptionWrapper(sys.exc_info())))
    else:
        data_queue.put((idx, samples))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
metrics = np.asarray([history.history[key], history.history[('val_' + key)]])
np.save(((((((results_dir + '/traininghistory_') + filename) + '_') + algorithm) + filename_addition) + '.npy'), metrics)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_archive_file = cached_path(archive_file, cache_dir=cache_dir, force_download=force_download, proxies=proxies)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (text[e1_s:e1_e] == ' '.join(x['words'][nepairs['m1']['start']:nepairs['m1']['end']]))
assert (text[e2_s:e2_e] == ' '.join(x['words'][nepairs['m2']['start']:nepairs['m2']['end']]))
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import pydot
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
repo_dpath = dirname(dirname(__file__))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import gitdb
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
error_message += '\nErrorCode:{}'.format(error_code.value)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return bool(eval(x))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
traced_gpt2 = torch.jit.trace(model, inputs)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if self.valid_set:
    return self.get_org_dataset(mode=mode, transform=transform, **kwargs)
else:
    dataset = self.get_org_dataset(mode='train', transform=transform, **kwargs)
    subset: dict[(str, torch.utils.data.Subset)] = {}
    (subset['train'], subset['valid']) = self.split_dataset(dataset, percent=self.split_ratio, seed=seed)
    return subset[mode]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(doc_id, para_id, sent_id, sent_para_id, n_para, n_sent, _, curr_sent, prev_sent, next_sent, level, doc_title, sec_title) = next(self.file).strip().lower().split('\t')
doc_ids.append(int(doc_id))
para_ids.append(int(para_id))
sent_ids.append(int(sent_id))
sent_para_ids.append(int(sent_para_id))
levels.append((int(level) - 1))
doc_titles.append(doc_title.lower().strip().split(' ')[:self.max_len])
sent_titles.append(sec_title.lower().strip().split(' ')[:self.max_len])
curr_sents.append(curr_sent.lower().strip().split(' ')[:self.max_len])
prev_sents.append(prev_sent.lower().strip().split(' ')[:self.max_len])
next_sents.append(next_sent.lower().strip().split(' ')[:self.max_len])
pm = np.zeros((1, self.max_npara))
pm[0, :int(n_para)] = 1
pmask.append(pm)
sm = np.zeros((1, self.max_nsent))
sm[0, :int(n_sent)] = 1
smask.append(sm)
self.n_sent += 1
self.src_min_sent_len = min(self.src_min_sent_len, len(curr_sents[(- 1)]))
self.src_max_sent_len = max(self.src_max_sent_len, len(curr_sents[(- 1)]))
self.src_sum_sent_len += len(curr_sents[(- 1)])
self.next_tgt_min_sent_len = min(self.next_tgt_min_sent_len, len(next_sents[(- 1)]))
self.next_tgt_max_sent_len = max(self.next_tgt_max_sent_len, len(next_sents[(- 1)]))
self.next_tgt_sum_sent_len += len(next_sents[(- 1)])
self.prev_tgt_min_sent_len = min(self.prev_tgt_min_sent_len, len(prev_sents[(- 1)]))
self.prev_tgt_max_sent_len = max(self.prev_tgt_max_sent_len, len(prev_sents[(- 1)]))
self.prev_tgt_sum_sent_len += len(prev_sents[(- 1)])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
f = (((1 + (b * b)) * c) / (((b * b) * g) + e))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1
"
value = float(value_part)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
s = next(source_iter)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
class_ = getattr(faction, candidate)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
lr = args.opt_params[0]
optimizer = optim.Adam(optim_model.parameters(), lr=lr)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
shutil.rmtree(save_folder)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
text_a = line[3]
text_b = line[4]
label = line[5]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(dirpath)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return (numerator / math.sqrt(denominator))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1
"
import torchvision as torchvision
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
text = line.strip()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
log_t = math.log((part1 + part2))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
import sentencepiece as spm
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from fairseq.fb_pathmgr import fb_pathmgr
bexists = fb_pathmgr.isfile(filename)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.split_lines_of_utt = segments[0].split_lines_of_utt
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
iteration %= len(data.batch_sampler)
self._setup_seed()
if (iteration > 0):
    data.batch_sampler.start_iteration = iteration
return iter(data)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
root_module.classes.remove(root_module['ns3::SqliteDataOutput'])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return {k: self._transform_tensor(t) for (k, t) in self._iterator.GetNextAsMap().items()}
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import amp_C
MultiTensorApply.available = True
self.chunk_size = chunk_size
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(save_path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
repo_dpath = dirname(dirname(__file__))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with open(_step_trace_file_path, 'r') as f:
    lines = f.readlines()
    (op_all_step_time, op_all_step_comp) = self._get_bp_fp_time_by_line(lines, op_all_step_time, op_all_step_comp)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
target_class = self.__criterion.target_class()
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
pdm_temp = pickle.load(filehandler)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0
"
main_matrix[(i, j)] = mini_batch[i][j]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
linop1.rmm(mat1.transpose((- 2), (- 1)))
assert False, errmsg
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
src_dict = getattr(task, 'source_dictionary', None)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
train_ids = [idx for idx in range(num_samples) if ((idx not in self.valid_ids) and (idx not in self.test_ids))]
valid_ids = [idx for idx in range(num_samples) if (idx in self.valid_ids)]
test_ids = [idx for idx in range(num_samples) if (idx in self.test_ids)]
train_set = Subset(pil_dataset, train_ids)
valid_set = Subset(pil_dataset, valid_ids)
test_set = Subset(pil_dataset, test_ids)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
axis = int(item)
continue
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0
"
cocoDt = cocoGt.loadRes(result_files[metric])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
hash(obj)
return obj
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
pointer = getattr(pointer, scope_names[0])
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
mod = self.object_from_node(obj.node.root())
self.add_relationship(obj, mod, 'ownership')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
src_dict = getattr(task, 'source_dictionary', None)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(yield next(g))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
while True:
    saved_pos = source.pos
    ch = source.get()
    if (ch == 'V'):
        ch += source.get()
    flags |= REGEX_FLAGS[ch]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.corpus = io.open(corpus_path, 'r', encoding='utf-8')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
font = ImageFont.truetype('/usr/share/fonts/truetype/ttf-bitstream-vera/Vera.ttf', 32)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from nltk.tokenize import word_tokenize
self.word_tokenize = word_tokenize
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
file_name = os.path.basename(file_path)
target_path = os.path.join(target_resource_dir, file_name)
shutil.copy2(file_path, target_path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from Cython.Build import cythonize
if (sys.version_info >= (3, 0)):
    subdir = '_cy3'
else:
    subdir = '_cy2'
ret = []
path = 'dgl/_ffi/_cython'
library_dirs = ['dgl', '../build/Release', '../build']
libraries = ['dgl']
for fn in os.listdir(path):
    if (not fn.endswith('.pyx')):
        continue
    ret.append(Extension(('dgl._ffi.%s.%s' % (subdir, fn[:(- 4)])), [('dgl/_ffi/_cython/%s' % fn)], include_dirs=['../include/', '../third_party/dmlc-core/include', '../third_party/dlpack/include'], library_dirs=library_dirs, libraries=libraries, language='c++'))
return cythonize(ret, force=True)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from nltk.tokenize import word_tokenize
self.word_tokenize = word_tokenize
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex import amp
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
writer = SummaryWriter()
writer.close()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(config.MODEL_PATH)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
rec = (TP / (TP + FN))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1
"
(self.current_sample, self.step_count) = next(self.iterator)
self.current_step = 0
return self.current_sample
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self._run_machar_highprec()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (pointer.shape == array.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import tensorflow as tf
import torch
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
next(f)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (pointer.shape == array.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
score_regions = [tuple(region) for region in score_regions]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
(mle_loss, rl_loss, total_loss, reward) = train_rl(epoch, tokenizer, device, training_loader, optimizer, scheduler, accumulation_steps=args.accumulation_steps, max_decoding_step=args.summary_len, semantic_rewards=args.semantic_rewards)
print(f'MLE loss: {mle_loss}, RL_loss: {rl_loss}, Total_loss: {total_loss}, reward: {reward}')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
config = self.config_dict[model_name]
model = MODEL_WITH_LM_HEAD_MAPPING[config.__class__](config)
model.to(self.args.device)
model.train()
input_ids = torch.randint(model.config.vocab_size, (batch_size, sequence_length), dtype=torch.long, device=self.args.device)

def compute_loss_and_backprob():
    function_argument_names = inspect.getfullargspec(model.forward).args
    if ('labels' in function_argument_names):
        loss = model(input_ids, labels=input_ids)[0]
    elif ('lm_labels' in function_argument_names):
        loss = model(input_ids, lm_labels=input_ids)[0]
    elif ('masked_lm_labels' in function_argument_names):
        loss = model(input_ids, masked_lm_labels=input_ids)[0]
    else:
        NotImplementedError(f'{model_name} does not seem to allow training with labels')
    loss.backward()
    model.zero_grad()
if (trace_memory is True):
    if (self.args.trace_memory_line_by_line or (self.args.n_gpu == 0)):
        trace = start_memory_tracing('transformers')
    else:
        torch.cuda.empty_cache()
        torch.cuda.reset_peak_memory_stats()
    compute_loss_and_backprob()
    if (self.args.trace_memory_line_by_line or (self.args.n_gpu == 0)):
        summary = stop_memory_tracing(trace)
        memory = summary.total
    else:
        memory = Memory(torch.cuda.max_memory_reserved())
    return memory
else:
    runtimes = timeit.repeat((lambda : compute_loss_and_backprob()), repeat=self.args.repeat, number=10)
    return (min(runtimes) / 10.0)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
next(module.parameters())
return True
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
elt = XMLCorpusView(locpath, 'frame')[0]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
p.lr_before = p.prod[(n - 1)]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(x, log_prob) = self.flow.sample_and_log_prob(z=z, alt_dist=self.alt_dist)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(m, _) = min(enumerate(lines), key=(lambda line: (line == '')))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
PyModuleObject = gdb.lookup_type('PyModuleObject')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (npy2sdk(segment_npy) == segment_sdk)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import torchtext.vocab as vocab
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import torch
from torch.onnx.symbolic_helper import _export_onnx_opset_version as opset_version
import torch.onnx.symbolic_registry as sym_registry
sym_registry.register_version('', opset_version)
if ((operator_export_type == OperatorExportTypes.ONNX_ATEN_FALLBACK) and (opset_version == 9)):
    import torch.onnx.symbolic_caffe2
    torch.onnx.symbolic_caffe2.register_quantized_ops('caffe2', opset_version)
if n.kind().endswith('_'):
    ns_op_name = n.kind()[:(- 1)]
else:
    ns_op_name = n.kind()
(ns, op_name) = ns_op_name.split('::')
if (ns == 'onnx'):
    return None
elif (ns == 'aten'):
    is_exportable_aten_op = sym_registry.is_registered_op(op_name, '', opset_version)
    is_onnx_aten_export = (operator_export_type == OperatorExportTypes.ONNX_ATEN)
    is_aten_fallback_export = (operator_export_type == OperatorExportTypes.ONNX_ATEN_FALLBACK)
    if (is_onnx_aten_export or ((not is_exportable_aten_op) and is_aten_fallback_export)):
        attrs = {((k + '_') + n.kindOf(k)[0]): n[k] for k in n.attributeNames()}
        outputs = n.outputsSize()
        attrs['outputs'] = outputs
        return _graph_at(g, op_name, *inputs, aten=True, **attrs)
    else:
        domain = ''
        symbolic_fn = _find_symbolic_in_registry(domain, op_name, opset_version, operator_export_type)
        if (symbolic_fn is None):
            return None
        attrs = {k: n[k] for k in n.attributeNames()}
        return symbolic_fn(g, *inputs, **attrs)
elif (ns == 'prim'):
    if ((op_name == 'Constant') and (not n.mustBeNone())):
        if (n.kindOf('value') == 't'):
            return g.op('Constant', value_t=n['value'])
        if (n.kindOf('value') == 's'):
            return g.op('Constant', value_s=n['value'])
        elif (n.output().type().isSubtypeOf(ListType.ofInts()) or n.output().type().isSubtypeOf(ListType.ofFloats())):
            vals = n.output().toIValue()
            value = (torch.stack([torch.tensor(v) for v in vals]) if len(vals) else [])
            return g.op('Constant', value_t=value)
        elif (n.output().type().kind() == 'DeviceObjType'):
            return None
        else:
            raise RuntimeError('Unsupported prim::Constant kind: `{}`. Send a bug report.'.format(n.kindOf('value')))
    elif (n.mustBeNone() or (op_name == 'ListConstruct') or (op_name == 'ListUnpack')):
        return None
    elif ((op_name == 'device') and (n.output().type().kind() == 'DeviceObjType')):
        return None
    elif ((op_name == 'Loop') or (op_name == 'If')):
        new_op_outputs = g.op(op_name, *inputs, outputs=n.outputsSize())
        new_node = (new_op_outputs[0].node() if (n.outputsSize() > 1) else new_op_outputs.node())
        for b in n.blocks():
            new_block = new_node.addBlock()
            for (i, b_in) in enumerate(b.inputs()):
                if ((i > 0) and ((i + 1) < len(inputs))):
                    b_in.setType(inputs[(i + 1)].type())
            torch._C._jit_pass_onnx_block(b, new_block, operator_export_type, env)
        new_op_outputs = torch._C._jit_pass_fixup_onnx_controlflow_node(new_node, opset_version)
        from torch.onnx.symbolic_helper import _onnx_shape_inference
        if _onnx_shape_inference:
            torch._C._jit_pass_onnx_node_shape_type_inference(new_node, opset_version)
        return new_op_outputs
    else:
        symbolic_name = ('prim_' + op_name)
        domain = ''
        symbolic_fn = _find_symbolic_in_registry(domain, symbolic_name, opset_version, operator_export_type)
        if (symbolic_fn is None):
            return None
        attrs = {k: n[k] for k in n.attributeNames()}
        return symbolic_fn(g, *inputs, **attrs)
elif (ns == 'quantized'):
    domain = ''
    if (operator_export_type == OperatorExportTypes.ONNX_ATEN_FALLBACK):
        domain = 'caffe2'
    symbolic_fn = _find_symbolic_in_registry(domain, op_name, opset_version, operator_export_type)
    if (symbolic_fn is None):
        return None
    attrs = {k: n[k] for k in n.attributeNames()}
    return symbolic_fn(g, *inputs, **attrs)
elif sym_registry.is_registered_version(ns, opset_version):
    domain = ns
    symbolic_fn = _find_symbolic_in_registry(domain, op_name, opset_version, operator_export_type)
    if (symbolic_fn is None):
        return None
    attrs = {k: n[k] for k in n.attributeNames()}
    return symbolic_fn(g, *inputs, **attrs)
else:
    raise RuntimeError('ONNX export failed on an operator with unrecognized namespace {}::{}. If you are trying to export a custom operator, make sure you registered it with the right domain and version.'.format(ns, op_name))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
original_filter = getattr(self, original_filter_name)
return self.negate_filter(original_filter, initial_set)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
obj.items
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import palaas
from .fb_tbmf_wrapper import FbTbmfWrapper
bar = FbTbmfWrapper(bar, log_interval)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (pointer.shape == array.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from mmdet.version import __version__
sha = __version__.split('+')[(- 1)]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
data[key] = np.array(list(map(float, value.split(' '))))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
shutil.rmtree(f'{databin_dir}', ignore_errors=True)
os.mkdir(f'{databin_dir}')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
text_a = line[3]
text_b = line[4]
label = line[5]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
text_a = line[3]
text_b = line[4]
label = line[5]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from fairseq.data.token_block_utils_fast import _get_slice_indices_fast, _get_block_to_dataset_index_fast
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
read_graph = nx.read_gml(file_path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
text_a = line[3]
text_b = line[4]
label = line[5]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
s.decode('ascii')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0
"
box_patch_id = np.array([b[1]['patch_id'] for b in boxes])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import apex
apex.amp.register_half_function(torch, 'einsum')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
turns = [turn['text'] for turn in example['log']]
dialog_acts = [[act_type for act_type in turn['dialog_act']] for turn in example['log']]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
v = literal_eval(v)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
(d, m) = arg
self.agent._held_item = (d, m)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
module = __import__(module_name)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
uri = urlparse.urlparse(val_unescaped)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
import yaml
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
index = int(parts.pop())
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
assert chainer.backends.cuda.cudnn_enabled
logging.info('--> cudnn is available in chainer.')
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
repo_dpath = dirname(dirname(__file__))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import torch
from torch.utils.data import DataLoader
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import palaas
from fairseq.fb_tbmf_wrapper import fb_tbmf_wrapper
bar = fb_tbmf_wrapper(bar, args, args.log_interval)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
root = os.path.realpath(__file__)
for i in cfg.versionfile_source.split('/'):
    root = os.path.dirname(root)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return strtobool(v)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
loss.backward()
self._optimizer.step()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
message['text'] = 'rofl'
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(padding_coords, padding_species_code, self.padding_image_of) = nl.create_paddings(influence_distance, cell, PBC, contributing_coords, contributing_species_code)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import psutil
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
kernel = te.TensorExprKernel(graph)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
node_feat = pd.read_csv(osp.join(subdir, (additional_file + '.csv.gz')), compression='gzip', header=None).values
if ('int' in str(node_feat.dtype)):
    node_feat = node_feat.astype(np.int64)
else:
    node_feat = node_feat.astype(np.float32)
assert (len(node_feat) == sum(num_node_dict[nodetype]))
additional_feat_dict[nodetype] = node_feat
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from thop import profile
stride = (int(model.stride.max()) if hasattr(model, 'stride') else 32)
img = torch.zeros((1, model.yaml.get('ch', 3), stride, stride), device=next(model.parameters()).device)
flops = ((profile(deepcopy(model), inputs=(img,), verbose=False)[0] / 1000000000.0) * 2)
img_size = (img_size if isinstance(img_size, list) else [img_size, img_size])
fs = (', %.1f GFLOPS' % ((((flops * img_size[0]) / stride) * img_size[1]) / stride))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_archive_file = cached_path(archive_file, cache_dir=cache_dir, force_download=force_download, proxies=proxies, resume_download=resume_download, local_files_only=local_files_only)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import lvis
assert (lvis.__version__ >= '10.5.3')
from lvis import LVISResults, LVISEval
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
task = self.async_vis.get()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
shutil.rmtree(f'{databin_dir}', ignore_errors=True)
os.mkdir(f'{databin_dir}')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from ..models.funnel.convert_funnel_original_tf_checkpoint_to_pytorch import convert_tf_checkpoint_to_pytorch
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
for filename in file_list:
    fd_list.append(open(filename))
for lines in zip(*fd_list):
    for (i, line) in enumerate(lines):
        line = line.rstrip('\n').split(' ')
        batch.append(line)
    (yield batch)
    batch = []
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
gender = self.data['gender']
self.gender = np.array([(0 if (str(g) == 'm') else 1) for g in gender]).astype(np.int32)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
r = sent_tokenize(r)[0]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from .convert_transfo_xl_original_tf_checkpoint_to_pytorch import convert_transfo_xl_checkpoint_to_pytorch
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
info['height'] = len(a)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
from .convert_gpt2_checkpoint_to_pytorch import convert_gpt2_checkpoint_to_pytorch
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from mmdet.version import __version__
sha = __version__.split('+')[(- 1)]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return self._args[idx]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_config_file = cached_path(config_file, cache_dir=cache_dir, force_download=force_download, proxies=proxies, resume_download=resume_download, local_files_only=local_files_only, use_auth_token=use_auth_token)
config_dict = cls._dict_from_json_file(resolved_config_file)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
lowered_submod(*submod_inputs)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
model = models.load_arch(args.checkpoint_dir, args, pretrained=args.pretrained_bert, tok=tokenizer, fn_cfg=args.config_file)
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
piece[all_key] = margin[key]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
self._errors_checked = (True if os.path.exists(self.errors_path) else False)
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
data = [encode_unicode_cols(r) for r in data]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0
"
docstring = node['__doc__']
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
dist = self.normalized_graph_edit_distance(predictions[i], targets[i], structure_only)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
hash(obj)
return obj
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
for e in range(self.nepochs):
    clock0 = time.time()
    self.train_epoch(t, xtrain, ytrain)
    clock1 = time.time()
    (train_loss, train_acc) = self.eval(t, xtrain, ytrain)
    clock2 = time.time()
    print('| Epoch {:3d}, time={:5.1f}ms/{:5.1f}ms | Train: loss={:.3f}, acc={:5.1f}% |'.format((e + 1), (((1000 * self.sbatch) * (clock1 - clock0)) / xtrain.size(0)), (((1000 * self.sbatch) * (clock2 - clock1)) / xtrain.size(0)), train_loss, (100 * train_acc)), end='')
    (valid_loss, valid_acc) = self.eval(t, xvalid, yvalid)
    print(' Valid: loss={:.3f}, acc={:5.1f}% |'.format(valid_loss, (100 * valid_acc)), end='')
    if (valid_loss < best_loss):
        best_loss = valid_loss
        best_model = utils.get_model(self.model)
        patience = self.lr_patience
        print(' *', end='')
    else:
        patience -= 1
        if (patience <= 0):
            lr /= self.lr_factor
            print(' lr={:.1e}'.format(lr), end='')
            if (lr < self.lr_min):
                print()
                break
            patience = self.lr_patience
            self.optimizer = self._get_optimizer(lr)
    print()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(file_id, channel) = reco2file_and_channel[reco]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
sample[k] = ds.collater([s[k] for s in samples])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(h, w) = conv2d_output_shape(h, w, child.kernel_size, child.stride, child.padding)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
next_ent = next(it)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
auc_score = roc_auc_score(y_test, y_prob)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
import instaboostfast as instaboost
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with open(os.path.join(location, '__init__.py'), 'rb') as stream:
    data = stream.read(4096)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.filter(a, strict=True)
return True
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0
"
assert (model.embed.weight.shape == init_params[0].shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex import amp
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import sentencepiece as spm
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
s = socket.socket(family, type, proto)
s.bind(('localhost', 0))
s.listen(0)
return s
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
c_vision.RandomResizeWithBBox((- 10))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
resolved_archive_file = cached_path(archive_file, cache_dir=cache_dir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
repo_dpath = dirname(dirname(__file__))
repo_dpath = join(repo_dpath, '..')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return self._os_release_info['codename']
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
masks = PolygonMasks(segms)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
os.symlink(source_configs_dir, destination)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
pointer = getattr(pointer, m_name)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
data = self.irl_iter.next()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
tok_i = src_vocab.stoi[tok]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return bool(eval(x))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
import tensorflow as tf
import torch
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
write_image(figure, filename_png)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
prev = next(it)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
i = obs_know.index(checked_sentence)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
from det3d.version import __version__
sha = __version__.split('+')[(- 1)]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.chflags(dst, st.st_flags)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
u = getattr(self.module, (self.name + '_u'))
v = getattr(self.module, (self.name + '_v'))
w = getattr(self.module, (self.name + '_bar'))
return True
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return self.data.num_examples()
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return float(val)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
nn.utils.remove_weight_norm(module)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
import apex
apex.amp.register_half_function(torch, 'einsum')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(root)
",0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import kwarray
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
Ntotal = ary.shape[axis]
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return next(module.parameters()).device
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
int_fields = [int(x) for x in fields]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
os.makedirs(self.uge_working_directory)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.ws = WebsocketServer(port, host='127.0.0.1')
self.port = port
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
num = max(num, int(filename))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
plus = self.handle.send(buff)
if (plus == 0):
    raise TTransportException(type=TTransportException.END_OF_FILE, message='TSocket sent 0 bytes')
sent += plus
buff = buff[plus:]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
dates.append(datetime(int(year_match), MONTH_NUMBERS[month], DAY_NUMBERS[digit]))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
benchmark_args = parser.parse_args_into_dataclasses()[0]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
next(module.parameters())
return True
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return super(ZeroOrMore, self).parseImpl(instring, loc, doActions)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import cityscapesscripts.helpers.labels as CSLabels
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
r_is_nan = math.isnan(r)
if (r_is_nan or (r is None)):
    df[needed_key][idx] = []
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
read_num_format = cell.number_format
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
idx = sys.argv.index('--')
return sys.argv[(idx + 1):]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
sig = formatargspec(*getargspec(obj))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
abis.remove(explicit_abi)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
encoding = locale.getpreferredencoding()
utf8.encode(encoding)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0
"
words.append(self.dictionary.word2idx[word])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import sentencepiece as spm
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from rdkit import Chem
from rdkit.Chem.Scaffolds.MurckoScaffold import MurckoScaffoldSmiles, MurckoScaffoldSmilesFromSmiles
from .data_loader import get_smiles
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
out_mask = batch.sub_b_id.to(device)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from_config_func = type(self).from_config
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import sentencepiece as spm
self.sp = spm.SentencePieceProcessor()
self.sp.Load(vocab)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if et.docinfo.internalDTD:
    self.children.append(Doctype(self, ensure_str(et.docinfo.root_name), ensure_str(et.docinfo.public_id), ensure_str(et.docinfo.system_url)))
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
iterator = iter(first_field)
first_field_iterator = True
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
result = self.index[i].startswith(path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import apex
apex.amp.register_half_function(torch, 'einsum')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
task.load_dataset(split_k)
print('| {} {} {} examples'.format(args.data, split_k, len(task.dataset(split_k))))
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(line, field) = line.rstrip().rsplit(' ', 1)
if (field == '#fairseq:overwrite'):
    overwrite = True
    (line, field) = line.rsplit(' ', 1)
else:
    overwrite = False
count = int(field)
word = line
if ((word in self) and (not overwrite)):
    raise RuntimeError(""Duplicate word found when loading Dictionary: '{}'. Duplicate words can overwrite earlier ones by adding the #fairseq:overwrite flag at the end of the corresponding row in the dictionary file. If using the Camembert model, please download an updated copy of the model file."".format(word))
self.add_symbol(word, n=count, overwrite=overwrite)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
class_ = getattr(module, class_name)
lale_wrapper_found = True
break
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(dir2save)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
mse_dist = self._mse_dist_mat[a][b]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
_ = activemri.envs.util.import_object_from_str(reconstructor_cfg['cls'])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with open(cls.path_token, 'r') as f:
    return f.read()
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
ctx = input('Input context: ')
ctx = ctx.strip().split()
if (len(ctx) != (2 * self.num_types)):
    raise Exception()
if (np.sum([int(x) for x in ctx[0::2]]) != self.num_objects):
    raise Exception()
if (np.max([int(x) for x in ctx[1::2]]) > self.max_score):
    raise Exception()
return ctx
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(A, A_paths) = next(self.data_loader_A_iter)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
mask_color = [(x / 255) for x in self.metadata.stuff_colors[category_idx]]
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_archive_file = cached_path(archive_file, cache_dir=cache_dir, force_download=force_download, proxies=proxies)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return function(*arguments)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0
"
resolved_vocab_file = cached_path(vocab_file, cache_dir=cache_dir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
last_checkpoint_time = timer()
last_n_episode_returns = torch.zeros(flags.stats_episodes)
curr_index = (- 1)
while (step < flags.total_steps):
    start_step = step
    start_time = timer()
    time.sleep(5)
    if ((timer() - last_checkpoint_time) > (10 * 60)):
        checkpoint()
        last_checkpoint_time = timer()
    sps = ((step - start_step) / (timer() - start_time))
    episode_returns = stats.get('episode_returns', None)
    if episode_returns:
        mean_return = ('Return per episode: %.1f. ' % stats['mean_episode_return'])
        for el in episode_returns:
            last_n_episode_returns[((curr_index + 1) % flags.stats_episodes)] = el.item()
            curr_index += 1
    else:
        mean_return = ''
    total_loss = stats.get('total_loss', float('inf'))
    logging.info('Steps %i @ %.1f SPS. Loss %f. Last %i episode returns %.2f %sStats:\n%s', step, sps, total_loss, flags.stats_episodes, last_n_episode_returns.mean(), mean_return, pprint.pformat(stats))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.firstMatchChar = matchString[0]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
np.info(C(), output=out)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import onnxruntime
print(('ORT   : %s' % onnxruntime.__version__))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
tokens[file_token_count] = self.dictionary.word2idx['<unk>']
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with open(save_file, 'r') as f:
    last_saved = f.read()
    last_saved = last_saved.strip()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
_ = (x * 0.5)
_ = (_ * (1.0 + torch.erf((x / math.sqrt(2.0)))))
return _
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import sentencepiece as spm
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
_max_unsafety_v = np.max(_unsafety_v[(_unsafety_v <= (1.0 - self.confidence))])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
trajectory[key] = np.asarray(val)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
import torchaudio
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(images, targets) = next(batch_iterator)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
y_hat = y_hat[:, :y.size()[1], :]
loss = objective(y_hat.contiguous().view((- 1), y_hat.size()[(- 1)]), y.contiguous().view((- 1)))
if has_optimizer:
    optimizer.zero_grad()
    if (grad_norm_val > (- 1)):
        clip_grad_norm_(module.parameters(), max_norm=grad_norm_val, norm_type=grad_norm)
    loss.backward()
    optimizer.step()
objective_output[i] = loss.cpu().item()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
module = sys.modules[moduleOrReq]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
q.remove(node)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
(fp, pathname, description) = imp.find_module('_polyiou', [dirname(__file__)])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return bpe.is_beginning_of_word(tok)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
import sentencepiece as spm
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
root = zarr.open(zarr_dataset.path, mode='a')
root.create_group('agents_mask')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
path_to_cache_dir = os.path.join('caches', 'voc2007')
os.makedirs(path_to_cache_dir, exist_ok=True)
(_, _, ap) = voc_eval(detpath=os.path.join(path_to_results_dir, 'comp3_det_test_{:s}.txt'.format(category)), annopath=os.path.join(path_to_annotations_dir, '{:s}.xml'), imagesetfile=os.path.join(path_to_main_dir, 'test.txt'), classname=category, cachedir=path_to_cache_dir, ovthresh=0.5, use_07_metric=True)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
examples.append(next_example(dataset, i))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import regex as re
self.re = re
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert polygon.is_valid
return polygon
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
ckpt = torch.load(model_path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
src_dict = getattr(task, 'source_dictionary', None)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
logging.debug('Try to load dataset as images')
(train_ds, val_ds, test_ds) = image_folder_dataset.load_dataset(dataset_folder, inmem, workers)
(mean, std) = _load_mean_std_from_file(dataset_folder, inmem, workers)
logging.debug('Setting up dataset transforms - image classification')
logging.debug('******************************************************************** regular imageclassification')
transform = transforms.Compose([transforms.RandomHorizontalFlip(), transforms.RandomVerticalFlip(), transforms.RandomCrop((768, 768)), transforms.Resize(model_expected_input_size), transforms.ToTensor(), transforms.Normalize(mean=mean, std=std)])
transform_test = transforms.Compose([transforms.Resize(model_expected_input_size), transforms.ToTensor(), transforms.Normalize(mean=mean, std=std)])
train_ds.transform = transform
val_ds.transform = transform_test
test_ds.transform = transform_test
(train_loader, val_loader, test_loader) = _dataloaders_from_datasets(batch_size, train_ds, val_ds, test_ds, workers)
logging.info('Dataset loaded as images')
_verify_dataset_integrity(dataset_folder, disable_dataset_integrity, enable_deep_dataset_integrity)
return (train_loader, val_loader, test_loader, len(train_ds.classes))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (x_ == 0):
    return 0
return round(x_, (- math.floor(((math.log10(abs(x_)) - sigfigs) + 1))))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
id_to_indices[entity_id].append(index)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
class_names = [str(i).replace(' ', '_') for i in class_names]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
from apex.optimizers import FP16_Optimizer
from apex.optimizers import FusedAdam
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(rawmode, prefix, photo, format, bits, extra) = SAVE_INFO[im.mode]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from thop import profile
stride = (int(model.stride.max()) if hasattr(model, 'stride') else 32)
img = torch.zeros((1, model.yaml.get('ch', 3), stride, stride), device=next(model.parameters()).device)
flops = ((profile(deepcopy(model), inputs=(img,), verbose=False)[0] / 1000000000.0) * 2)
img_size = (img_size if isinstance(img_size, list) else [img_size, img_size])
fs = (', %.1f GFLOPS' % ((((flops * img_size[0]) / stride) * img_size[1]) / stride))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
while (i < len_l):
    value_repr = l[i]
    try:
        value = float(value_repr)
    except ValueError:
        value = None
    if (value is not None):
        i = self._parse_numeric_token(l, i, info, ymd, res, fuzzy)
    elif (info.weekday(l[i]) is not None):
        value = info.weekday(l[i])
        res.weekday = value
    elif (info.month(l[i]) is not None):
        value = info.month(l[i])
        ymd.append(value, 'M')
        if ((i + 1) < len_l):
            if (l[(i + 1)] in ('-', '/')):
                sep = l[(i + 1)]
                ymd.append(l[(i + 2)])
                if (((i + 3) < len_l) and (l[(i + 3)] == sep)):
                    ymd.append(l[(i + 4)])
                    i += 2
                i += 2
            elif (((i + 4) < len_l) and (l[(i + 1)] == l[(i + 3)] == ' ') and info.pertain(l[(i + 2)])):
                if l[(i + 4)].isdigit():
                    value = int(l[(i + 4)])
                    year = str(info.convertyear(value))
                    ymd.append(year, 'Y')
                else:
                    pass
                i += 4
    elif (info.ampm(l[i]) is not None):
        value = info.ampm(l[i])
        val_is_ampm = self._ampm_valid(res.hour, res.ampm, fuzzy)
        if val_is_ampm:
            res.hour = self._adjust_ampm(res.hour, value)
            res.ampm = value
        elif fuzzy:
            skipped_idxs.append(i)
    elif self._could_be_tzname(res.hour, res.tzname, res.tzoffset, l[i]):
        res.tzname = l[i]
        res.tzoffset = info.tzoffset(res.tzname)
        if (((i + 1) < len_l) and (l[(i + 1)] in ('+', '-'))):
            l[(i + 1)] = ('+', '-')[(l[(i + 1)] == '+')]
            res.tzoffset = None
            if info.utczone(res.tzname):
                res.tzname = None
    elif ((res.hour is not None) and (l[i] in ('+', '-'))):
        signal = ((- 1), 1)[(l[i] == '+')]
        len_li = len(l[(i + 1)])
        if (len_li == 4):
            hour_offset = int(l[(i + 1)][:2])
            min_offset = int(l[(i + 1)][2:])
        elif (((i + 2) < len_l) and (l[(i + 2)] == ':')):
            hour_offset = int(l[(i + 1)])
            min_offset = int(l[(i + 3)])
            i += 2
        elif (len_li <= 2):
            hour_offset = int(l[(i + 1)][:2])
            min_offset = 0
        else:
            raise ValueError(timestr)
        res.tzoffset = (signal * ((hour_offset * 3600) + (min_offset * 60)))
        if (((i + 5) < len_l) and info.jump(l[(i + 2)]) and (l[(i + 3)] == '(') and (l[(i + 5)] == ')') and (3 <= len(l[(i + 4)])) and self._could_be_tzname(res.hour, res.tzname, None, l[(i + 4)])):
            res.tzname = l[(i + 4)]
            i += 4
        i += 1
    elif (not (info.jump(l[i]) or fuzzy)):
        raise ValueError(timestr)
    else:
        skipped_idxs.append(i)
    i += 1
(year, month, day) = ymd.resolve_ymd(yearfirst, dayfirst)
res.century_specified = ymd.century_specified
res.year = year
res.month = month
res.day = day
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
assert (list(symbolic_weight.shape) == list(array.shape))
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
pointer = getattr(pointer, scope_names[0])
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (pointer.shape == array.shape), f'Pointer shape {pointer.shape} and array shape {array.shape} mismatched'
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.writer = importlib.import_module(module).SummaryWriter(log_dir)
succeeded = True
break
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(dirpath)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (list(pt_weight.shape) == list(array.shape))
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import nltk
assert (valid['nltk_bleu1'] > 0.9)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from transformers.convert_bert_original_tf_checkpoint_to_pytorch import convert_tf_checkpoint_to_pytorch
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
iter(x)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
import git
git_infos = []
for directory in dirs:
    try:
        repo = git.Repo(directory)
        try:
            branch_name = repo.active_branch.name
        except TypeError:
            branch_name = '[DETACHED]'
        git_infos.append(GitInfo(directory=directory, code_diff=repo.git.diff(None), code_diff_staged=repo.git.diff('--staged'), commit_hash=repo.head.commit.hexsha, branch_name=branch_name))
    except git.exc.InvalidGitRepositoryError as e:
        print('Not a valid git repo: {}'.format(directory))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
del callbackd[cid]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
archive = py7zr.SevenZipFile(f'{TRACKING_DIR}/{game_7z}', mode='r')
archive.extractall(path=f'{TRACKING_DIR}/{game_name}')
archive.close()
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
int(s)
return True
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
ckpt = torch.load(model_path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (value <= 0):
    raise ValueError(('Attempted to set %s timeout to %s, but the timeout cannot be set to a value less than or equal to 0.' % (name, value)))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
subprocess.call(['doxygen', '--version'])
retcode = subprocess.call(['doxygen'], cwd=app.confdir)
if (retcode < 0):
    sys.stderr.write('doxygen error code: {}\n'.format((- retcode)))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex.optimizers import FusedLAMB
self._optimizer = FusedLAMB(params, **self.optimizer_config)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
value = literal_eval(value)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
resolved_corpus_file = cached_path(corpus_file, cache_dir=cache_dir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import pyarrow.plasma as plasma
self._plasma = plasma
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
fig = optuna.visualization.plot_param_importances(study)
fig.write_html(str((output_dir / 'param_importances.html')))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
evaluator = cls.build_evaluator(cfg, dataset_name)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
data_time = storage.history('data_time').avg(20)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
traced_gpt2 = torch.jit.trace(model, inputs)
torch.jit.save(traced_gpt2, 'traced_model.pt')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
parse_to_aware_datetime(value)
return True
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0
"
val = env[name]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(cropped_face, bbox, label) = self.AU_image_dataset[img_idx]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import cv2
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if ((i % 20) == 0):
    x2 = (cx.data + ((length.data * torch.cos(theta.data)) / 2))
    x1 = (cx.data - ((length.data * torch.cos(theta.data)) / 2))
    y2 = (cy.data + ((length.data * torch.sin(theta.data)) / 2))
    y1 = (cy.data - ((length.data * torch.sin(theta.data)) / 2))
    lines_batch = torch.stack([x1, y1, x2, y2, width.data], (- 1))
    lines_batch.data[(..., (- 1))][(lines_batch[(..., (- 1))] < (1 / 4))] = 0
    vector_rendering[patches_to_optimize] = render_lines_pt(lines_batch[patches_to_optimize].detach())
    im = rasters_batch[patches_to_optimize].clone()
    im.masked_fill_((vector_rendering[patches_to_optimize] > 0), 0)
    reinit_excess_lines(cx, cy, width, length, im.reshape(im.shape[0], (- 1)), patches_to_consider=patches_to_optimize)
x2 = (cx + ((length.data * torch.cos(theta)) / 2))
x1 = (cx - ((length.data * torch.cos(theta)) / 2))
y2 = (cy + ((length.data * torch.sin(theta)) / 2))
y1 = (cy - ((length.data * torch.sin(theta)) / 2))
lines_batch = torch.stack([x1, y1, x2, y2, width.data], (- 1))
mean_field_energy = mean_field_energy_lines(lines_batch[patches_to_optimize], rasters_batch[patches_to_optimize])
pos_optimizer.zero_grad()
mean_field_energy.backward()
pos_optimizer.step()
constrain_parameters(cx, cy, theta, length, width, canvas_width=w, canvas_height=h, size_optimizer=size_optimizer)
x1 = (cx.data - ((length.data * torch.cos(theta.data)) / 2))
y1 = (cy.data - ((length.data * torch.sin(theta.data)) / 2))
x2 = (x1 + (length * torch.cos(theta.data)))
y2 = (y1 + (length * torch.sin(theta.data)))
lines_batch = torch.stack([x1, y1, x2, y2, width], (- 1))
excess_energy = size_energy(lines_batch[patches_to_optimize], rasters_batch[patches_to_optimize])
collinearity_energy = mean_vector_field_energy_lines(lines_batch[patches_to_optimize])
size_optimizer.zero_grad()
(excess_energy + collinearity_energy).backward()
size_optimizer.step()
cx.data[patches_to_optimize] = (x1.data[patches_to_optimize] + ((length.data[patches_to_optimize] * torch.cos(theta.data[patches_to_optimize])) / 2))
cy.data[patches_to_optimize] = (y1.data[patches_to_optimize] + ((length.data[patches_to_optimize] * torch.sin(theta.data[patches_to_optimize])) / 2))
constrain_parameters(cx, cy, theta, length, width, canvas_width=w, canvas_height=h, size_optimizer=size_optimizer)
x2 = (cx.data + ((length.data * torch.cos(theta.data)) / 2))
y2 = (cy.data + ((length.data * torch.sin(theta.data)) / 2))
x1 = (x2 - (length * torch.cos(theta.data)))
y1 = (y2 - (length * torch.sin(theta.data)))
lines_batch = torch.stack([x1, y1, x2, y2, width], (- 1))
excess_energy = size_energy(lines_batch[patches_to_optimize], rasters_batch[patches_to_optimize])
collinearity_energy = mean_vector_field_energy_lines(lines_batch[patches_to_optimize])
size_optimizer.zero_grad()
(excess_energy + collinearity_energy).backward()
size_optimizer.step()
cx.data[patches_to_optimize] = (x2.data[patches_to_optimize] - ((length.data[patches_to_optimize] * torch.cos(theta.data[patches_to_optimize])) / 2))
cy.data[patches_to_optimize] = (y2.data[patches_to_optimize] - ((length.data[patches_to_optimize] * torch.sin(theta.data[patches_to_optimize])) / 2))
constrain_parameters(cx, cy, theta, length, width, canvas_width=w, canvas_height=h, size_optimizer=size_optimizer)
if (((i + 1) % 20) == 0):
    snap_lines(cx, cy, theta, length, width, pos_optimizer=pos_optimizer, size_optimizer=size_optimizer)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
_a[1, :, :] = b
assert False
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
import sentencepiece as spm
self.sp = spm.SentencePieceProcessor()
self.sp.Load(vocab)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return self.tokens[index]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.fsync(self._file_handle.fileno())
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return next((cls for cls in SubplotBase.__subclasses__() if (cls.__bases__ == (SubplotBase, axes_class))))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.translator = build_translator(self.opt, report_score=False, out_file=codecs.open(os.devnull, 'w', 'utf-8'))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return getattr(sys.modules[mod_str], class_str)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
checkpoint_suffix = args.model_name_or_path.split('-')[(- 1)].split('/')[0]
global_step = int(checkpoint_suffix)
epochs_trained = (global_step // (len(train_dataloader) // args.gradient_accumulation_steps))
steps_trained_in_current_epoch = (global_step % (len(train_dataloader) // args.gradient_accumulation_steps))
logger.info('  Continuing training from checkpoint, will skip to saved global_step')
logger.info('  Continuing training from epoch %d', epochs_trained)
logger.info('  Continuing training from global step %d', global_step)
logger.info('  Will skip the first %d steps in the first epoch', steps_trained_in_current_epoch)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
for (pos, char) in enumerate(domain):
    code_point = ord(char)
    uts46row = uts46data[(code_point if (code_point < 256) else (bisect.bisect_left(uts46data, (code_point, 'Z')) - 1))]
    status = uts46row[1]
    replacement = (uts46row[2] if (len(uts46row) == 3) else None)
    if ((status == 'V') or ((status == 'D') and (not transitional)) or ((status == '3') and (not std3_rules) and (replacement is None))):
        output += char
    elif ((replacement is not None) and ((status == 'M') or ((status == '3') and (not std3_rules)) or ((status == 'D') and transitional))):
        output += replacement
    elif (status != 'I'):
        raise IndexError()
return unicodedata.normalize('NFC', output)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import re
import tensorflow as tf
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
size = int(size)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
blocks = self.blocks[name]
index = (blocks.index(current) + 1)
blocks[index]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with open(pickle_file, 'rb') as f:
    pickle_data = pickle.load(f)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0
"
return '{:.2f}'.format(math.pow(2, loss))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (self.process_group != _get_default_group()):
    pickle_not_supported = True
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(g, W) = GENERATOR_FUNCTIONS_TSP[self.generative_model](self.n_vertices)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return super(SafeFileCache, self).set(*args, **kwargs)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import ftfy
import spacy
self.nlp = spacy.load('en', disable=['parser', 'tagger', 'ner', 'textcat'])
self.fix_text = ftfy.fix_text
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
log_t = math.log(t)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
import sentencepiece as spm
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
_ = self.unnecessary_tags.index(child.tag)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
os.makedirs(self.cache_folder)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
key = self._data._validate_scalar(key, cast_str=True)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
assigned = stmt.getitem(index_node, context)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (list(self.args.labels_map.keys()) == self.args.labels_list)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
for _ in range(replabel_idx_to_value[token]):
    result.append(prev_token)
prev_token = (- 1)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
_aux_save_information['parameter_dict'].pop('vectors')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
pointer = getattr(pointer, m_name)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
args.lstm_delay = ParseLstmDelayString(args.lstm_delay.strip())
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
self.info(('%sexporter_info' % prefix), 'Information about the Prometheus Flask exporter', version=self.version)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
expr_parse(instring, tmploc, doActions=False, callPreParse=False)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
speed = (sum(lane_states[lane]['speed']) / len(lane_states[lane]['speed']))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
checkpoint_suffix = args.model_name_or_path.split('-')[(- 1)].split('/')[0]
global_step = int(checkpoint_suffix)
epochs_trained = (global_step // (len(train_dataloader) // args.gradient_accumulation_steps))
steps_trained_in_current_epoch = (global_step % (len(train_dataloader) // args.gradient_accumulation_steps))
logger.info('  Continuing training from checkpoint, will skip to saved global_step')
logger.info('  Continuing training from epoch %d', epochs_trained)
logger.info('  Continuing training from global step %d', global_step)
logger.info('  Will skip the first %d steps in the first epoch', steps_trained_in_current_epoch)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
from urllib.request import urlopen
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with torch.no_grad():
    (action, value) = actor_critic.forward([obs])
(obs, reward, done, infos) = env.step(action[0])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
l = [float(e) for e in seq]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
with open(cls.path_token, 'r') as f:
    return f.read()
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return list(map(type, x))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
return tensor.sparse_mask(mask)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
cmd = ('lsb_release', '-a')
stdout = subprocess.check_output(cmd, stderr=devnull)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
bbox = map(int, self.detector.detect_face(img[:, :, ::(- 1)])[0][0][:(- 1)])
bbox = [max(0, i) for i in bbox]

def marginP(x, y):
    return int((x + (y / margin)))

def marginM(x, y):
    return int((x - (y / margin)))
bbox = [marginM(bbox[0], (bbox[2] - bbox[0])), marginM(bbox[1], (bbox[3] - bbox[1])), marginP(bbox[2], (bbox[2] - bbox[0])), marginP(bbox[3], (bbox[3] - bbox[1]))]
bbox = [max(0, i) for i in bbox]
img_face = img[bbox[1]:bbox[3], bbox[0]:bbox[2]]
return (img_face, True)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
len(bitdepth)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
iterator = iter(first_field)
first_field_iterator = True
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
from pytorch_transformers import BertTokenizer
from pytorch_transformers.tokenization_utils import clean_up_tokenization
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import pydot
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
sock.bind(('', port))
sock.close()
return port
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
is_scalar = ((not sym_help._is_packed_list(size)) and (sym_help._maybe_get_const(size, 't').dim() == 0))
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from lvis import LVISResults, LVISEval
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
overload = self.methods[method_name]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
nextchar = string[idx]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from fairseq import libnat_cuda
return (libnat_cuda, True)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
module_name = ('%s.agents.%s.agents' % (repo, dir_name))
importlib.import_module(module_name)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.fsync(self._file_handle.fileno())
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
values.append(float(line))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
from apex.optimizers import FusedLAMB
self._optimizer = FusedLAMB(params, **self.optimizer_config)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
cmd = ('uname', '-rs')
stdout = subprocess.check_output(cmd, stderr=devnull)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
version.append(int(x))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
if (not ignore_utf_errors):
    with open(f, 'r', encoding='utf-8') as fd:
        self.add_from_file(fd)
else:
    with open(f, 'r', encoding='utf-8', errors='ignore') as fd:
        self.add_from_file(fd)
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (pointer.shape == array.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if is_url(self.io):
    with urlopen(self.io) as f:
        r = parse(f, parser=parser)
else:
    r = parse(self.io, parser=parser)
try:
    r = r.getroot()
except AttributeError:
    pass
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
buf.append(next(reader))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with gzip.open(file_path, 'rb') as f:
    pkl_obj = f.read()
    obj = pickle.loads(pkl_obj)
    return obj
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
trial.with_generators(train_generator=train_loader, val_generator=val_loader).run(epochs=self.epochs)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
pidfile = open(pidfile_path, 'r')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (pointer.shape == array.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import apex
apex.amp.register_half_function(torch, 'einsum')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
object.__getattribute__(self, name)
return object.__setattr__(self, name, value)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import numpy as np
import tensorflow as tf
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return getattr(module, class_name)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
gradcheck(find_homography_dlt, (points_src, points_dst, weights), rtol=1e-06, atol=1e-06, raise_exception=True)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (tuple(pointer.shape) == array.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
message['text'] = 'rofl'
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
s = finder[item]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
flop(x, y)
assert_(False, (""Type %s did not raise fpe error '%s'."" % (ftype, fpeerr)))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_vocab_file = cached_path(vocab_file, cache_dir=cache_dir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return int(v)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0
"
return self.make_c_thunk(node, storage_map, compute_map, no_recycling)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
output_label.append(tokenizer.vocab[token])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
r = (tp / (tp + fn))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1
"
key = self._selector.get_key(fd)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
eos_index = next((i for (i, v) in enumerate(sequence) if (v == eos)))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(pid, status) = os.waitpid((- 1), os.WNOHANG)
",0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (p_i.shape == arr_i.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(processor, obj, index) = self._keymap[key]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from fairseq import libbase
return libbase
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return self.__dict__[attr]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import cv2
show_animation = True
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (pointer.shape == array.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
lvis_dt = LVISResults(lvis_gt, result_files[metric])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
duplicate_params = request.duplicate_params
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
obj_pos = obj_desc.obj_poss[i]
if self.vis_mask[obj_pos]:
    shortest_path_to_obj = None
    if use_shortest_path:
        (shortest_path_to_obj, _, _) = self.shortest_path((lambda pos, cell: (pos == obj_pos)))
    if (shortest_path_to_obj is not None):
        distance_to_obj = len(shortest_path_to_obj)
    else:
        distance_to_obj = self.distance(obj_pos, self.mission.agent_pos)
    if ((not best_distance_to_obj) or (distance_to_obj < best_distance_to_obj)):
        best_distance_to_obj = distance_to_obj
        best_pos = obj_pos
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex.optimizers import FP16_Optimizer
from apex.optimizers import FusedAdam
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from deepspeed.ops.sparse_attention import VariableSparsityConfig
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
cryptography_version = list(map(int, cryptography_version.split('.')))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
result = inference_manager.run(model, dataloader)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
nn.utils.remove_weight_norm(module)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
assert (pointer.shape == array.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import instaboostfast as instaboost
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from subword_nmt import apply_bpe
bpe_parser = apply_bpe.create_parser()
bpe_args = bpe_parser.parse_args(['--codes', codes, '--separator', args.bpe_separator])
self.bpe = apply_bpe.BPE(bpe_args.codes, bpe_args.merges, bpe_args.separator, None, bpe_args.glossaries)
self.bpe_symbol = (bpe_args.separator + ' ')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex import amp
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex import amp
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
monet_pseudo = None
if (MODEL_NAME == 'MoNet'):
    print('\nPre-computing MoNet pseudo-edges')
    (us, vs) = graph.edges()
    monet_pseudo = [[(1 / np.sqrt((graph.in_degree(us[i]) + 1))), (1 / np.sqrt((graph.in_degree(vs[i]) + 1)))] for i in range(graph.number_of_edges())]
    monet_pseudo = torch.Tensor(monet_pseudo)
with tqdm(range(params['epochs'])) as t:
    for epoch in t:
        t.set_description(('Epoch %d' % epoch))
        start = time.time()
        (epoch_train_loss, optimizer) = train_epoch(model, optimizer, device, graph, train_edges, params['batch_size'], epoch, monet_pseudo)
        (epoch_train_hits, epoch_val_hits, epoch_test_hits) = evaluate_network(model, device, graph, train_edges, val_edges, val_edges_neg, test_edges, test_edges_neg, evaluator, params['batch_size'], epoch, monet_pseudo)
        epoch_train_losses.append(epoch_train_loss)
        epoch_train_hits.append(epoch_train_hits)
        epoch_val_hits.append(epoch_val_hits)
        writer.add_scalar('train/_loss', epoch_train_loss, epoch)
        writer.add_scalar('train/_hits@10', (epoch_train_hits[0] * 100), epoch)
        writer.add_scalar('train/_hits@50', (epoch_train_hits[1] * 100), epoch)
        writer.add_scalar('train/_hits@100', (epoch_train_hits[2] * 100), epoch)
        writer.add_scalar('val/_hits@10', (epoch_val_hits[0] * 100), epoch)
        writer.add_scalar('val/_hits@50', (epoch_val_hits[1] * 100), epoch)
        writer.add_scalar('val/_hits@100', (epoch_val_hits[2] * 100), epoch)
        writer.add_scalar('test/_hits@10', (epoch_test_hits[0] * 100), epoch)
        writer.add_scalar('test/_hits@50', (epoch_test_hits[1] * 100), epoch)
        writer.add_scalar('test/_hits@100', (epoch_test_hits[2] * 100), epoch)
        writer.add_scalar('learning_rate', optimizer.param_groups[0]['lr'], epoch)
        t.set_postfix(time=(time.time() - start), lr=optimizer.param_groups[0]['lr'], train_loss=epoch_train_loss, train_hits=epoch_train_hits[1], val_hits=epoch_val_hits[1], test_hits=epoch_test_hits[1])
        per_epoch_time.append((time.time() - start))
        ckpt_dir = os.path.join(root_ckpt_dir, 'RUN_')
        if (not os.path.exists(ckpt_dir)):
            os.makedirs(ckpt_dir)
        torch.save(model.state_dict(), '{}.pkl'.format(((ckpt_dir + '/epoch_') + str(epoch))))
        files = glob.glob((ckpt_dir + '/*.pkl'))
        for file in files:
            epoch_nb = file.split('_')[(- 1)]
            epoch_nb = int(epoch_nb.split('.')[0])
            if (epoch_nb < (epoch - 1)):
                os.remove(file)
        scheduler.step(epoch_val_hits[1])
        if (optimizer.param_groups[0]['lr'] < params['min_lr']):
            print('\n!! LR EQUAL TO MIN LR SET.')
            break
        if ((time.time() - t0) > (params['max_time'] * 3600)):
            print(('-' * 89))
            print('Max_time for training elapsed {:.2f} hours, so stopping'.format(params['max_time']))
            break
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with open(temp_file_path, 'w'):
    pass
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return insp.selectable
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
cmd = ('uname', '-rs')
stdout = subprocess.check_output(cmd, stderr=devnull)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
n = f.__qualname__
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
torch.autograd.gradcheck(f, (x1, x2, lengthscale))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
mkdir(dirname, 493)
",0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from tensorflow.contrib.graph_editor import get_backward_walk_ops
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
spine = self.axes.spines['bottom']
spinebbox = spine.get_transform().transform_path(spine.get_path()).get_extents()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
v = literal_eval(v)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
batch_outputs[key] = tf.constant(value)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
from torch.cuda import amp
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
buf_start = self.decoder.count
hook_id = self.decoder.readByte()
world_tick = self.decoder.readLong()
if (world_tick < self.last_tick):
    raise RuntimeError(('Error: {} < {}\n'.format(world_tick, self.last_tick) + 'buf_start={} hook_id={}'.format(buf_start, hook_id)))
self.last_tick = world_tick
self.decode_and_handle_hook(hook_id, world_tick, buf_start)
",0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(ords, vals) = zip(*deriv)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
(src, ext) = build[obj]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
for c in iterbytes(chunk):
    acc = ((acc * 85) + _b85dec[c])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
sample = next(dl_iter)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
number = int(no_comma_word)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
assert (model.tokens_embed.weight.shape == init_params[1].shape)
assert (model.positions_embed.weight.shape == init_params[0].shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from nltk.translate import bleu_score as nltkbleu
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
ckpt['model'] = {k: v for (k, v) in ckpt['model'].items() if (model.state_dict()[k].numel() == v.numel())}
model.load_state_dict(ckpt['model'], strict=False)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (pointer.shape == array.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(ls_x, ls_y) = visible['left_shoulder']
(rs_x, rs_y) = visible['right_shoulder']
(mid_shoulder_x, mid_shoulder_y) = (((ls_x + rs_x) / 2), ((ls_y + rs_y) / 2))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
temp = added_label[(y_min + ty):((y_max + 1) + ty), (x + tx):((x_max + 1) + tx)]
added_label[(y_min + ty):((y_max + 1) + ty), (x + tx):((x_max + 1) + tx)] = np.logical_or(temp, added_label[y_min:(y_max + 1), x:(x_max + 1)])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
(flow_face, _) = FaceMaskCropper.get_cropface_and_box(adjacent_flow_path, adjacent_rgb_path, channel_first=True, mc_manager=self.mc_manager, key_prefix=key_prefix)
flow_face = flow_face[:2, :, :]
flow_face_list.append(flow_face)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
batch_outputs[key] = tf.constant(value)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
from apex.optimizers import FP16_Optimizer
from apex.optimizers import FusedAdam
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
data[key] = np.array([float(x) for x in value.split()])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
nn.utils.remove_weight_norm(module)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
CLIENT_FLAGS = __import__((self.dbapi.__name__ + '.constants.CLIENT')).constants.CLIENT
client_flag |= CLIENT_FLAGS.FOUND_ROWS
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
validation_perplexity = math.exp(history.history['val_loss'][(- 1)])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.set_defaults(**self._defaults)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
image = plt.imread(img_path).copy()
success = True
if ((image.ndim != 3) or (image.shape[2] != 3) or np.any((np.array(image.strides) < 0))):
    success = False
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return self.__fp.closed
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(charge_value, electrostatic_pot_value) = self._pqr[atom_id]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
column_types = line[2].split()
table = line[3]
fact = line[4]
label = line[5]
verb = lines_verb[i]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import sentencepiece as spm
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
checkpoint_suffix = args.model_name_or_path.split('-')[(- 1)].split('/')[0]
global_step = int(checkpoint_suffix)
epochs_trained = (global_step // (len(train_dataloader) // args.gradient_accumulation_steps))
steps_trained_in_current_epoch = (global_step % (len(train_dataloader) // args.gradient_accumulation_steps))
logger.info('  Continuing training from checkpoint, will skip to saved global_step')
logger.info('  Continuing training from epoch %d', epochs_trained)
logger.info('  Continuing training from global step %d', global_step)
logger.info('  Will skip the first %d steps in the first epoch', steps_trained_in_current_epoch)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
(firstaxis, parity, repetition, frame) = _AXES2TUPLE[axes.lower()]
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return int(value)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
assert (list(pt_weight.shape) == list(array.shape))
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex.normalization import FusedLayerNorm
return FusedLayerNorm(normalized_shape, eps, elementwise_affine)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
cy_thresh = (np.finfo(M.dtype).eps * 4)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
output_label.append(self.tokenizer.vocab[sub_token])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
v = float(v)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
return sys.modules[fullname]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
out = _minimal_ext_cmd(['git', 'rev-parse', 'HEAD'])
sha = out.strip().decode('ascii')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
tokenizer = cls(*init_inputs, **init_kwargs)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
last_state_index = (2 if self._module.bidirectional else 1)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from lvis import LVIS
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
nn.utils.remove_weight_norm(module)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
with open(optfile, 'r') as handle:
    new_opt = json.load(handle)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0
"
thisWordList = flatten(results)
numWords = (len(flatten([word.split('-') for word in thisWordList])) - numFillers)
numSents = (len(results) - sentDiscount)
mlu = (numWords / numSents)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1
"
(x, _, d, x2, _, d2) = next(self.iter)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import onnxruntime as ort
from mmedit.core.export.wrappers import ONNXRuntimeEditing, ONNXRuntimeRestorer
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
size = __calcsize_cache[fmt]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from torch.utils.tensorboard import SummaryWriter
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (pointer.shape == array.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_vocab_file = cached_path(vocab_file, cache_dir=cache_dir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import re
import numpy as np
import tensorflow as tf
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
norm = float(torch.norm(fp16_grads_flat, 2.0, dtype=torch.float32))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
metadata_json = json.dumps(obj=final_metadata_dict, cls=SafeFallbackJSONEncoder)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
from apex.parallel import DistributedDataParallel as DDP
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
data = next(self.dataset_iter)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (pointer.shape == array.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from torch_xla.distributed.parallel_loader import MpDeviceLoader
dl_type = MpDeviceLoader
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from fairseq import libnat
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
finite_mdp = __import__('finite_mdp.envs.finite_mdp_env')
if isinstance(env, finite_mdp.envs.finite_mdp_env.FiniteMDPEnv):
    return True
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
return cls(freq=string)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
import sentencepiece as spm
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
img = np.load(npy_path.format(i))
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with open(tst_list_path, 'r') as tstf:
    tst_list_0 = tstf.readlines()
    for path in tst_list_0:
        img_path = os.path.join(dir, 'BSR/BSDS500/data/images/test', (path[:(- 1)] + '.jpg'))
        if (not os.path.isfile(img_path)):
            print('The validate images are missing in {}'.format(os.path.dirname(img_path)))
            print('Please pre-process the BSDS500 as README states and provide the correct dataset path.')
            exit(1)
        tst_list.append(img_path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
csv_file = _load_analytics_csv(dataset_folder, inmem, workers)
mean = np.asarray(csv_file.ix[0, 1:3])
std = np.asarray(csv_file.ix[1, 1:3])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_archive_file = cached_path(archive_file, cache_dir=cache_dir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
for s in self.schema:
    if (s[0] == ZeroPadOp):
        reifiedSchema.append(zero_pad_fn(batchSize, s[1]))
    else:
        entry = entries[s[0]]
        if callable(entry):
            reifiedSchema.append(entry(batchSize, s[1]))
        else:
            reifiedSchema.append(entry)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
file = ((file and abspath(file)) or '?')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
name = os.environ['TZ']
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import hydra
original_cwd = hydra.utils.get_original_cwd()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
return int(v)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0
"
os.symlink(target, link_name)
",0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (pointer.shape == array.shape), f'Pointer shape {pointer.shape} and array shape {array.shape} mismatched'
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
in_order_args = [locals_[arg] for arg in spec.args][1:]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return ((self._ip == other._ip) and (self._version == other._version))
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
labeled_id = (Labeled.objects.aggregate(Max('id'))['id__max'] + 1)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
tfile.extractall(path=datadir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(pron, post) = entry.pop()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import sentencepiece as spm
self.sp = spm.SentencePieceProcessor()
self.sp.Load(vocab)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (list(symbolic_weight.shape) == list(array.shape))
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import torch
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import requests
response = requests.head(url, allow_redirects=True)
if (response.status_code != 200):
    etag = None
else:
    etag = response.headers.get('ETag')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_corpus_file = cached_path(corpus_file, cache_dir=cache_dir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from fairseq import libnat_cuda
return (libnat_cuda, True)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
word_ids.append(self.gram2id[word])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with open(os.path.join(args.output_path, 'MASK_video_idx_{}'.format(attack_idx)), 'wb') as opt_write:
    pickle.dump(one_class.best_MASK, opt_write)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if hasattr(data, '__len__'):
    return len(data)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
with torch.no_grad():
    '\n                NEW: batch_predictions can now be of shape (batch_size,batch_max_seq_len,topk) if topk>1, else (batch_size,batch_max_seq_len)\n                '
    (batch_loss, batch_predictions) = model(batch_idxs, inverted_mask, batch_lengths, batch_elmo_inp, targets=batch_labels, topk=topk)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from mmdet.version import __version__
sha = __version__.split('+')[(- 1)]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(py, nm, inv) = latent_estimation.estimate_latent(confident_joint=data['cj'], s=data['s'], py_method='INVALID')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
checkpoint_suffix = args.model_name_or_path.split('-')[(- 1)].split('/')[0]
global_step = int(checkpoint_suffix)
epochs_trained = (global_step // (len(train_dataloader) // args.gradient_accumulation_steps))
steps_trained_in_current_epoch = (global_step % (len(train_dataloader) // args.gradient_accumulation_steps))
logger.info('  Continuing training from checkpoint, will skip to saved global_step')
logger.info('  Continuing training from epoch %d', epochs_trained)
logger.info('  Continuing training from global step %d', global_step)
logger.info('  Will skip the first %d steps in the first epoch', steps_trained_in_current_epoch)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
self.init_.fit(X, y, sample_weight=sample_weight)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
logging.info('Actor %i started.', actor_index)
timings = prof.Timings()
seed = (actor_index ^ int.from_bytes(os.urandom(4), byteorder='little'))
gym_env = create_env(flags, level_name, seed)
env = environment.Environment(gym_env)
env_output = env.initial()
agent_state = model.initial_state(batch_size=1)
(agent_output, unused_state) = model(env_output, agent_state)
while True:
    index = free_queue.get()
    if (index is None):
        break
    for key in env_output:
        buffers[key][index][(0, ...)] = env_output[key]
    for key in agent_output:
        buffers[key][index][(0, ...)] = agent_output[key]
    for (i, tensor) in enumerate(agent_state):
        initial_agent_state_buffers[index][i][...] = tensor
    for t in range(flags.unroll_length):
        timings.reset()
        with torch.no_grad():
            (agent_output, agent_state) = model(env_output, agent_state)
        timings.time('model')
        env_output = env.step(agent_output['action'])
        timings.time('step')
        for key in env_output:
            buffers[key][index][((t + 1), ...)] = env_output[key]
        for key in agent_output:
            buffers[key][index][((t + 1), ...)] = agent_output[key]
        timings.time('write')
    full_queue.put(index)
if (actor_index == 0):
    logging.info('Actor %i: %s', actor_index, timings.summary())
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import psutil
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(_loss, sample_size, logging_output) = self.task.valid_step(sample, self.model, self.criterion)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
nonlinearity = {'RNN_TANH': 'tanh', 'RNN_RELU': 'relu'}[rnn_type]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
checkpoint_suffix = args.model_name.split('/')[(- 1)].split('-')
if (len(checkpoint_suffix) > 2):
    checkpoint_suffix = checkpoint_suffix[1]
else:
    checkpoint_suffix = checkpoint_suffix[(- 1)]
global_step = int(checkpoint_suffix)
epochs_trained = (global_step // (len(train_dataloader) // args.gradient_accumulation_steps))
steps_trained_in_current_epoch = (global_step % (len(train_dataloader) // args.gradient_accumulation_steps))
logger.info('   Continuing training from checkpoint, will skip to saved global_step')
logger.info('   Continuing training from epoch %d', epochs_trained)
logger.info('   Continuing training from global step %d', global_step)
logger.info('   Will skip the first %d steps in the current epoch', steps_trained_in_current_epoch)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
from fairseq import libnat
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
model_class = model.module.__class__.__name__
model_state = model.to('cpu').module.state_dict()
print('Saving unwrapped DataParallel module.')
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if self.tpu_name:
    tpu = tf.distribute.cluster_resolver.TPUClusterResolver(self.tpu_name, zone=self.tpu_zone, project=self.gcp_project)
else:
    tpu = tf.distribute.cluster_resolver.TPUClusterResolver()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
import pytest
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
val = int(val)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
from apex.optimizers import FP16_Optimizer
from apex.optimizers import FusedAdam
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if self.tpu_name:
    tpu = tf.distribute.cluster_resolver.TPUClusterResolver(self.tpu_name, zone=self.tpu_zone, project=self.gcp_project)
else:
    tpu = tf.distribute.cluster_resolver.TPUClusterResolver()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
batch.append(next(self.random_sampler_natural))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from mmcv.onnx.symbolic import register_extra_symbolics
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
iter(size)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
acts[index] = agent.act(timeout=None)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
(image, score_map, training_mask, G_d) = next(data_loader_iter)
balanced_batch_images.append(image)
balanced_batch_score_maps.append(score_map)
balanced_batch_training_masks.append(training_mask)
balanced_batch_Gds.append(G_d)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
f_iter = iter(field)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
float(inps[(k - 1)])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
os.killpg(os.getpgid(worker_process.pid), signal.SIGTERM)
print(f'Process {pid} killed')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
idx = slot_meta.index(k)
if (vv != v):
    if ((v == 'dontcare') and (OP_SET[op_code].get('dontcare') is not None)):
        op_labels[idx] = 'dontcare'
    elif ((v == 'yes') and (OP_SET[op_code].get('yes') is not None)):
        op_labels[idx] = 'yes'
    elif ((v == 'no') and (OP_SET[op_code].get('no') is not None)):
        op_labels[idx] = 'no'
    else:
        op_labels[idx] = 'update'
        generate_y.append([(tokenizer.tokenize(v) + ['[EOS]']), idx])
elif (vv == v):
    op_labels[idx] = 'carryover'
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
import moviepy
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (len(task_vid_paths) == self.demos[task]['demoX'].shape[0])
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (model.tokens_embed.weight.shape == init_params[1].shape)
assert (model.positions_embed.weight.shape == init_params[0].shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.ws = WebsocketServer(port, host='127.0.0.1')
self.port = port
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
result = self._inner_indexer(lvals, rvals)[0]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
(yield pickle.load(f, **self._pickle_kwargs))
",0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
like_gpu_tensor = ((x.device.type == 'cuda') and hasattr(x, 'to'))
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
random_adjust_sharpness_op = c_vision.RandomAdjustSharpness(2.0, 1.5)
dataset = dataset.map(operations=random_adjust_sharpness_op, input_columns=['image'])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
resolved_archive_file = cached_path(archive_file, cache_dir=cache_dir, force_download=force_download, proxies=proxies)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import h5py
self.h5py = h5py
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(yield iterator.__next__())
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
j = word.index(first, i)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
assert (model.tokens_embed.weight.shape == init_params[1].shape)
assert (model.positions_embed.weight.shape == init_params[0].shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
chkpt['model'] = {k: v for (k, v) in chkpt['model'].items() if (model.state_dict()[k].numel() == v.numel())}
model.load_state_dict(chkpt['model'], strict=False)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_corpus_file = cached_path(corpus_file, cache_dir=cache_dir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import lvis
assert (lvis.__version__ >= '10.5.3')
from lvis import LVISResults, LVISEval
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return pickle.load(open(path, 'rb'))
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
X: Tensor = gen_batch_initial_conditions(acq_func, bounds, q_q_fantasies, self.num_restarts, self.num_raw_samples, options={'seed': (self.seed + self.num_points)})
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return bool(eval(x))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
assert (pointer.shape == array.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.anin2_msg.data = o['analogIn2']
self.pub_anin2 = True
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
f = open(versionfile_abs, 'r')
for line in f.readlines():
    if line.strip().startswith('git_refnames ='):
        mo = re.search('=\\s*""(.*)""', line)
        if mo:
            keywords['refnames'] = mo.group(1)
    if line.strip().startswith('git_full ='):
        mo = re.search('=\\s*""(.*)""', line)
        if mo:
            keywords['full'] = mo.group(1)
    if line.strip().startswith('git_date ='):
        mo = re.search('=\\s*""(.*)""', line)
        if mo:
            keywords['date'] = mo.group(1)
f.close()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.images.append(np.block([dataset[image_set][0], dataset[image_set][1]]).astype(np.float32))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
if ('pythainlp' not in sys.modules):
    from pythainlp.tokenize import word_tokenize as th_word_tokenize
else:
    th_word_tokenize = sys.modules['pythainlp'].word_tokenize
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
num = int(os.environ['NUMBER_OF_PROCESSORS'])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
os.remove(cls.path_token)
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import torchtext.vocab as vocab
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return bpe.is_beginning_of_word(tok)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
m.set_chosen_op_active()
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
db = apsw.Connection(':memory:')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1
"
return self._descriptors[symbol].file
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
for k in range(0, (self.M + 1)):
    L = list(combinations(range(0, self.M), k))
    for j in range(len(L)):
        z_[(i, L[j])] = torch.ones(k)
        i += 1
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
px = pycuda.gpuarray.zeros((3, 4, 5), 'float64')
to_cudandarray(px)
assert False
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
if hasattr(function, 'compat_func_name'):
    funcname = function.compat_func_name
else:
    funcname = function.__name__
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
shape = matrix.shape
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (filename == '-'):
    lines = codecs.StreamReaderWriter(sys.stdin, codecs.getreader('utf8'), codecs.getwriter('utf8'), 'replace').read().split('\n')
else:
    lines = codecs.open(filename, 'r', 'utf8', 'replace').read().split('\n')
carriage_return_found = False
for linenum in range(len(lines)):
    if lines[linenum].endswith('\r'):
        lines[linenum] = lines[linenum].rstrip('\r')
        carriage_return_found = True
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with open(save_file, 'r') as f:
    last_saved = f.read()
    last_saved = last_saved.strip()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from fairseq.modules.lightconv_layer import LightconvLayer
return LightconvLayer(input_size, kernel_size=kernel_size, padding_l=padding_l, num_heads=num_heads, weight_dropout=weight_dropout, weight_softmax=weight_softmax, bias=bias)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
evaluator = cls.build_evaluator(cfg, dataset_name)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
n = int(idx)
d = d[n]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
from pavi import modelcloud
from pavi.exception import NodeNotFoundError
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import wandb
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
grid_ref = fig._grid_ref
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
repo_dpath = dirname(dirname(__file__))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_archive_file = cached_path(archive_file, cache_dir=cache_dir, force_download=force_download, proxies=proxies)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
evaluator = cls.build_evaluator(cfg, dataset_name)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
raw_text = input('Model input >>> ')
while (not raw_text):
    print('Input should not be empty!')
    raw_text = input('Model input >>> ')
",0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
acts[index] = agent.act(timeout=None)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
self.model.load_state_dict(state_dict)
return
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(j, bpe_tok) = next(bpe_toks)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
exp_path = exp
params_json = load_json(os.path.join(exp_path, 'params.json'))
progress_csv_path = os.path.join(exp_path, 'progress.csv')
pkl_paths = []
if (gap > 0):
    for pkl_path in glob.iglob(os.path.join(exp_path, '*.pkl')):
        pkl_paths.append(pkl_path)
    pkl_paths.sort(key=(lambda x: int(x.split('_')[(- 1)][:(- 4)])))
    pkl_paths = pkl_paths[:max:gap]
exps_data.append(dict(csv=progress_csv_path, json=params_json, pkl=pkl_paths, exp_name=exp_path))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(yield)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
cocoDt = cocoGt.loadRes(result_files[metric])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
getattr(obj, method).__getitem__(axified)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
with PathManager.open(f, 'r', encoding='utf-8') as fd:
    self.set_from_json(fd)
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
array = np.reshape(saved_weight_value, K.int_shape(symbolic_weight))
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (pointer.shape == array.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return webencodings.lookup(encoding)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
i = word.index(new_pair, i)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
return f.readline()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0
"
return reverse_mapping[value]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
addr = ipaddress.ip_address((origin[1] if (isinstance(origin[1], six.text_type) or (origin[1] is None)) else origin[1].decode('utf8')))
network = ipaddress.ip_network((secure_origin[1] if isinstance(secure_origin[1], six.text_type) else secure_origin[1].decode('utf8')))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
os.makedirs(save_path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (issubclass(elem, op.Op) and (not isinstance(r.owner.op, elem))):
    return False
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
from apex.optimizers import FP16_Optimizer
from apex.optimizers import FusedAdam
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
answer_char_span = token_aligner.project_token_to_char_span(answer_span['span'][0], answer_span['span'][1], inclusive=True)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
int(s)
return True
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
pointer = getattr(pointer, scope_names[0])
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(dirname)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_corpus_file = cached_path(corpus_file, cache_dir=cache_dir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
pointer = getattr(pointer, scope_names[0])
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
homophones[w1].append(w2)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return self.word2idx[word]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if six.PY2:
    sdist_add_defaults._add_defaults_data_files(self)
else:
    super()._add_defaults_data_files()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
assert (model.tokens_embed.weight.shape == init_params[1].shape)
assert (model.positions_embed.weight.shape == init_params[0].shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
text_a = line[q1_index]
text_b = line[q2_index]
label = (None if test_mode else line[5])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
revision = self._revision_map[resolved_id]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_vocab_file = cached_path(vocab_file, cache_dir=cache_dir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
classname = self.__class__.__name__
nice = self.__nice__()
return '<{0}({1})>'.format(classname, nice)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
result |= locator.get_distribution_names()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
connection_recall = (num_gt_connections_recalled / num_gt_connections)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1
"
for _m in value:
    _strict_call(_m)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
pointer = getattr(pointer, scope_names[0])
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
filename = os.path.join(load_dir, (('probs' + str(i)) + '.hdf5'))
f_probs = h5py.File(filename, 'r')
probs = np.asarray(f_probs['probabilities'])
gt_train = np.asarray(f_probs['gt_train_ids'])
gt_label = np.asarray(f_probs['gt_label_ids'])
probs = np.squeeze(probs)
gt_train = np.squeeze(gt_train)
gt_label = np.squeeze(gt_label)
im_path = f_probs['image_path'][0].decode('utf8')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
masked_ratio = float(arg)
print('Masked ratio is set to', masked_ratio)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
basefmt = args[2]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
cte(self)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
config.read(repo_config)
config.set('paths', 'default', url)
with open(repo_config, 'w') as config_file:
    config.write(config_file)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(loc, tokens) = self.parseImpl(instring, preloc, doActions)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.set_zlim(0, 1)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
import psutil
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import re
import numpy as np
import tensorflow as tf
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_config_file = cached_path(config_file, cache_dir=cache_dir, force_download=force_download, proxies=proxies, resume_download=resume_download, local_files_only=local_files_only)
if (resolved_config_file is None):
    raise EnvironmentError
config_file = Config.load_yaml(resolved_config_file)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(os.path.join(self.root))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
step = int(fields[0])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
resolved_archive_file = cached_path(archive_file, cache_dir=cache_dir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
pointer = getattr(pointer, l[0])
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (self._optimizer._maxiter != 1):
    warnings.warn('Please set the the optimizer maxiter argument to 1 to ensure that the generator and discriminator are updated in an alternating fashion.')
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
word_vec = wv[word]
found_cnt += 1
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex import amp
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
n = operator.index(n)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
if (sample_size > 0):
    self.optimizer.multiply_grads((self.args.distributed_world_size / float(sample_size)))
grad_norm = self.optimizer.clip_grad_norm(self.args.clip_norm)
self._prev_grad_norm = grad_norm
self.optimizer.step()
self.set_num_updates((self.get_num_updates() + 1))
self.task.update_step(self._num_updates)
ntokens = logging_output.get('ntokens', 0)
nsentences = logging_output.get('nsentences', 0)
self.meters['wps'].update(ntokens)
self.meters['ups'].update(1.0)
self.meters['wpb'].update(ntokens)
self.meters['bsz'].update(nsentences)
self.meters['gnorm'].update(grad_norm)
self.meters['clip'].update((1.0 if ((grad_norm > self.args.clip_norm) and (self.args.clip_norm > 0)) else 0.0))
self.meters['train_loss'].update(logging_output.get('loss', 0), sample_size)
if ('train_acc' in self.meters):
    self.meters['train_acc'].update(logging_output.get('acc', 0), sample_size)
if ('nll_loss' in logging_output):
    self.meters['train_nll_loss'].update(logging_output.get('nll_loss', 0), ntokens)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (iteration in stats_table[component_name]['stats']):
    stats_table[component_name]['stats'][iteration].extend([value_mean, value_stddev, deriv_mean, deriv_stddev, value_5th, value_50th, value_95th, deriv_5th, deriv_50th, deriv_95th])
else:
    stats_table[component_name]['stats'][iteration] = [value_mean, value_stddev, deriv_mean, deriv_stddev, value_5th, value_50th, value_95th, deriv_5th, deriv_50th, deriv_95th]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
args.model_type = args.model_type.lower()
(model_class, tokenizer_class) = MODEL_CLASSES[args.model_type]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
_ = c_vision.GaussianBlur([2, 2])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
shutil.rmtree(log_dir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
retval = sb.array(recList, dtype=descr)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0
"
setattr(self, key, value)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.repo.push_to_hub(commit_message='update model card README.md', blocking=blocking)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from tensorboardX import SummaryWriter
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from mmdet.version import __version__
sha = __version__.split('+')[(- 1)]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
phones = ' '.join(splits[2:])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
from subword_nmt import apply_bpe
bpe_parser = apply_bpe.create_parser()
bpe_args = bpe_parser.parse_args(['--codes', codes, '--separator', args.bpe_separator])
self.bpe = apply_bpe.BPE(bpe_args.codes, bpe_args.merges, bpe_args.separator, None, bpe_args.glossaries)
self.bpe_symbol = (bpe_args.separator + ' ')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
shebang.decode('utf-8')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0
"
for i in range(params['train_steps']):
    print(('Step %d' % (i,)))
    if ((params['save_iters'] > 0) and ((i % params['save_iters']) == 0)):
        store['checkpoints'].append_row({'iteration': i, 'val_model': p.val_model.state_dict(), 'policy_model': p.policy_model.state_dict(), 'policy_opt': p.POLICY_ADAM.state_dict(), 'val_opt': p.val_opt.state_dict(), 'envs': p.envs})
    mean_reward = p.train_step()
    rewards.append(mean_reward)
finalize_table(i, False, rewards)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
confidence = 1.0
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
return (landmarks[0], True)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
coefs = LogisticRegression().fit(X, y).coef_
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
self._previous_epoch_detail = serializer('previous_epoch_detail', self._previous_epoch_detail)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (not self.output):
    new_output = self.outputs[self.output_index]
    if (self.output_index > original_output_index):
        print('Falling back to video output %s', new_output.name())
    self.output = new_output(self.directory, self.frame_shape)
self.output.emit_frame(np_array)
return
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return nt.void.__getattribute__(self, attr)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(ref_features, rank_features) = test_dataset[i]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
traced_gpt2 = torch.jit.trace(model, inputs)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (p_i.shape == arr_i.shape), f'Pointer shape {p_i.shape} and array shape {arr_i.shape} mismatched'
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
data = parse_qs(environ['QUERY_STRING'])['q'][0]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import pyarrow.plasma as plasma
self._plasma = plasma
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
fd = open(file_or_fd, 'r')
fname = file_or_fd
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
array = numpy.reshape(array, pt_weight.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
for epoch in range(num_epochs):
    print('Epoch {}/{}'.format((epoch + 1), num_epochs))
    print(('-' * 10))
    loss_per_batch = []
    for phase in ['train', 'validation']:
        if (phase == 'train'):
            model.train()
        else:
            model.eval()
        running_loss = 0.0
        running_acc = 0.0
        running_class = 0.0
        for (inputs, labels) in dataloaders[phase]:
            batch_size = inputs.size(0)
            inputs = inputs.to(device)
            if isinstance(labels, collections.Sequence):
                if boundary_loss:
                    dists = labels[1].to(device)
                    labels = labels[0].to(device)
                else:
                    labels = (labels[0].to(device), labels[1].to(device))
            else:
                labels = labels.to(device)
            optimizer.zero_grad()
            with torch.set_grad_enabled((phase == 'train')):
                outputs = model(inputs)
                if boundary_loss:
                    loss = criterion(outputs, dists, labels)
                else:
                    loss = criterion(outputs, labels)
                if probs2onehot:
                    mask = probs2one_hot(outputs.detach())
                else:
                    mask = outputs
                if (hasattr(criterion, 'cross_entropy') and criterion.cross_entropy):
                    outputs = ce_output_to_mask(outputs, numpy=False).to(device)
                if classify:
                    (acc, acc_class) = metric(outputs, labels)
                else:
                    acc = metric(mask, labels)
                if (phase == 'train'):
                    loss_per_batch.append(loss)
                    loss.backward()
                    optimizer.step()
            running_loss += (loss.item() * batch_size)
            running_acc += (acc * batch_size)
            if classify:
                running_class += (acc_class * batch_size)
        if (phase == 'train'):
            print('Learning rate step')
            scheduler.step()
        epoch_loss = (running_loss / dataset_sizes[phase])
        epoch_acc = (running_acc / dataset_sizes[phase])
        epoch_class = (running_class / dataset_sizes[phase])
        if (phase == 'train'):
            if boundary_loss:
                criterion.increment_weights()
            train_loss.append(epoch_loss)
            train_acc.append(epoch_acc)
            if classify:
                train_class.append(epoch_class)
            if inepoch_plot:
                plt.title(('Training Loss per batch, EPOCH: ' + str((epoch + 1))))
                plt.xlabel('Batch')
                plt.ylabel(loss_name)
                plt.plot(range(len(loss_per_batch)), loss_per_batch, 'b*-', label='Train')
                plt.show()
        elif (phase == 'validation'):
            val_loss.append(epoch_loss)
            val_acc.append(epoch_acc)
            if classify:
                val_class.append(epoch_class)
        else:
            raise ValueError('WRONG PHASE NAME, check folder names?')
        print(('{} {}: {:.4f} {}: {:.4f} '.format(phase, loss_name, epoch_loss, metric_name, epoch_acc) + (classify * 'Class ACC: {:.4f}'.format(epoch_class))))
        if (phase == 'validation'):
            if ((epoch_acc > best_acc) or (epoch_class > best_acc)):
                if (patience != 0):
                    patience_count = 0
                print('Best model so far, checkpoint...')
                best_acc = (epoch_acc if (epoch_acc > best_acc) else epoch_class)
                torch.save(model.state_dict(), os.path.join(savefolder, (model_name + '.pt')))
                best_model_wts = copy.deepcopy(model.state_dict())
            elif (patience != 0):
                patience_count += 1
                print('Patience {}/{}...'.format(patience_count, patience))
                if (patience_count >= patience):
                    print('{} epochs without improvement, ending training.'.format(patience_count))
                    raise KeyboardInterrupt('Patience interrupt')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
block_placements[blockstr].extend(placement)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
batch2 = self.iterator2.next()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (pointer.shape == array.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
number = int(no_comma_word)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
start_batch_size = args.batch_size
for (m, c) in model_cfgs:
    batch_size = start_batch_size
    args.model = m
    args.checkpoint = c
    result = OrderedDict(model=args.model)
    r = {}
    while ((not r) and (batch_size >= args.num_gpu)):
        torch.cuda.empty_cache()
        try:
            args.batch_size = batch_size
            print(('Validating with batch size: %d' % args.batch_size))
            r = validate(args)
        except RuntimeError as e:
            if (batch_size <= args.num_gpu):
                print('Validation failed with no ability to reduce batch size. Exiting.')
                raise e
            batch_size = max((batch_size // 2), args.num_gpu)
            print('Validation failed, reducing batch size by 50%')
    result.update(r)
    if args.checkpoint:
        result['checkpoint'] = args.checkpoint
    results.append(result)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
end_x = int(kps_1d[end][0])
end_y = int(kps_1d[end][1])
(line_x, line_y) = weighted_line(start_x, start_y, end_x, end_y, rmin=0, rmax=max(kps_2d.shape[1:]))
kps_2d[:, line_y, line_x] = 1
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
iter(size)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
count = int(fields[1])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
target_bboxes_semcls[0:num_bbox] = [DC.nyu40id2class[int(x)] for x in instance_bboxes[:, (- 2)][0:num_bbox]]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
miss_meth = _valid_miss_meth[missing]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import pkuseg
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import apex
apex.amp.register_half_function(torch, 'einsum')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return comm.Get_rank()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import palaas
from .fb_tbmf_wrapper import FbTbmfWrapper
bar = FbTbmfWrapper(bar, log_interval)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
enhance = hyperparameters['enhance']
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
log_interval = max((len(iterator) // 20), 10)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
param_type_matcher.register((alias + '&'), self.ThisClassRefParameter)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
if (('context' in infer_dict) and ('qas' in infer_dict)):
    return infer_dict
questions = infer_dict['questions']
text = infer_dict['text']
uid = infer_dict.get('id', None)
qas = [{'question': q, 'id': uid, 'answers': [], 'answer_type': None} for (i, q) in enumerate(questions)]
converted = {'qas': qas, 'context': text}
return converted
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if ((ours is None) or (theirs is None)):
    different = (ours is not theirs)
else:
    different = bool((ours != theirs))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
pointer = getattr(pointer, scope_names[0])
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
nice = self.__nice__()
classname = self.__class__.__name__
return '<{0}({1}) at {2}>'.format(classname, nice, hex(id(self)))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
height = segm.shape[0]
width = segm.shape[1]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import torch
import tensorflow as tf
from tensorflow.python.keras import backend as K
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(self.box_subclass, box_constructor) = self.box_registry[name]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with open(save_file, 'r') as f:
    last_saved = f.read()
    last_saved = last_saved.strip()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (step is None):
    self.step = (index + 1)
else:
    self.step = as_symbol(step)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
var_file_handle = open(var_file, 'r')
for line in var_file_handle:
    parts = line.split('=')
    field_name = parts[0].strip()
    field_value = parts[1].strip()
    if (field_name in ['model_left_context', 'left_context']):
        variables['model_left_context'] = int(field_value)
    elif (field_name in ['model_right_context', 'right_context']):
        variables['model_right_context'] = int(field_value)
    elif (field_name == 'num_hidden_layers'):
        if (int(field_value) > 1):
            raise Exception('You have num_hidden_layers={0} (real meaning: your config files are intended to do discriminative pretraining).  Since Kaldi 5.2, this is no longer supported --> use newer config-creation scripts, i.e. xconfig_to_configs.py.'.format(field_value))
    else:
        variables[field_name] = field_value
return variables
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
preds = preds.reshape(labels.shape[0], labels.shape[1], labels.shape[2])
scores = scores.reshape(labels.shape[0], labels.shape[1], labels.shape[2])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
os.remove(chkpt_path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
while True:
    self.train_epoch(epoch_idx=epoch)
    epoch += 1
    if (self.iter_num >= config.num_iters):
        break
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
t_xz = batch_data['t_xz'].to(self.device, self.dtype, non_blocking=True)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
npars = pl_module.model.model.num_parameters()
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (not flow.runs_forward()):
    flow.invert()
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
gpu_rank = onmt.utils.distributed.multi_init(opt, device_id)
if (gpu_rank != opt.gpu_ranks[device_id]):
    raise AssertionError('An error occurred in                   Distributed initialization')
single_main(opt, device_id, batch_queue, semaphore)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self._reference_namespace.value = value_namespace
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
import sentencepiece as spm
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
variable = variables['{}_{}'.format(stage, col[:(- 1)])][int(col[(- 1)])]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
array = numpy.reshape(array, symbolic_weight.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import ftfy
from spacy.lang.en import English
_nlp = English()
self.nlp = _nlp.Defaults.create_tokenizer(_nlp)
self.fix_text = ftfy.fix_text
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import multiprocessing
val = multiprocessing.Value('i', 0)
forkcheck = True
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import re
import numpy as np
import tensorflow as tf
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
decoded_token = base64.b64decode(page_token)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
fst_stop_idx = decoded_words.index(STOP_DECODING)
decoded_words = decoded_words[:fst_stop_idx]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
mlflow.log_artifact(f)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
value = int(unparsed_args[(i + 1)])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
cv2.rectangle(img, (list1[0], list1[1]), (list1[2], list1[3]), (0, 255, 0), 1)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if rule(j):
    reads.append(j)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
segments = segmentation_fn(image)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
res = self.create_lambda(np.random.randint(((2 ** 32) - 1)))
assert (type(res) == dclasses.Equation)
return res
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0
"
if (len(val) > 19):
    if (val[19] == '.'):
        if (val[(- 1)].upper() == 'Z'):
            subsecondval = val[20:(- 1)]
            tzval = 'Z'
        else:
            subsecondvalandtz = val[20:]
            if ('+' in subsecondvalandtz):
                splitpoint = subsecondvalandtz.index('+')
                subsecondval = subsecondvalandtz[:splitpoint]
                tzval = subsecondvalandtz[splitpoint:]
            elif ('-' in subsecondvalandtz):
                splitpoint = subsecondvalandtz.index('-')
                subsecondval = subsecondvalandtz[:splitpoint]
                tzval = subsecondvalandtz[splitpoint:]
            else:
                tzval = None
                subsecondval = subsecondvalandtz
        if (tzval is not None):
            tz = TomlTz(tzval)
        microsecond = int((int(subsecondval) * (10 ** (6 - len(subsecondval)))))
    else:
        tz = TomlTz(val[19:])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
module = importlib.import_module(module_name)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
v = quadprog.solve_qp(p, q, G, h)[0]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
ps_font_info_weight = (font.get_ps_font_info()['weight'].replace(' ', '') or '')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
self.book.remove(self.book.worksheets[0])
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import instaboostfast as instaboost
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import re
import numpy as np
import tensorflow as tf
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
query = queries[:, t, :].unsqueeze(1)
(c, att) = self.luong_att(query=query, masks=mask, values=keys)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
batch[k] = batch[k].cuda()
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
setattr(self, key, value)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return self._sentinel
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
nice = self.__nice__()
classname = self.__class__.__name__
return f'<{classname}({nice}) at {hex(id(self))}>'
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return self.labelToIdx[key]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
reduced_loss = self.args.strategy.reduce(tf.distribute.ReduceOp.MEAN, per_replica_loss, axis=0)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
rv = self[key]
self.remove(key)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
checkpoint_suffix = args.model_name_or_path.split('-')[(- 1)].split('/')[0]
global_step = int(checkpoint_suffix)
epochs_trained = (global_step // (len(train_dataloader) // args.gradient_accumulation_steps))
steps_trained_in_current_epoch = (global_step % (len(train_dataloader) // args.gradient_accumulation_steps))
logger.info('  Continuing training from checkpoint, will skip to saved global_step')
logger.info('  Continuing training from epoch %d', epochs_trained)
logger.info('  Continuing training from global step %d', global_step)
logger.info('  Will skip the first %d steps in the first epoch', steps_trained_in_current_epoch)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
import yaml
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from transformers.models.transfo_xl import TransfoXLConfig, TransfoXLLMHeadModel
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
pointer = getattr(pointer, scope_names[0])
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (self.datapoints is None):
    diag_jitter = torch.eye(output_covar.size((- 1)))
else:
    diag_jitter = torch.eye(output_covar.size((- 1)), dtype=self.datapoints.dtype, device=self.datapoints.device)
diag_jitter = diag_jitter.expand(output_covar.shape)
diag_jitter = (diag_jitter * self._jitter)
output_covar = (output_covar + diag_jitter)
post = MultivariateNormal(output_mean, output_covar)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
classname = self.__class__.__name__
nice = self.__nice__()
return f'<{classname}({nice})>'
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from tensorflow.python.summary.writer.event_file_writer import EventFileWriter
from tensorflow.python.summary.writer.event_file_writer_v2 import EventFileWriterV2
from tensorflow.python.saved_model import tag_constants
from tensorflow.python.summary.writer.writer import FileWriter
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
handler = token_handlers[token]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
tokenizer = cls(*init_inputs, **init_kwargs)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_archive_file = cached_path(archive_file, cache_dir=cache_dir, force_download=force_download, proxies=proxies, resume_download=resume_download, local_files_only=local_files_only)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from .convert_transfo_xl_original_tf_checkpoint_to_pytorch import convert_transfo_xl_checkpoint_to_pytorch
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (list(pt_weight.shape) == list(array.shape))
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import matplotlib.pyplot as plt
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from .modeling_tf_pytorch_utils import load_tf2_checkpoint_in_pytorch_model
model = load_tf2_checkpoint_in_pytorch_model(model, resolved_archive_file, allow_missing_keys=True)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex.optimizers import FP16_Optimizer
from apex.optimizers import FusedAdam
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.mkdir(os.path.join(data_folder, 'scaled', ds))
",0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
line = next(self.buffer)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
fd = stream.fileno()
if ((fd == fd_expect) and stream.isatty()):
    os.close(fd)
    os.dup2(fd_null, fd)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
shutil.copy(file_path, dest_folder)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (pointer.shape == array.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (p_i.shape == arr_i.shape), f'Pointer shape {p_i.shape} and array shape {arr_i.shape} mismatched'
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import wget
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import tensorflow as tf
import torch
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
print(((('Downloading ' + url) + ' to ') + file_path))
urllib.request.urlretrieve(url, file_path, reporthook=gen_bar_updater())
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import cityscapesscripts.helpers.labels as CSLabels
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
array = numpy.reshape(array, symbolic_weight.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
promoted_dt_highres = np.dtype(promoted_dt_highres)
return promoted_dt_highres
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
import instaboostfast as instaboost
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_archive_file = cached_path(archive_file, cache_dir=cache_dir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return len(next(iter(self.Y_dict.values())))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self[name] = toklist[0]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
for diff_type in ['Parameter differences', 'Relative parameter differences']:
    iter_stats.append(np.array(sorted(stats_per_dir[dir][diff_type]['progress_per_component'][component_name].items())))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with open(config_file) as f:
    return json.load(f)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.tryParse(instring, loc)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return bool(eval(x))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
return '{:.2f}'.format(math.pow(2, loss))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
for _ in range(replabel_idx_to_value[token]):
    result.append(prev_token)
prev_token = (- 1)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_archive_file = cached_path(archive_file, cache_dir=cache_dir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (list(pt_weight.shape) == list(array.shape))
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import apex
apex.amp.register_half_function(torch, 'einsum')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
ws.RunNetOnce(predict_net)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(pfxes, root, sfxes) = self.segment(form)
if (mode == 'roots'):
    return root
if (mode == 'bundles'):
    return (''.join(((p + '_') for p in pfxes)), root, ''.join((('_' + s) for s in sfxes)))
if (mode == 'morphemes'):
    return (pfxes, root, sfxes)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
from apex.parallel import DistributedDataParallel as DDP
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import sentencepiece as spm
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
arr.remove('[')
arr.remove(']')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
assert (pointer.shape == array.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
settings = ac.settings()
settings.parse_settings('settings.cfg')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return datetime.strptime(t[0], fmt).date()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
assert (pointer.shape == array.shape), f'Pointer shape {pointer.shape} and array shape {array.shape} mismatched'
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
prev_count = type_counts[img_type]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
spl = len(self.paths[start_node][node])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from spacy.lang.en import English
spacy_nlp._nlp = English()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
data[key] = np.array([float(x) for x in value.split()])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
assert chainer.backends.cuda.available
logging.info('--> cuda is available in chainer.')
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (model.tokens_embed.weight.shape == init_params[1].shape)
assert (model.positions_embed.weight.shape == init_params[0].shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
iter(size)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
with PathManager.open(f, 'r', encoding='utf-8') as fd:
    self.add_from_file(fd)
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return [self.word2index[token.text] for token in self.tokenize(sentence)]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import numpy as np
import tensorflow as tf
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
datapoint_pos = torch.FloatTensor(list(map((lambda x: embeddings.loc[x]), pos)))
datapoint_neg = torch.FloatTensor(list(map((lambda x: embeddings.loc[x]), neg)))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.num_encoders = int(config['num_encoders'])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
logging.info(subprocess.check_output(['nvidia-smi']).decode('utf-8'))
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
gameid = os.listdir(f'{TRACKING_DIR}/{game_name}')[0].split('.')[0]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (lineno is not None):
    py3nvml.nvmlInit()
    handle = py3nvml.nvmlDeviceGetHandleByIndex(int(os.environ['GPU_DEBUG']))
    meminfo = py3nvml.nvmlDeviceGetMemoryInfo(handle)
    line = linecache.getline(filename, lineno)
    where_str = ((((module_name + ' ') + func_name) + ':') + str(lineno))
    new_meminfo_used = meminfo.used
    mem_display = ((new_meminfo_used - last_meminfo_used) if use_incremental else new_meminfo_used)
    if ((abs((new_meminfo_used - last_meminfo_used)) / (1024 ** 2)) > 256):
        with open(gpu_profile_fn, 'a+') as f:
            f.write(f'''{where_str:<50}:{(mem_display / (1024 ** 2)):<7.1f}Mb {line.rstrip()}
''')
            last_meminfo_used = new_meminfo_used
            if (print_tensor_sizes is True):
                for tensor in get_tensors():
                    if (not hasattr(tensor, 'dbg_alloc_where')):
                        tensor.dbg_alloc_where = where_str
                new_tensor_sizes = {(type(x), tuple(x.size()), x.dbg_alloc_where) for x in get_tensors()}
                for (t, s, loc) in (new_tensor_sizes - last_tensor_sizes):
                    f.write(f'''+ {loc:<50} {str(s):<20} {str(t):<10}
''')
                for (t, s, loc) in (last_tensor_sizes - new_tensor_sizes):
                    f.write(f'''- {loc:<50} {str(s):<20} {str(t):<10}
''')
                last_tensor_sizes = new_tensor_sizes
    py3nvml.nvmlShutdown()
lineno = None
func_name = frame.f_code.co_name
filename = frame.f_globals['__file__']
if (filename.endswith('.pyc') or filename.endswith('.pyo')):
    filename = filename[:(- 1)]
module_name = frame.f_globals['__name__']
lineno = frame.f_lineno
if ('maua-stylegan2' not in os.path.dirname(os.path.abspath(filename))):
    lineno = None
if (('car_datasets' in filename) or ('_exec_config' in func_name) or ('gpu_profile' in module_name) or ('tee_stdout' in module_name) or ('PIL' in module_name)):
    lineno = None
return gpu_profile
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(_loss, sample_size, logging_output) = self.task.valid_step(sample, self.model, self.criterion)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
text_a = line[3]
text_b = line[4]
label = line[5]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_archive_file = cached_path(archive_file, cache_dir=None)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
d[seqn]['lymphocytes'] = float(line[326:328])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
clip.write_gif(filename, verbose=False, logger=None)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
num_lines = 0
for line in lines[2:]:
    num_lines += 1
    line = line.strip().split()
    if ((len(line) != 4) and (len(line) != 7)):
        raise InputError(f'Corrupted data at line {(num_lines + 3)} of file ""{filename}"".')
    if has_forces:
        (symbol, x, y, z, fx, fy, fz) = line
        species.append(symbol.lower().capitalize())
        coords.append([float(x), float(y), float(z)])
        forces.append([float(fx), float(fy), float(fz)])
    else:
        (symbol, x, y, z) = line
        species.append(symbol.lower().capitalize())
        coords.append([float(x), float(y), float(z)])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
import instaboostfast as instaboost
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
shutil.copy2(file_path, task_directory_path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_vocab_files = {}
for (file_id, file_path) in vocab_files.items():
    if (file_path is None):
        resolved_vocab_files[file_id] = None
    else:
        resolved_vocab_files[file_id] = cached_path(file_path, cache_dir=cache_dir, force_download=force_download, proxies=proxies, resume_download=resume_download, local_files_only=local_files_only)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return (self.P2w[((prev + NGRAM_SEP) + word)] / float(self.Pw[prev]))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
response = requests.head(url, allow_redirects=True)
if (response.status_code != 200):
    etag = None
else:
    etag = response.headers.get('ETag')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return self.etoi[entity]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
unsupervised_data = np.load(os.path.join(dataset_path, ((emb_path + str(fold)) + '.npy')))
if transpose:
    unsupervised_data = unsupervised_data.transpose()
feat_emb_val = unsupervised_data.astype('float32')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
lens = [(0 if x.is_empty(recurse=True) else len(x)) for x in batches]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
resolved_vocab_file = cached_path(vocab_file, cache_dir=cache_dir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
PathManager.mkdirs(cache_path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
iter(size)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
callable_ = (fn if hasattr(fn, '__name__') else fn.__call__)
inspect.getcallargs(callable_, self, *args, **kwargs)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
os.chown(h.baseFilename, self.cfg.user, self.cfg.group)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
ret = func(*args[limit[0]:])
foundArity[0] = True
return ret
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
checkpoint_suffix = args.model_name_or_path.split('-')[(- 1)].split('/')[0]
global_step = int(checkpoint_suffix)
epochs_trained = (global_step // (len(train_dataloader) // args.gradient_accumulation_steps))
steps_trained_in_current_epoch = (global_step % (len(train_dataloader) // args.gradient_accumulation_steps))
logger.info('  Continuing training from checkpoint, will skip to saved global_step')
logger.info('  Continuing training from epoch %d', epochs_trained)
logger.info('  Continuing training from global step %d', global_step)
logger.info('  Will skip the first %d steps in the first epoch', steps_trained_in_current_epoch)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
this_video_metrics = [roc_auc_score(sample_y, sample_oc), roc_auc_score(sample_y, sample_rc), roc_auc_score(sample_y, sample_as)]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
assert (p_i.shape == arr_i.shape), f'Pointer shape {p_i.shape} and array shape {arr_i.shape} mismatched'
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from fairseq.data.token_block_utils_fast import _get_slice_indices_fast, _get_block_to_dataset_index_fast
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(r, c) = self._closest_food(obs, self.level)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
old = getattr(roi_heads, attr)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(covariance_, precision_) = graphical_lasso(emp_cov, alpha=alpha, cov_init=covariance_, mode=mode, tol=tol, enet_tol=enet_tol, max_iter=max_iter, verbose=inner_verbose)
covariances_.append(covariance_)
precisions_.append(precision_)
if (X_test is not None):
    this_score = log_likelihood(test_emp_cov, precision_)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(save_folder)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_feature_extractor_file = cached_path(feature_extractor_file, cache_dir=cache_dir, force_download=force_download, proxies=proxies, resume_download=resume_download, local_files_only=local_files_only, use_auth_token=use_auth_token, user_agent=user_agent)
with open(resolved_feature_extractor_file, 'r', encoding='utf-8') as reader:
    text = reader.read()
feature_extractor_dict = json.loads(text)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
tb_writer.add_scalar(key, value, global_step)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return _np.fromfile(stream, self.dtype(byte_order), 1)[0]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
fig.canvas._draw()
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert ('loss' in output_dict)
regularization_penalty = self.model.get_regularization_penalty()
if (regularization_penalty is not None):
    output_dict['reg_loss'] = regularization_penalty
    output_dict['loss'] += regularization_penalty
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
data = next(self.dataset_iter)
if (data['label'].shape[0] < self.opt.batch_size):
    raise StopIteration
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from django.core.management import execute_from_command_line
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return unichr(2018)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return float(value)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
from allennlp.modules.token_embedders.bidirectional_language_model_token_embedder import BidirectionalLanguageModelTokenEmbedder
from allennlp.data.token_indexers.elmo_indexer import ELMoTokenCharactersIndexer
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if ('jieba' not in sys.modules):
    import jieba
else:
    jieba = sys.modules['jieba']
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
batch = next(self._train_iterator)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
loss += optimizer.target(chainer.Variable(cropped_face), chainer.Variable(bbox), chainer.Variable(label))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
get_ipython = sys.modules['IPython'].get_ipython
if ('IPKernelApp' not in get_ipython().config):
    raise ImportError('console')
if ('VSCODE_PID' in os.environ):
    raise ImportError('vscode')
return (importlib.util.find_spec('IPython') is not None)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from netrc import netrc, NetrcParseError
netrc_path = None
for f in NETRC_FILES:
    try:
        loc = os.path.expanduser('~/{}'.format(f))
    except KeyError:
        return
    if os.path.exists(loc):
        netrc_path = loc
        break
if (netrc_path is None):
    return
ri = urlparse(url)
splitstr = b':'
if isinstance(url, str):
    splitstr = splitstr.decode('ascii')
host = ri.netloc.split(splitstr)[0]
try:
    _netrc = netrc(netrc_path).authenticators(host)
    if _netrc:
        login_i = (0 if _netrc[0] else 1)
        return (_netrc[login_i], _netrc[2])
except (NetrcParseError, IOError):
    if raise_errors:
        raise
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(cache_root)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
item = self.load_item_raindrop(index)
self.backup_item = item
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0
"
nlp = spacy_nlp()
spacy_tokenizer._tokenizer = nlp.Defaults.create_tokenizer(nlp)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
text = unicode(text, 'utf-8')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
iter_time = storage.history('time').global_avg()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (proxy_ca_bundle is not None):
    context.load_verify_locations(cafile=proxy_ca_bundle)
if isinstance(proxy_cert, tuple):
    context.load_cert_chain(proxy_cert[0], keyfile=proxy_cert[1])
elif isinstance(proxy_cert, str):
    context.load_cert_chain(proxy_cert)
return context
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self._remaining_times_toshow = reps.astype(int)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
with open(f, 'r', encoding='utf-8') as fd:
    self.add_from_file(fd)
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return self._python_agg_general(func, *args, engine=engine, engine_kwargs=engine_kwargs, **kwargs)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
frontend_contents = os.listdir(os.path.join(task_directory_path, 'frontend'))
if ('package.json' in frontend_contents):
    self.task_files_to_copy['needs_build'] = os.path.join(task_directory_path, 'frontend')
for dir in frontend_contents:
    if (dir in self.task_files_to_copy):
        for file_name in os.listdir(os.path.join(task_directory_path, 'frontend', dir)):
            self.task_files_to_copy[dir].append(os.path.join(task_directory_path, 'frontend', dir, file_name))
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (pointer.shape == array.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.faiss_index = faiss.index_cpu_to_gpu(faiss.StandardGpuResources(), 0, self.faiss_index)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
like_gpu_tensor = ((x.device.type == 'cuda') and hasattr(x, 'to'))
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
tokenizer = cls(*init_inputs, **init_kwargs)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert PathManager.exists(os.path.join(folder, 'data', file)), f""{file} doesn't exist in {folder}""
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
processor = processors[data_args.task_name]()
label_list = processor.get_labels()
num_labels = len(label_list)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
decoded = self.decode_generated_act_resp(generated)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
resolved_corpus_file = cached_path(corpus_file, cache_dir=cache_dir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
matcher = self._scheme.matcher(('%s (%s)' % (name, version)))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
(ls_x, ls_y) = visible['left_shoulder']
(rs_x, rs_y) = visible['right_shoulder']
(mid_shoulder_x, mid_shoulder_y) = (((ls_x + rs_x) / 2), ((ls_y + rs_y) / 2))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex.parallel import DistributedDataParallel as DDP
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
tf_cuda_available = tf.test.is_gpu_available()
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
my_module = load_task_module(opt['task'])
task_agents = my_module.create_agents(opt)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from .convert_gpt2_original_tf_checkpoint_to_pytorch import convert_gpt2_checkpoint_to_pytorch
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return '{:.2f}'.format(math.pow(2, loss))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import pydot
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
param_norm = float(torch.norm(p, norm_type, dtype=torch.float32))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
return Pickler.dump(self, obj)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (eq.get('type', None) == 'display'):
    if eq.get('id', None):
        ref_id = eq.get('id').replace('uid', 'EQREF')
        try:
            mathml = latex2mathml.converter.convert(eq.texmath.text.strip())
        except Exception:
            mathml = ''
        equation_map[ref_id] = {'num': eq.get('id-text', None), 'text': eq.math.text.strip(), 'mathml': mathml, 'latex': eq.texmath.text.strip(), 'ref_id': ref_id}
    replace_item = sp.new_tag('p')
    equation_copy = copy.copy(eq)
    equation_copy['type'] = 'inline'
    replace_item.insert(0, equation_copy)
    eq.replace_with(replace_item)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (pointer.shape == array.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
cpu_sum = float(x.float().sum())
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_archive_file = cached_path(archive_file, cache_dir=cache_dir, force_download=force_download, proxies=proxies)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from scipy.sparse import issparse as _is_scipy_sparse
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self._shape_tuple = tuple(self.shape.as_list())
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
model_dict = model.module.state_dict()
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
global_step = int(args.model_name_or_path.split('-')[(- 1)].split('/')[0])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
import sentencepiece as spm
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
del self.entries[(blob.path, stage)]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from sacremoses import MosesTokenizer, MosesDetokenizer
self.tok = MosesTokenizer(args.moses_source_lang)
self.detok = MosesDetokenizer(args.moses_target_lang)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
fp.seek(0)
lut = paletteHandler(fp).getpalette()
if lut:
    break
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0
"
ppppp_indx = self.att_manager.inputDict[ppppp]['values'].index(p_val)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
node_attribute_outputs = self._node_attribute_predict(decoding_outputs['rnn_outputs'][:, :(- 1), :], inputs['node_attribute_truth'], inputs['node_attribute_mask'])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
text_a = line[q1_index]
text_b = line[q2_index]
label = (None if test_mode else line[5])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
outcome = json.loads(outcome)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
metrics_epoch[metric] = np.average(metrics_epoch[metric], weights=record_weights_tp)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1
"
global_step = int(args.model_name_or_path.split('-')[(- 1)].split('/')[0])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
ret = model.load_state_dict(torch.load(weights_path), strict=False)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
for parse in parser.parse([word_L, word_R]):
    (token, _) = parse.label()
    (category, semantics) = (token.categ(), token.semantics())
    memory_key = ((str(category) + '_') + str(semantics))
    if (memory_key not in memory):
        memory.append(memory_key)
        word_index += 1
        form.append((parse, category, semantics, word_index))
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0
"
batch = next(dataset)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
shape_iter = iter(args[0])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
print('Making', os.path.join(self.root, self.raw_folder))
os.makedirs(os.path.join(self.root, self.raw_folder))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
img = Image.open(img_path).convert('RGB')
got_img = True
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.saved_score = _roc_auc_score(self.golds, self.cands)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
print(((('Downloading ' + url) + ' to ') + fpath))
urllib.request.urlretrieve(url, fpath, reporthook=gen_bar_updater())
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(args.log_dir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
iter(data[0])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
from mmdet.version import __version__
sha = __version__.split('+')[(- 1)]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
ev0 = theano.gof.op.get_test_value(eval_points[0])
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return self.binops[(nargs, op)]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
checkpoint_suffix = args.model_name_or_path.split('-')[(- 1)].split('/')[0]
global_step = int(checkpoint_suffix)
epochs_trained = (global_step // (len(train_dataloader) // args.gradient_accumulation_steps))
steps_trained_in_current_epoch = (global_step % (len(train_dataloader) // args.gradient_accumulation_steps))
logger.info('  Continuing training from checkpoint, will skip to saved global_step')
logger.info('  Continuing training from epoch %d', epochs_trained)
logger.info('  Continuing training from global step %d', global_step)
logger.info('  Will skip the first %d steps in the first epoch', steps_trained_in_current_epoch)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
os.makedirs(dirname)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
logger.debug('Importing %s', plugin)
__import__(f'PIL.{plugin}', globals(), locals(), [])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
na = len(axes_a)
axes_a = list(axes_a)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
return [self.protocol_parser[x] for x in filenames]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import sentencepiece as spm
self.sp = spm.SentencePieceProcessor()
self.sp.Load(vocab)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return (self.__fp.fp is None)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
torch.save(data, filename, _use_new_zipfile_serialization=False, pickle_protocol=3)
logger.info('Saved pretrained vocab and vectors to {}'.format(filename))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0
"
self.optimizer.load_state_dict(checkpoint['optimizer'])
if self.with_cuda:
    for state in self.optimizer.state.values():
        for (k, v) in state.items():
            if isinstance(v, torch.Tensor):
                state[k] = v.cuda(self.gpu)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
if match.group(2):
    number = int(entity_body, 16)
else:
    number = int(entity_body, 10)
if (128 <= number <= 159):
    return bytes((number,)).decode('cp1252')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
if generate_random_embeddings:
    emb_query = np.random.normal(0, 0.67, 200)
else:
    emb_query = embeddings[pid]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return '{:.2f}'.format(math.pow(2, loss))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
batch_outputs[key] = tf.constant(value)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
return cyrillic_letters[uchr]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
sock.bind((host, port))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.remove(fname)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
loss = output_dict['loss']
if for_training:
    loss += self.model.get_regularization_penalty()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
existing = self[binding.variable]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
dsplit(a, 2)
assert_(0)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
resolved_archive_file = cached_path(archive_file, cache_dir=None)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.fd = os.open(self.filename, self.flags)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
task = model.get()
num_task -= 1
(yield task)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
cls_name = '.'.join((cls.__module__, cls.__name__))
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
element = lines.popleft()
if element.startswith('@highlight'):
    break
story_lines.append(element)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_archive_file = cached_path(archive_file, cache_dir=cache_dir, force_download=force_download, proxies=proxies)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
_text.encode('us-ascii')
_charset = 'us-ascii'
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0
"
pointer = getattr(pointer, l[0])
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
shell = get_ipython().__class__.__name__
if (shell == 'ZMQInteractiveShell'):
    return True
elif (shell == 'TerminalInteractiveShell'):
    return False
else:
    return False
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
s.bind(('127.0.0.1', port))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
kinds = [include_kind[i] for i in util.to_list(include)]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
AddConfigVar('T_config.test_invalid_default_a', doc='unittest', configparam=ConfigParam('invalid', filter=filter), in_c_key=False)
assert False
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
pointer = getattr(pointer, scope_names[0])
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from mmdet.version import __version__
sha = __version__.split('+')[(- 1)]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with open(parent_path, 'r') as f:
    d_parent = json.load(f)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return super(VisDiagnoser, self).__getattr__(item)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
random_idxs = np.random.choice(size, downsample_size, replace=replace)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
import cv2
data.append(('cv2', cv2.__version__))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
nlp = spacy_nlp()
spacy_tokenizer._tokenizer = nlp.Defaults.create_tokenizer(nlp)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_archive_file = cached_path(archive_file, cache_dir=cache_dir, force_download=force_download, proxies=proxies, resume_download=resume_download, local_files_only=local_files_only)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with open(PathManager.get_local_path(f), 'r', encoding='utf-8') as fd:
    self.add_from_file(fd)
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
next_index = indexes[(i + 1)]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
nonlinearity = {'RNN_TANH': 'tanh', 'RNN_RELU': 'relu'}[rnn_type]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(yield iterator.__next__())
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
env = gym.make(env_config['id'])
env.import_module = env_config.get('import_module', None)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return datetime.strptime(t[0], fmt).date()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
frames = video.transpose((1, 2, 0, 3, 4)).reshape((T, H, (B * W), C))
summary = tf1.Summary()
image = tf1.Summary.Image(height=(B * H), width=(T * W), colorspace=C)
image.encoded_image_string = encode_gif(frames, fps)
summary.value.add(tag=(name + '/gif'), image=image)
tf.summary.experimental.write_raw_pb(summary.SerializeToString(), step)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import tensorflow as tf
import torch
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
args = munch.munchify(ckpt['args'])
pipeline = get_module(args.pipeline)()
pipeline.create(args)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import numpy as np
import tensorflow as tf
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(self.next_input, self.next_target) = next(self.loader)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with torch.no_grad():
    if use_predicted_queries:
        example_preds = model.predict_with_predicted_queries(interaction, max_generation_length)
    else:
        example_preds = model.predict_with_gold_queries(interaction, max_generation_length, feed_gold_query=gold_forcing)
    torch.cuda.empty_cache()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_embedding_file = cached_path(embedding_file, cache_dir=cache_dir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.sent_tok = nltk.data.load(st_path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import apex
apex.amp.register_half_function(torch, 'einsum')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
load_params = torch.load(pretrained_path, map_location=torch.device(device))
online_network.load_state_dict(load_params['online_network_state_dict'])
online_network.load_state_dict(load_params)
log.info('Load from {}.'.format(pretrained_path))
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
dates.append(datetime(int(year_match), MONTH_NUMBERS[month], DAY_NUMBERS[day]))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
(line, field) = line.rstrip().rsplit(' ', 1)
if (field == '#fairseq:overwrite'):
    overwrite = True
    (line, field) = line.rsplit(' ', 1)
else:
    overwrite = False
count = int(field)
word = line
if ((word in self) and (not overwrite)):
    raise RuntimeError(""Duplicate word found when loading Dictionary: '{}'. Duplicate words can overwrite earlier ones by adding the #fairseq:overwrite flag at the end of the corresponding row in the dictionary file. If using the Camembert model, please download an updated copy of the model file."".format(word))
self.add_symbol(word, n=count, overwrite=overwrite)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
os.makedirs(dirpath)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if re.search('^(ark|scp)(,scp|,b|,t|,n?f|,n?p|,b?o|,n?s|,n?cs)*:', file):
    (prefix, file) = file.split(':', 1)
if re.search(':[0-9]+$', file):
    (file, offset) = file.rsplit(':', 1)
if (file[(- 1)] == '|'):
    fd = popen(file[:(- 1)], 'rb')
elif (file[0] == '|'):
    fd = popen(file[1:], 'wb')
elif (file.split('.')[(- 1)] == 'gz'):
    fd = gzip.open(file, mode)
else:
    fd = open(file, mode)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
from apex import amp
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
self.sock.setblocking(1)
self.sock.connect(server_address)
logger.log(msg='Conneted to server at: {}'.format(server_address), level=15)
break
",0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.ignore_index = tuple(ignore_index)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
import sentencepiece as spm
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(yield (k, (ranks1[k] - ranks2[k])))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
Y = model.intermediate_fms['output_fms'][layer_name]
X = model.intermediate_fms['input_fms'][layer_name]
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return next(self.parameters()).dtype
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
best_eval_measures_higher_better = checkpoint['best_eval_measures_higher_better'].cpu()
best_eval_measures_lower_better = checkpoint['best_eval_measures_lower_better'].cpu()
best_eval_steps = checkpoint['best_eval_steps']
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
pointer = getattr(pointer, scope_names[0])
pt_name.append(f'{scope_names[0]}')
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return safe_round((base ** loss), round)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import accimage
return accimage.Image(path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import numpy as np
import tensorflow.compat.v1 as tf
import tensorflow_hub as hub
import tensorflow_text
tf.disable_eager_execution()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (index in SPECIAL_CODEPOINTS):
    return SPECIAL_CODEPOINTS[index]
return chr(index)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
out = _minimal_ext_cmd(['git', 'rev-parse', 'HEAD'])
sha = out.strip().decode('ascii')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_archive_file = cached_path(archive_file, cache_dir=cache_dir, force_download=force_download, proxies=proxies, resume_download=resume_download)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import instaboostfast as instaboost
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
cocoDt = cocoGt.loadRes(result_files[res_type])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return sysconfig.get_config_var(var)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
for i in range(len(split1)):
    indexes = [int(x) for x in split1[i].strip().lstrip('[').rstrip(']').strip().split(',')]
    if (len(indexes) < 1):
        raise ValueError(('invalid --lstm-delay argument, too-short element: ' + lstm_delay))
    elif ((len(indexes) == 2) and ((indexes[0] * indexes[1]) >= 0)):
        raise ValueError('Warning: {} is not a standard BLSTM mode. There should be a negative delay for the forward, and a postive delay for the backward.'.format(indexes))
    if ((len(indexes) == 2) and (indexes[0] > 0)):
        (indexes[0], indexes[1]) = (indexes[1], indexes[0])
    lstm_delay_array.append(indexes)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
(_loss, sample_size, logging_output) = self.task.valid_step(sample, self.model, self.criterion)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if args.log_norm:
    for p in getattr(model, 'module', model).parameters():
        param_norm = p.grad.data.norm(2)
        total_norm += (param_norm.item() ** 2)
    total_norm = (total_norm ** (1.0 / 2))
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
opt_path = os.path.join(gp_run_folder, f'gp_opt_res{gp_iter:04d}.npy')
log_path = os.path.join(gp_run_folder, f'gp_opt_{gp_iter:04d}.log')
gp_opt_command = ['python', GP_OPT_FILE, f'--seed={iter_seed}', f'--gp_file={str(curr_gp_file)}', f'--data_file={str(gp_data_file)}', f'--save_file={str(opt_path)}', f'--n_out={1}', f'--logfile={str(log_path)}']
if error_aware_acquisition:
    gp_opt_command += [f'--gp_err_file={str(curr_gp_err_file)}', f'--data_err_file={str(gp_err_data_file)}']
if (pbar is not None):
    pbar.set_description('optimizing acq func')
print_flush('Start running gp_opt_command')
_run_command(gp_opt_command, f'GP opt {gp_iter}')
z_opt = np.load(opt_path)
(smiles_opt, prop_opt) = _batch_decode_z_and_props(model, torch.as_tensor(z_opt, device=model.device), datamodule, invalid_score=invalid_score, pbar=pbar)
good = True
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (self.config.mode == 'test'):
    print('-------test------------')
    start = time.time()
    self.test('test')
    self.time_record = (time.time() - start)
else:
    self.train()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex import amp
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
out = _minimal_ext_cmd(['git', 'rev-parse', 'HEAD'])
sha = out.strip().decode('ascii')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
attr = object.__getattr__(name)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(minima,) = np.where((sum_path_len == np.min(sum_path_len)))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
src_dict = getattr(task, 'source_dictionary', None)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import cityscapesscripts.evaluation.evalInstanceLevelSemanticLabeling as CSEval
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
iter(size)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
n = operator.index(n)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
num_labels = glue_tasks_num_labels[('mnli' if (data_args.task_name == 'mnli-mm') else data_args.task_name)]
output_mode = glue_output_modes[data_args.task_name]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
ax.set_yscale('log')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
output = kwargs['output']
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
predictions_for_q = predictions[question_id]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_archive_file = cached_path(archive_file, cache_dir=cache_dir)
resolved_config_file = cached_path(config_file, cache_dir=cache_dir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
matplotlibrc = os.environ['MATPLOTLIBRC']
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return super(SafeFileCache, self).delete(*args, **kwargs)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
npars = pl_module.model.model.num_parameters()
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
task.load_dataset(split_k, combine=False)
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.writer.add_histogram('action_batch_distribution_overall', torch.Tensor(action_batch_distribution_overall), (total_train_time + _))
self.writer.add_histogram('action_batch_distribution_solved', torch.Tensor(action_batch_distribution_solved), (total_train_time + _))
self.writer.add_histogram('action_batch_distribution_not_solved', torch.Tensor(action_batch_distribution_notsolved), (total_train_time + _))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
model_pointer = getattr(model_pointer, sub_layer)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if ('pythainlp' not in sys.modules):
    from pythainlp.tokenize import word_tokenize as th_word_tokenize
else:
    th_word_tokenize = sys.modules['pythainlp'].word_tokenize
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
start_p = abstract.index(config.SENTENCE_START, cur)
end_p = abstract.index(config.SENTENCE_END, (start_p + 1))
cur = (end_p + len(config.SENTENCE_END))
sents.append(abstract[(start_p + len(config.SENTENCE_START)):end_p])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
import re
import numpy as np
import tensorflow as tf
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (model.tokens_embed.weight.shape == init_params[1].shape)
assert (model.positions_embed.weight.shape == init_params[0].shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex import amp
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
for _ in range(self.chunk_size):
    chunk.append(next(self.itr))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (value <= 0):
    raise ValueError(('Attempted to set %s timeout to %s, but the timeout cannot be set to a value less than or equal to 0.' % (name, value)))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
wg_name = wg.attrib['name']
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
colors = [random_color(rgb=True, maximum=1) for k in category_ids]
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if model.config.is_encoder_decoder:
    model.config.use_cache = False
    input_ids = inputs['input_ids']
    decoder_attention_mask = inputs['decoder_attention_mask']
    labels = inputs.get('labels', None)
    input_names = ['input_ids', 'attention_mask', 'decoder_input_ids', 'decoder_attention_mask']
    if (labels is not None):
        input_names.append('labels')
    filtered_inputs = {k: v for (k, v) in inputs.items() if (k in input_names)}
    model_output = model(**filtered_inputs)
    batch_size = input_ids.shape[0]
    encoder_sequence_length = input_ids.shape[1]
    decoder_sequence_length = decoder_attention_mask.shape[1]
    traced_model = symbolic_trace(model, input_names, batch_size=batch_size, sequence_length=[encoder_sequence_length, decoder_sequence_length])
    traced_output = traced_model(**filtered_inputs)
else:
    input_names = ['input_ids', 'attention_mask', 'token_type_ids']
    input_ids = inputs['input_ids']
    labels = inputs.get('labels', None)
    start_positions = inputs.get('start_positions', None)
    end_positions = inputs.get('end_positions', None)
    if (labels is not None):
        input_names.append('labels')
    if (start_positions is not None):
        input_names.append('start_positions')
    if (end_positions is not None):
        input_names.append('end_positions')
    filtered_inputs = {k: v for (k, v) in inputs.items() if (k in input_names)}
    input_names = filtered_inputs.keys()
    model_output = model(**filtered_inputs)
    rank = len(input_ids.shape)
    if (rank == 2):
        (batch_size, sequence_length) = input_ids.shape
        num_choices = (- 1)
    elif (rank == 3):
        (batch_size, num_choices, sequence_length) = input_ids.shape
    else:
        raise NotImplementedError(f'symbolic_trace automatic parameters inference not implemented for input of rank {rank}.')
    traced_model = symbolic_trace(model, input_names, batch_size=batch_size, sequence_length=sequence_length, num_choices=num_choices)
    traced_output = traced_model(**filtered_inputs)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
mask = np.array(Image.open(map_path))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from fairscale.nn import Pipe
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.translator = build_translator(self.opt, report_score=False, out_file=open(os.devnull, 'w'))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
value = os.environ[key]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import psutil
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.__dict__[k] = _to_array_with_correct_type(np.stack(v, axis))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
trainer.train_step(raw_batch)
trainer.iter()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
to_return.id = self.data_id
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.optimizer.load_state_dict(states['optimizer'])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
nlp = spacy_nlp()
spacy_tokenizer._tokenizer = nlp.Defaults.create_tokenizer(nlp)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from tensorboardX import SummaryWriter
self.SummaryWriter = SummaryWriter
self._writers = {}
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.model.load_state_dict(states['model'])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
while True:
    if epoch_done:
        if ((not opt.noamopt) and (not opt.reduce_on_plateau)):
            if ((epoch > opt.learning_rate_decay_start) and (opt.learning_rate_decay_start >= 0)):
                frac = ((epoch - opt.learning_rate_decay_start) // opt.learning_rate_decay_every)
                decay_factor = (opt.learning_rate_decay_rate ** frac)
                opt.current_lr = (opt.learning_rate * decay_factor)
            else:
                opt.current_lr = opt.learning_rate
            utils.set_lr(optimizer, opt.current_lr)
        if ((epoch > opt.scheduled_sampling_start) and (opt.scheduled_sampling_start >= 0)):
            frac = ((epoch - opt.scheduled_sampling_start) // opt.scheduled_sampling_increase_every)
            opt.ss_prob = min((opt.scheduled_sampling_increase_prob * frac), opt.scheduled_sampling_max_prob)
            model.ss_prob = opt.ss_prob
        if ((opt.self_critical_after != (- 1)) and (epoch >= opt.self_critical_after)):
            sc_flag = True
            init_scorer(opt.cached_tokens)
        else:
            sc_flag = False
        epoch_done = False
    start = time.time()
    if ((opt.use_warmup == 1) and (iteration < opt.noamopt_warmup)):
        opt.current_lr = ((opt.learning_rate * (iteration + 1)) / opt.noamopt_warmup)
        utils.set_lr(optimizer, opt.current_lr)
    data = loader.get_batch('train')
    print('Read data:', (time.time() - start))
    if ((iteration % acc_steps) == 0):
        optimizer.zero_grad()
    torch.cuda.synchronize()
    start = time.time()
    tmp = [data['fc_feats'], data['att_feats'], data['labels'], data['masks'], data['att_masks']]
    tmp = [(_ if (_ is None) else _.cuda()) for _ in tmp]
    (fc_feats, att_feats, labels, masks, att_masks) = tmp
    model_out = dp_lw_model(fc_feats, att_feats, labels, masks, att_masks, data['gts'], torch.arange(0, len(data['gts'])), sc_flag)
    loss = model_out['loss'].mean()
    loss_sp = (loss / acc_steps)
    loss_sp.backward()
    if (((iteration + 1) % acc_steps) == 0):
        utils.clip_gradient(optimizer, opt.grad_clip)
        optimizer.step()
    torch.cuda.synchronize()
    train_loss = loss.item()
    end = time.time()
    if (not sc_flag):
        print('iter {} (epoch {}), train_loss = {:.3f}, time/batch = {:.3f}'.format(iteration, epoch, train_loss, (end - start)))
    else:
        print('iter {} (epoch {}), avg_reward = {:.3f}, time/batch = {:.3f}'.format(iteration, epoch, model_out['reward'].mean(), (end - start)))
    iteration += 1
    if data['bounds']['wrapped']:
        epoch += 1
        epoch_done = True
    if ((iteration % opt.losses_log_every) == 0):
        add_summary_value(tb_summary_writer, 'train_loss', train_loss, iteration)
        if opt.noamopt:
            opt.current_lr = optimizer.rate()
        elif opt.reduce_on_plateau:
            opt.current_lr = optimizer.current_lr
        add_summary_value(tb_summary_writer, 'learning_rate', opt.current_lr, iteration)
        add_summary_value(tb_summary_writer, 'scheduled_sampling_prob', model.ss_prob, iteration)
        if sc_flag:
            add_summary_value(tb_summary_writer, 'avg_reward', model_out['reward'].mean(), iteration)
        loss_history[iteration] = (train_loss if (not sc_flag) else model_out['reward'].mean())
        lr_history[iteration] = opt.current_lr
        ss_prob_history[iteration] = model.ss_prob
    infos['iter'] = iteration
    infos['epoch'] = epoch
    infos['iterators'] = loader.iterators
    infos['split_ix'] = loader.split_ix
    if ((iteration % opt.save_checkpoint_every) == 0):
        eval_kwargs = {'split': 'val', 'dataset': opt.input_json}
        eval_kwargs.update(vars(opt))
        (val_loss, predictions, lang_stats) = eval_utils.eval_split(dp_model, lw_model.crit, loader, eval_kwargs)
        if opt.reduce_on_plateau:
            if ('CIDEr' in lang_stats):
                optimizer.scheduler_step((- lang_stats['CIDEr']))
            else:
                optimizer.scheduler_step(val_loss)
        add_summary_value(tb_summary_writer, 'validation loss', val_loss, iteration)
        if (lang_stats is not None):
            for (k, v) in lang_stats.items():
                add_summary_value(tb_summary_writer, k, v, iteration)
        val_result_history[iteration] = {'loss': val_loss, 'lang_stats': lang_stats, 'predictions': predictions}
        if (opt.language_eval == 1):
            current_score = lang_stats['CIDEr']
        else:
            current_score = (- val_loss)
        best_flag = False
        if ((best_val_score is None) or (current_score > best_val_score)):
            best_val_score = current_score
            best_flag = True
        infos['best_val_score'] = best_val_score
        histories['val_result_history'] = val_result_history
        histories['loss_history'] = loss_history
        histories['lr_history'] = lr_history
        histories['ss_prob_history'] = ss_prob_history
        save_checkpoint(model, infos, optimizer, histories)
        if opt.save_history_ckpt:
            save_checkpoint(model, infos, optimizer, append=str(iteration))
        if best_flag:
            save_checkpoint(model, infos, optimizer, append='best')
    if ((epoch >= opt.max_epochs) and (opt.max_epochs != (- 1))):
        break
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
pointer = getattr(pointer, l[0])
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
nw_slice.tag.test_value = gof.Op._get_test_value(_seq_val_slice)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.optimizer.load_state_dict(states['optimizer'])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
shutil.rmtree(self.dataset_dir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return accimage.Image(path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (list(symbolic_weight.shape) == list(array.shape))
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
input_number = np.array([1, 2, 3, 4]).reshape(1, 4).astype('double')
magphase_window = audio.Magphase(power=2.0)
_ = magphase_window(input_number)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
settings = encoders[name]['pretrained_settings'][weights]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
medge_set = self.graph.edges[(start_clust, end_clust)]['edge_set']
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import torch
import torchaudio.compliance.kaldi as ta_kaldi
waveform = torch.from_numpy(waveform).unsqueeze(0)
features = ta_kaldi.fbank(waveform, num_mel_bins=n_bins, sample_frequency=sample_rate)
return features.numpy()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(j, bpe_tok) = next(bpe_toks)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
res = pickle.load(f)
last_acc = res[(- 1)]['test']['acc']
key = tuple(cfg.values())
results2[key] = last_acc
",0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
url = ('https://pjreddie.com/media/files/' + file)
print(('Downloading ' + url))
os.system(((('curl -f ' + url) + ' -o ') + weights))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
u = getattr(self.module, (self.name + '_u'))
v = getattr(self.module, (self.name + '_v'))
w = getattr(self.module, (self.name + '_bar'))
return True
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if match.group(2):
    number = int(entity_body, 16)
else:
    number = int(entity_body, 10)
if (128 <= number <= 159):
    return bytes((number,)).decode('cp1252')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
os.makedirs(path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
im = np.asarray(Image.open(os.path.join(path, ('dst/%d.png' % i))))
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.model.load_best_weights(self.train_dir)
print('Best weights loaded')
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (self.args.is_tpu or self.args.torchscript):
    logger.info('Do inference on TPU or torchscript. Running model 5 times to stabilize compilation')
    timeit.repeat(func, repeat=1, number=5)
runtimes = timeit.repeat(func, repeat=self.args.repeat, number=10)
if (self.args.is_tpu and self.args.torch_xla_tpu_print_metrics):
    import torch_xla.debug.metrics as met
    self.print_fn(met.metrics_report())
return (min(runtimes) / 10.0)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
file = open(filename, 'r')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.size_reg = math.log((gt_size / prop_size))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
msg = f'Downloading pretrained {kind} ""{name}"" to ""{pretrained_zip}"".'
print(msg)
torch.hub.download_url_to_file(zip_url, pretrained_zip, hash_prefix=sha256, progress=True)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
sys.path.insert(0, 'bartpy/')
from bartpy.sklearnmodel import SklearnModel
print('... SklearnModel Loaded', n_trees, n_burn)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from transformers.convert_funnel_original_tf_checkpoint_to_pytorch import convert_tf_checkpoint_to_pytorch
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import lzma
self._file_openers['.xz'] = lzma.open
self._file_openers['.lzma'] = lzma.open
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from ..models.xlnet.convert_xlnet_original_tf_checkpoint_to_pytorch import convert_xlnet_checkpoint_to_pytorch
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
result = getpwnam(name)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
sys.path.remove(_module_dir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
return super(GymObject, self).__getitem__(k)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
retval = multiprocess_train(0, opt, port)
spawncontext.join()
return retval
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
val = np.exp((res_policy[i][_].item() * 3))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (pointer.shape == array.shape), f'Pointer shape {pointer.shape} and array shape {array.shape} mismatched'
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return '{:.2f}'.format(math.pow(2, loss))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.remove((config_dir + '/init.config'))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
out = _minimal_ext_cmd(['git', 'rev-parse', 'HEAD'])
sha = out.strip().decode('ascii')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
key = self.cmodule_key()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.__root
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import yaml
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(features, dataset, examples) = (features_and_dataset['features'], features_and_dataset['dataset'], features_and_dataset['examples'])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (not valid_contextj(label, pos)):
    raise InvalidCodepointContext('Joiner {0} not allowed at position {1} in {2}'.format(_unot(cp_value), (pos + 1), repr(label)))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
resolved_config_file = cached_path(config_file, cache_dir=cache_dir, force_download=force_download, proxies=proxies, resume_download=resume_download)
if (resolved_config_file is None):
    raise EnvironmentError
config_dict = cls._dict_from_json_file(resolved_config_file)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
result = self.obj.apply(f, *args, **kwargs)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0
"
return self.env_specs[id]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import instaboostfast as instaboost
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
global fused_adam_cuda
import importlib
fused_adam_cuda = importlib.import_module('fused_adam_cuda')
return FusedAdamV1
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.auth.load_creds(subdir='/nosuchdir')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
pointer = getattr(pointer, scope_names[0])
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
label = float(toks[(- 1)])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
cached = pickle.loads(data)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
log_r_xz = batch_data['log_r_xz'].to(self.device, self.dtype, non_blocking=True)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
while ((self.state['i_epoch'] < self.params['runner']['n_epochs']) and (not self.termination_check())):
    self.state['i_cycle'] = 0
    while (self.state['i_cycle'] < self.params['runner']['n_cycles']):
        with KeepTime('/'):
            self.explorer['demo'].update()
        self.state['i_cycle'] += 1
    self.state['i_epoch'] += 1
    self.monitor_epoch()
    self.log()
    gc.collect()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0
"
parse_options(optmanager, options, extra_args)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
csv_file = _load_analytics_csv(dataset_folder, inmem, workers)
mean = np.asarray(csv_file.ix[0, 1:3])
std = np.asarray(csv_file.ix[1, 1:3])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with maybe_no_sync():
    (loss, sample_size_i, logging_output) = self.task.train_step(sample=sample, model=self.model, criterion=self.criterion, optimizer=self.optimizer, update_num=self.get_num_updates(), ignore_grad=is_dummy_batch)
    del loss
logging_outputs.append(logging_output)
sample_size += sample_size_i
if (self.cuda and (self.get_num_updates() == 0)):
    torch.cuda.empty_cache()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import torchvision.models
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import ftfy
from spacy.lang.en import English
_nlp = English()
self.nlp = _nlp.Defaults.create_tokenizer(_nlp)
self.fix_text = ftfy.fix_text
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from transformers.convert_transfo_xl_original_tf_checkpoint_to_pytorch import convert_transfo_xl_checkpoint_to_pytorch
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from spacy.lang.en import English
spacy_nlp._nlp = English()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.mkdir(args.output_dir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import re
import numpy as np
import tensorflow as tf
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
data[key] = np.array(list(map(float, value.split(' '))))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
dest.load_state_dict(src)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
data['n_fft'] = int(text_part)
continue
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
op = next(generator)
while True:
    if isinstance(op, stash):
        handle_stash(op.name, op.tensor)
        op = next(generator)
        continue
    if isinstance(op, pop):
        tensor = handle_pop(op.name)
        op = generator.send(tensor)
        continue
    raise TypeError(('%r is not a command from @skippable' % op))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (list(pt_weight.shape) == list(array.shape))
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.sum_model.train()
if ((self.hp.n_docs_min > 0) and (self.hp.n_docs_max > 0)):
    train_iter = self.dataset.get_data_loader(split='train', n_docs_min=self.hp.n_docs_min, n_docs_max=self.hp.n_docs_max, sample_reviews=True, seed=epoch, category=self.opt.az_cat)
nbatches = train_iter.__len__()
(stats_avgs, evaluator, _) = self.run_epoch(train_iter, nbatches, epoch, 'train', sum_optimizer=self.sum_optimizer, discrim_optimizer=self.discrim_optimizer, clf_optimizer=self.clf_optimizer, cpkt_every=int((nbatches / 10)), save_intermediate=True, run_val_subset=True, tb_writer=self.tb_tr_writer)
for (k, v) in stats_avgs.items():
    self.tb_tr_writer.add_scalar('overall_stats/{}'.format(k), v, epoch)
for (stat, rouges) in evaluator.get_avg_stats_dicts().items():
    for (rouge_name, d) in rouges.items():
        for (metric_name, v) in d.items():
            self.tb_tr_writer.add_scalar('overall_rouges_{}/{}/{}'.format(stat, rouge_name, metric_name), v, epoch)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_archive_file = cached_path(archive_file, cache_dir=None)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (not ignore_utf_errors):
    with open(f, 'r', encoding='utf-8') as fd:
        self.add_from_file(fd)
else:
    with open(f, 'r', encoding='utf-8', errors='ignore') as fd:
        self.add_from_file(fd)
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import regex as re
self.re = re
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
tops = [db.eval_query_top(q, s) for (q, s) in enumerate(tqdm.tqdm(scores, desc='top1'))]
if detailed:
    res['tops'] = tops
for k in tops[0]:
    res[('top%d' % k)] = float(np.mean([top[k] for top in tops]))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(dirname)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return list(map(type, x))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
os.makedirs(path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
result = getpwnam(name)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return safe_round((base ** loss), round)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
axes = self.font.getvaraxes()
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (pointer.shape == array.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from fairseq.modules.dynamicconv_layer import DynamicconvLayer
return DynamicconvLayer(input_size, kernel_size=kernel_size, padding_l=padding_l, num_heads=num_heads, weight_dropout=weight_dropout, weight_softmax=weight_softmax, bias=bias)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
colors.append(self.color_map[numpy.where((act > lookup))[0][(- 1)]])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
response = requests.head(url, allow_redirects=True)
if (response.status_code != 200):
    etag = None
else:
    etag = response.headers.get('ETag')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
arr.remove('[')
arr.remove(']')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
client = carla.Client('localhost', port)
client.set_timeout(client_timeout)
client.load_world(map_name=town)
world = client.get_world()
world.set_weather(carla.WeatherParameters.ClearNoon)
frame = world.apply_settings(carla.WorldSettings(no_rendering_mode=False, synchronous_mode=True, fixed_delta_seconds=(1.0 / fps)))
logging.debug('Server version: {}'.format(client.get_server_version()))
logging.debug('Client version: {}'.format(client.get_client_version()))
return (client, world, frame, server)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex.optimizers import FP16_Optimizer
from apex.optimizers import FusedAdam
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.removedirs(head)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
Chem.SanitizeMol(mol)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
shutil.copy(req.local_file_path, options.wheel_dir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (pointer.shape == array.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
six.text_type(s, 'ascii')
return True
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0
"
cat = self._data.fillna(value)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0
"
self.vis.line(X=np.stack(([np.array(self.plot_data['X'])] * len(self.plot_data['legend'])), 1), Y=np.array(self.plot_data['Y']), opts={'title': (self.name + ' loss over time'), 'legend': self.plot_data['legend'], 'xlabel': 'epoch', 'ylabel': 'loss'}, win=self.display_id)
",0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return SparseConstant(SparseType(format=x.format, dtype=x.dtype), x.copy(), name=name)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
return float('{:.2f}'.format(math.pow(2, loss)))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
multivariate_normal(mu, sigma)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
(scores, predictions) = self.translator.translate(src_data_iter=texts_to_translate, batch_size=self.opt.batch_size)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import sentencepiece as spm
self.sp = spm.SentencePieceProcessor()
self.sp.Load(vocab)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from mmdet.version import __version__
sha = __version__.split('+')[(- 1)]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
nn.utils.remove_weight_norm(module)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
val = float(val)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
import spacy
from spacy.language import Language
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
cost = argmin(n, axis=(- 1))
cost.name = None
g = grad(cost, n)
raise Exception('Expected an error')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
self.bias = Parameter(linear.bias.data.clone())
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return sorted(terminals).index(word)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
nll = model.optimize_parameters(current_step)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
mask = np.array(mask, copy=copy, dtype=mdtype)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
optimizer_discriminator.load_state_dict(checkpoint['optimizer_discriminator'])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import torch
import tensorflow as tf
from tensorflow.python.keras import backend as K
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.ignore_index = tuple(ignore_index)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
documented = (total - stats[('undocumented_' + node_type)])
percent = ((documented * 100.0) / total)
nice_stats[node_type]['percent_documented'] = ('%.2f' % percent)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
metadata = state_dict._metadata
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return self.const_type(value[slobj], self.env)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
grad_input = QE(grad_output, self.bits_E)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
nice = self.__nice__()
classname = self.__class__.__name__
return '<{0}({1}) at {2}>'.format(classname, nice, hex(id(self)))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
_ = py_vision.RandomAffine(degrees=15, scale=(0.0, 0.0))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
(train_loss, n_iter, optimizer) = train(train_loader, model, criterion, optimizer, epoch, n_iter, args.use_gpu, args.double_ema, args.thaw, temporal, dtype)
print('Epoch {}/{} done with train loss {}\n'.format(epoch, args.epochs, train_loss))
if (args.val_perc > 0):
    print('Running validation..')
    val_loss = validate(val_loader, model, criterion, epoch, temporal, dtype)
    print('Validation loss: {}'.format(val_loss))
if ((epoch % plot_every) == 0):
    train_losses.append(train_loss.cpu())
    if (args.val_perc > 0):
        val_losses.append(val_loss.cpu())
torch.save({'epoch': (epoch + 1), 'state_dict': model.cpu().state_dict(), 'optimizer': optimizer.state_dict()}, (args.new_model + '.pt'))
if (args.use_gpu == 'parallel'):
    model = nn.DataParallel(model).cuda()
elif (args.use_gpu == 'gpu'):
    model = model.cuda()
else:
    pass
'\n            else:\n\n                print(""Training on whole set"")\n                train_loss, n_iter, optimizer = train(whole_loader, model, criterion, optimizer, epoch, n_iter)\n                print(""Epoch {}/{} done with train loss {}"".format(epoch, args.epochs, train_loss))\n            '
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
f = open(path, 'r')
result = yaml.load(f, Loader=yaml.Loader)
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from pygtrie import Trie
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
print('{0:>4} {1:.4f}'.format(0, float(f_gjsd(nr.randn(*data.shape), data)[0])))
for epoch in range(max_epochs):
    values = []
    print(f'Alpha: {alpha}')
    for t in range(0, data.shape[1], B):
        Z = nr.randn(D, B)
        Y = data[:, t:(t + B)]
        (v, ga, gb) = f_gjsd(Z, Y)
        da = ((mm * da) - (lr * ga))
        db = ((mm * db) - (lr * gb))
        values.append(v)
        a.set_value((a.get_value() + da))
        b.set_value((b.get_value() + db))
    lr /= 2.0
    print('{0:>4} {1:.4f}'.format((epoch + 1), np.mean(values)))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
cy_thresh = (np.finfo(M.dtype).eps * 4)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
traced_gpt2 = torch.jit.trace(model, inputs)
torch.jit.save(traced_gpt2, 'traced_model.pt')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(dom, slot, value) = dom_slot_value.split('-')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
return (self.model[self.word2id[word]], word)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
shape = trn_data.data.shape
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import sentencepiece as spm
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
args.streaming_layers = [int(s, 0) for s in args.streaming_layers.split(',')]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
resolved_model_card_file = cached_path(model_card_file, cache_dir=cache_dir, force_download=True, proxies=proxies, resume_download=False)
if (resolved_model_card_file is None):
    raise EnvironmentError
if (resolved_model_card_file == model_card_file):
    logger.info('loading model card file {}'.format(model_card_file))
else:
    logger.info('loading model card file {} from cache at {}'.format(model_card_file, resolved_model_card_file))
modelcard = cls.from_json_file(resolved_model_card_file)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
batch[k] = batch[k].cuda()
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
transform = getattr(transforms, key)(*cfg_dict[key])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
import sentencepiece as spm
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (len(tree_dict[node_index]['children']) == 1):
    ast_words.append(tree_dict[node_index]['children'][0])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
repo_dpath = dirname(dirname(dirname(__file__)))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from torch.distributed.pipeline.sync import Pipe
global Pipe
from torch.distributed.pipeline.sync.utils import partition_model
global partition_model
from torch.distributed import rpc
import tempfile
TORCH_PIPE = True
tmpfile = tempfile.NamedTemporaryFile()
if (not RPC_INIT):
    rpc.init_rpc(name='worker', rank=0, world_size=1, rpc_backend_options=rpc.TensorPipeRpcBackendOptions(init_method='file://{}'.format(tmpfile.name)))
    RPC_INIT = True
logger.info('Using torch pipe')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.chunk_left = int(line, 16)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
nn.utils.remove_weight_norm(module)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
os.makedirs(os.path.join(outputdir, *parts[:(- 1)]))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return self.idxToLabel[idx]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
_parse_makefile(makefile, vars)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
numpy_include = np.get_include()
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return datetime.strptime(t[0], fmt).date()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
from fairseq.modules.lightconv_layer import LightconvLayer
return LightconvLayer(input_size, kernel_size=kernel_size, padding_l=padding_l, num_heads=num_heads, weight_dropout=weight_dropout, weight_softmax=weight_softmax, bias=bias)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
indexof = cmd.index('-u')
cmd.pop(indexof)
cmd.pop(indexof)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
return object.__getattribute__(self, name)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from sacremoses import MosesPunctNormalizer
self.punc_normalizer = MosesPunctNormalizer(self.source_lang).normalize
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (not self.args.use_bmuf):
    self.optimizer.multiply_grads((self.args.distributed_world_size / sample_size))
elif (sample_size > 0):
    num = (self.args.distributed_world_size if self._sync_stats() else 1)
    self.optimizer.multiply_grads((num / sample_size))
grad_norm = self.optimizer.clip_grad_norm(self.args.clip_norm)
if (not self.args.use_bmuf):
    self._check_grad_norms(grad_norm)
self.optimizer.step()
self.set_num_updates((self.get_num_updates() + 1))
logging_output = self._reduce_and_log_stats(logging_outputs, sample_size, grad_norm)
if ((self.args.empty_cache_freq > 0) and ((((self.get_num_updates() + self.args.empty_cache_freq) - 1) % self.args.empty_cache_freq) == 0) and torch.cuda.is_available() and (not self.args.cpu)):
    torch.cuda.empty_cache()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
for (i, image) in enumerate(images.items()):
    restacked = client.submit(self.restack_image, *(i, image, scaled_feature_space, svm))
    feature_space.append(restacked)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0
"
r = float(args[0])
self.q = np.array([r, 0.0, 0.0, 0.0])
return
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
shell = get_ipython().__class__.__name__
if (shell == 'ZMQInteractiveShell'):
    return True
elif (shell == 'TerminalInteractiveShell'):
    return False
else:
    return False
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
trackers = [registry[tracker] for tracker in trackers]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
idx = original_branch_qconfig_list.index(merged_qconfig)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
resolved_archive_file = cached_path(archive_file, cache_dir=cache_dir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import jieba
list(jieba.cut('作为', cut_all=False))
return jieba
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
label = label.encode('ascii')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0
"
new_index = new_index.droplevel(i)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
traced_gpt2 = torch.jit.trace(model, inputs)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
value = literal_eval(value)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
import lmdb
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return float(val)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
for epoch in trange(self.epochs, desc='epochs'):
    pbar = trange(self.iterations, desc='iteration')
    for i in pbar:
        (_, loss) = self.train_step(epoch, i)
        pbar.set_description(f'loss: {loss.item():.2f}')
    if self.create_story:
        self.clip_encoding = self.update_story_encoding(epoch, i)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.file_name = int(file_name)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
return self._key
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (p_i.shape == arr_i.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
text_a = line[3]
text_b = line[4]
label = line[5]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
f = DatasetCatalog._REGISTERED[name]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (list(pt_weight.shape) == list(array.shape))
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return self.overrides[where]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
img = Image.open(img_path).convert('RGB')
got_img = True
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return _cache[filename]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return partition[index]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import numpy as np
import tensorflow as tf
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
hat_y = pickle.load(open(os.path.join(self.result_dir, ('hat_y.' + self._loaded_epoch)), 'rb'))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
token_classification_task_clazz = getattr(module, hparams.task_type)
self.token_classification_task: TokenClassificationTask = token_classification_task_clazz()
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return bpe.is_beginning_of_word(tok)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
self.file_name = int(file_name)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
parse(string, fuzzy=fuzzy)
return True
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
encoded_sent = tokenizer.encode(sent, add_special_tokens=True, max_length=max_length)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
from habitat.datasets.vln.r2r_vln_dataset import VLNDatasetV1
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
data = ds.FlickrDataset(FLICKR30K_DATASET_DIR, FLICKR30K_ANNOTATION_FILE_1, decode=True)
data = data.map(operations=exception_func, input_columns=['image'], num_parallel_workers=1)
num_rows = 0
for _ in data.create_dict_iterator(num_epochs=1):
    num_rows += 1
assert False
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from fairscale.nn import enable_wrap
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
outputs = net(inputs)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
pointer = getattr(pointer, l[0])
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
func = getattr(lib, item[0])
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (list(self.args.labels_map.keys()) == self.args.labels_list)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return convex_hull_image(im)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
img = cv2.imread(img_path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
f_iter = iter(field)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
rawmode = MODES[layout]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return load(os.path.join(directory, filename))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from transformers.convert_funnel_original_tf_checkpoint_to_pytorch import convert_tf_checkpoint_to_pytorch
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from allennlp.modules.token_embedders.bidirectional_language_model_token_embedder import BidirectionalLanguageModelTokenEmbedder
from allennlp.data.token_indexers.elmo_indexer import ELMoTokenCharactersIndexer
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
nvml.nvmlInit()
devices = (list(range(nvml.nvmlDeviceGetCount())) if (gpus_to_trace is None) else gpus_to_trace)
nvml.nvmlShutdown()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
y.create_dataset(k, data=v)
y[k].attrs['__data_type__'] = 'ndarray'
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
return f.readline()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0
"
return bytes([BCHAR_TO_BYTE[bc] for bc in x]).decode('utf-8')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
j = word.index(first, i)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
resolved_archive_file = cached_path(archive_file, cache_dir=cache_dir)
resolved_config_file = cached_path(config_file, cache_dir=cache_dir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (len(val) == 10):
    d = datetime.date(int(val[:4]), int(val[5:7]), int(val[8:10]))
else:
    d = datetime.datetime(int(val[:4]), int(val[5:7]), int(val[8:10]), int(val[11:13]), int(val[14:16]), int(val[17:19]), microsecond, tz)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
ineff_kw_counts = ineff_kw_dc[f'{kw_decision[0]}-{kw_decision[1]}']
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self._root = os.path.split(stream.name)[0]
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import Mykytea
self.ja_word_tokenizer = Mykytea.Mykytea(('-model %s/local/share/kytea/model.bin' % os.path.expanduser('~')))
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
loss = output_dict[u'loss']
if for_training:
    loss += self._model.get_regularization_penalty()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
u = getattr(self.module, (self.name + '_u'))
v = getattr(self.module, (self.name + '_v'))
w = getattr(self.module, (self.name + '_bar'))
return True
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import tensorflow as tf
import torch
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if ('jieba' not in sys.modules):
    import jieba
else:
    jieba = sys.modules['jieba']
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from mmdet.version import __version__
sha = __version__.split('+')[(- 1)]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
content_img = Image.open(content_path).convert('RGB')
for style_path in random.sample(styles, args.num_styles):
    style_img = Image.open(style_path).convert('RGB')
    content = content_tf(content_img)
    style = style_tf(style_img)
    style = style.to(device).unsqueeze(0)
    content = content.to(device).unsqueeze(0)
    with torch.no_grad():
        output = style_transfer(vgg, decoder, content, style, args.alpha)
    output = output.cpu()
    rel_path = content_path.relative_to(content_dir)
    out_dir = output_dir.joinpath(rel_path.parent)
    if (not out_dir.is_dir()):
        out_dir.mkdir(parents=True)
    content_name = content_path.stem
    style_name = style_path.stem
    out_filename = (((content_name + '-stylized-') + style_name) + content_path.suffix)
    output_name = out_dir.joinpath(out_filename)
    save_image(output, output_name, padding=0)
    style_img.close()
content_img.close()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import apex
apex.amp.register_half_function(torch, 'einsum')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return {'float16': (float, 'npy_float16', 'NPY_FLOAT16'), 'float32': (float, 'npy_float32', 'NPY_FLOAT32'), 'float64': (float, 'npy_float64', 'NPY_FLOAT64'), 'uint8': (int, 'npy_uint8', 'NPY_UINT8'), 'int8': (int, 'npy_int8', 'NPY_INT8'), 'uint16': (int, 'npy_uint16', 'NPY_UINT16'), 'int16': (int, 'npy_int16', 'NPY_INT16'), 'uint32': (int, 'npy_uint32', 'NPY_UINT32'), 'int32': (int, 'npy_int32', 'NPY_INT32'), 'uint64': (int, 'npy_uint64', 'NPY_UINT64'), 'int64': (int, 'npy_int64', 'NPY_INT64'), 'complex128': (complex, 'theano_complex128', 'NPY_COMPLEX128'), 'complex64': (complex, 'theano_complex64', 'NPY_COMPLEX64')}[self.dtype]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(firstaxis, parity, repetition, frame) = _AXES2TUPLE[axes.lower()]
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
proc.stdin.write(('%s\n' % filepath).encode(defenc))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
_cls = cls._style_list[_name]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from fairseq import libnat_cuda
return (libnat_cuda, True)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
scores = [x['score'] for x in sinfo]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
len_data_loader = len(self.data_loader)
num_training_batches = math.ceil((len_data_loader / self._num_gradient_accumulation_steps))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
assert (p_i.shape == arr_i.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with open(file_name, 'wt') as opt_file:
    opt_file.write(message)
    opt_file.write('\n')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
ws.RunNet(self.net.Proto().name)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
f = open(script, 'rb')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with Image.open(image_path) as im:
    pass
self.image_path_list.append(image_path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_archive_file = cached_path(archive_file, cache_dir=None)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex import amp
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex import amp
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
filtered_df = func_df[func_df['function'].isin(funcs)]
filtered_df.sort_values('date', inplace=True)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import psutil
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
shutil.copy2(file_path, task_directory_path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
rname = rec_check[0][1]
if ((rname == '<ipython console>') or rname.endswith('<string>')):
    return rec_check
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with tf.Graph().as_default(), tf.Session() as sess:
    vggish_slim.define_vggish_slim(training=False, **params)
    vggish_slim.load_vggish_slim_checkpoint(sess, model_path, **params)
    while True:
        (audio_path, output_path) = (yield)
        if os.path.exists(output_path):
            continue
        try:
            examples_batch = vggish_input.wavfile_to_examples(audio_path, **params)
        except ValueError:
            print('Error opening {}. Skipping...'.format(audio_path))
            continue
        pproc = vggish_postprocess.Postprocessor(pca_params_path, **params)
        input_tensor_name = (input_op_name + ':0')
        output_tensor_name = (output_op_name + ':0')
        features_tensor = sess.graph.get_tensor_by_name(input_tensor_name)
        embedding_tensor = sess.graph.get_tensor_by_name(output_tensor_name)
        [embedding_batch] = sess.run([embedding_tensor], feed_dict={features_tensor: examples_batch})
        emb = pproc.postprocess(embedding_batch, **params).astype(np.float32)
        with gzip.open(output_path, 'wb') as f:
            emb.dump(f)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
img_tensor = torch.stack(img_tensor, 0)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
self.temp_idx2symbol += [mask_list[i] for i in range(self.copy_nums)]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
version_start = (_find_name_version_sep(fragment, canonical_name) + 1)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
del self[key]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(dirpath)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return json.dumps(self.as_dict(), indent=4)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
import numpy as np
import tensorflow as tf
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_config_file = cached_path(config_file, cache_dir=cache_dir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
label = self.label_map[obj['category']]
color = ((label.trainId / 255.0), (obj['id'] / 255.0), 0)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
int(value)
return True
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
data = ds.DIV2KDataset(DATASET_DIR, usage=usage, downgrade=downgrade, scale=scale)
data = data.map(operations=exception_func, input_columns=['hr_image'], num_parallel_workers=1)
num_rows = 0
for _ in data.create_dict_iterator(num_epochs=1):
    num_rows += 1
assert False
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if extract_continuous:
    out_continuous.append(output[continuous_cols])
if extract_embeddables:
    out_to_embed.append(output[to_embed_cols])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex import amp
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
output = mll.model(*train_inputs)
args = ([output, train_targets] + _get_extra_mll_args(mll))
loss = (- mll(*args).sum())
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
gData.optimal_sequence_to_excel(mode)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return construct_arg(class_name, name, arg, default, params, **extras)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0
"
lvl = int(d)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
import re
import numpy as np
import tensorflow as tf
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
fn(1.5, 3.0)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
del module.target_input
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
pointer = getattr(pointer, l[0])
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.corpus = io.open(corpus_path, 'r', encoding='utf-8')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return next(self.parameters()).dtype
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from .modeling_tf_pytorch_utils import load_tf2_checkpoint_in_pytorch_model
model = load_tf2_checkpoint_in_pytorch_model(model, resolved_archive_file, allow_missing_keys=True)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
background = im.palette.getcolor(background, im)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
return float(val)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
os.makedirs(root)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex import amp
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
arr.remove('[')
arr.remove(']')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
self.pixels[y][x] = color
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
verify_split_model(module_split)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
six.text_type(s, 'ascii')
return True
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0
"
for i in range(0, len(images), batch_size):
    predictions.extend(detector.get_detections_for_batch(np.array(images[i:(i + batch_size)])))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return self._components.get_component(name)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
ip_int = 0
for i in range(parts_hi):
    ip_int <<= 16
    ip_int |= cls._parse_hextet(parts[i])
ip_int <<= (16 * parts_skipped)
for i in range((- parts_lo), 0):
    ip_int <<= 16
    ip_int |= cls._parse_hextet(parts[i])
return ip_int
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
assert (pointer.shape == array.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (pointer.shape == array.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
verb_index = fields['verb_indicator'].labels.index(1)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
import fairscale
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if ('intro' in self.options):
    intro = (self.options['intro'][:195] + '...')
else:
    (_, blocks) = sphinx_gallery.gen_rst.split_code_and_text_blocks(abs_fname)
    (intro, _) = sphinx_gallery.gen_rst.extract_intro_and_title(abs_fname, blocks[0][1])
thumbnail_rst = sphinx_gallery.backreferences._thumbnail_div(dirname, basename, intro)
if ('figure' in self.options):
    (rel_figname, figname) = env.relfn2path(self.options['figure'])
    save_figname = os.path.join('_static/thumbs/', os.path.basename(figname))
    try:
        os.makedirs('_static/thumbs')
    except OSError:
        pass
    sphinx_gallery.gen_rst.scale_image(figname, save_figname, 400, 280)
    thumbnail_rst = re.sub('..\\sfigure::\\s.*\\.png', '.. figure:: /{}'.format(save_figname), thumbnail_rst)
thumbnail = StringList(thumbnail_rst.split('\n'))
thumb = nodes.paragraph()
self.state.nested_parse(thumbnail, self.content_offset, thumb)
return [thumb]
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
bleu = float(result.split(',')[0][7:])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
return self.question_encoder.bert_model.get_input_embeddings()
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
for _ in range(self.chunk_size):
    chunk.append(next(self.itr))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import cv2
if (int(cv2.__version__.split('.')[0]) >= 3):
    cv2.ocl.setUseOpenCL(False)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
d = open(f, 'r')
return d
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
pts_bytes = self.file_client.get(pts_filename)
points = np.frombuffer(pts_bytes, dtype=np.float32)
",0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.ws = WebsocketServer(port, host='127.0.0.1')
self.port = port
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import instaboostfast as instaboost
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
lvis_dt = LVISResults(lvis_gt, result_files[metric])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
testResult = bake._check_source_code(config, options)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(save_folder_mother)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
out = _minimal_ext_cmd(['git', 'rev-parse', 'HEAD'])
sha = out.strip().decode('ascii')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.global_step = int(model_path.split('-')[(- 1)].split('/')[0])
epochs_trained = (self.global_step // (len(train_dataloader) // self.args.gradient_accumulation_steps))
steps_trained_in_current_epoch = (self.global_step % (len(train_dataloader) // self.args.gradient_accumulation_steps))
logger.info('  Continuing training from checkpoint, will skip to saved global_step')
logger.info('  Continuing training from epoch %d', epochs_trained)
logger.info('  Continuing training from global step %d', self.global_step)
logger.info('  Will skip the first %d steps in the first epoch', steps_trained_in_current_epoch)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
self.set_defaults(**self._defaults)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
task.load_dataset(subset, combine=False, epoch=1)
dataset = task.dataset(subset)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
int(n)
x = (True if (start <= int(n) <= end) else False)
return x
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
return bool(eval(x))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
os.makedirs(self.root_path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from transformers import load_tf2_checkpoint_in_pytorch_model
model = load_tf2_checkpoint_in_pytorch_model(model, resolved_archive_file, allow_missing_keys=True)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return '{:.2f}'.format(math.pow(2, loss))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
while True:
    t += 1
    agent.offline_update(counter=t)
    if (checkpoint_freq and ((t % checkpoint_freq) == 0)):
        save_agent(agent, t, outdir, logger, suffix='_checkpoint')
    for hook in step_hooks:
        hook(None, agent, t)
    if ((log_interval is not None) and (t >= log_interval) and ((t % log_interval) == 0)):
        logger.info('outdir:{} training roop:{}'.format(outdir, t))
        logger.info('statistics: {}'.format(agent.get_statistics()))
    if tester:
        if tester.evaluate_if_necessary(t=t, episodes=0):
            if ((successful_score is not None) and (tester.max_score >= successful_score)):
                break
    if (t >= steps):
        break
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
c = f.read(1)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0
"
matcher = self.version_match
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if select(entry, entry._s):
    res = path(entry, entry._s)
    if (type(res) == LogEntry):
        return res.__dict__['_']
    else:
        return res
else:
    return None
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex.optimizers import FP16_Optimizer
from apex.optimizers import FusedAdam
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from fairseq.modules.lightconv_layer import LightconvLayer
return LightconvLayer(input_size, kernel_size=kernel_size, padding_l=padding_l, num_heads=num_heads, weight_dropout=weight_dropout, weight_softmax=weight_softmax, bias=bias)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
rel_grad = []
linear_grad = []
for epoch_id in range(args.n_epochs):
    if (epoch_id == args.unfreeze_epoch):
        print('encoder unfreezed')
        unfreeze_net(model.encoder)
    if (epoch_id == args.refreeze_epoch):
        print('encoder refreezed')
        freeze_net(model.encoder)
    model.train()
    for (qids, labels, *input_data) in dataset.train():
        optimizer.zero_grad()
        bs = labels.size(0)
        for a in range(0, bs, args.mini_batch_size):
            b = min((a + args.mini_batch_size), bs)
            (logits, _) = model(*[x[a:b] for x in input_data], layer_id=args.encoder_layer)
            if (args.loss == 'margin_rank'):
                num_choice = logits.size(1)
                flat_logits = logits.view((- 1))
                correct_mask = F.one_hot(labels, num_classes=num_choice).view((- 1))
                correct_logits = flat_logits[(correct_mask == 1)].contiguous().view((- 1), 1).expand((- 1), (num_choice - 1)).contiguous().view((- 1))
                wrong_logits = flat_logits[(correct_mask == 0)]
                y = wrong_logits.new_ones((wrong_logits.size(0),))
                loss = loss_func(correct_logits, wrong_logits, y)
            elif (args.loss == 'cross_entropy'):
                loss = loss_func(logits, labels[a:b])
            loss = ((loss * (b - a)) / bs)
            loss.backward()
            total_loss += loss.item()
        if (args.max_grad_norm > 0):
            nn.utils.clip_grad_norm_(model.parameters(), args.max_grad_norm)
        rel_grad.append(model.decoder.rel_emb.weight.grad.abs().mean().item())
        linear_grad.append(model.decoder.mlp.layers[8].weight.grad.abs().mean().item())
        scheduler.step()
        optimizer.step()
        if (((global_step + 1) % args.log_interval) == 0):
            total_loss /= args.log_interval
            ms_per_batch = ((1000 * (time.time() - start_time)) / args.log_interval)
            print('| step {:5} |  lr: {:9.7f} | loss {:7.4f} | ms/batch {:7.2f} |'.format(global_step, scheduler.get_lr()[0], total_loss, ms_per_batch))
            total_loss = 0
            rel_grad = []
            linear_grad = []
            start_time = time.time()
        global_step += 1
    model.eval()
    dev_acc = evaluate_accuracy(dataset.dev(), model)
    test_acc = (evaluate_accuracy(dataset.test(), model) if args.test_statements else 0.0)
    print(('-' * 71))
    print('| epoch {:5} | dev_acc {:7.4f} | test_acc {:7.4f} |'.format(epoch_id, dev_acc, test_acc))
    print(('-' * 71))
    with open(log_path, 'a') as fout:
        fout.write('{},{},{}\n'.format(global_step, dev_acc, test_acc))
    if (dev_acc >= best_dev_acc):
        best_dev_acc = dev_acc
        final_test_acc = test_acc
        best_dev_epoch = epoch_id
        torch.save(model.state_dict(), model_path)
        print(f'model saved to {model_path}')
    model.train()
    start_time = time.time()
    if ((epoch_id > args.unfreeze_epoch) and ((epoch_id - best_dev_epoch) >= args.max_epochs_before_stop)):
        break
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
for attr in args.attr.split('.'):
    if attr.isdigit():
        attr = int(attr)
    indict = indict[attr]
print(indict)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
pointer = getattr(pointer, l[0])
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
task.load_dataset(subset, combine=False, epoch=1, task_cfg=saved_cfg.task)
dataset = task.dataset(subset)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return self.popmin()
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import re
import numpy as np
import tensorflow as tf
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(self.next_rgb, self.next_t, self.next_gt, _, _) = next(self.loader)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import pyximport
cython_available = True
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
alpha = [(a * w) for (a, w) in zip(alpha, self.weights)]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
os.makedirs(os.path.join(self.root, self.raw_folder))
os.makedirs(os.path.join(self.root, self.processed_folder))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
traced_gpt2 = torch.jit.trace(model, inputs)
torch.jit.save(traced_gpt2, 'traced_model.pt')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return object.__format__(self, format_spec)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
weights.save_layer(module)
log.debug(f'Layer saved: {name}')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
del self.__connection
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(A, A_paths) = next(self.data_loader_A_iter)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if params.expanded_cms:
    assert ('examiner' in params.train_root), 'training with an '
    'expanded set of camera models (only valid if user is '
    'examiner)'
    exp_root = params.train_root.replace('examiner', 'examiner_outdist')
    (dataset_exp, n_classes_exp, n_samples_exp) = self.dataset(params, exp_root, n_classes)
    dataset = ConcatDataset((dataset, dataset_exp))
    n_classes += n_classes_exp
    n_samples += n_samples_exp
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return _compat_int_from_byte_vals(map(cls._parse_octet, octets), 'big')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
from apex import amp
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.__next__()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
for seed in range(42, (42 + 4)):
    try:
        expstr = ('k=%d_B=%d_seed=%d/progress.csv' % (k, b, seed))
        df = pd.read_csv(opj(ceemdatadir, expstr))
        error = (10 ** df['test/log10_error'].values)
        print(df['test/log10_error'].values[:10])
        (l,) = ax.plot(range(error.shape[0]), error, color=('C%d' % i), alpha=0.55)
        if (seed == 42):
            l.set_label(('CE-EM: (%d traj)' % b))
        if (b == 8):
            expstr = ('k=%d_B=%d_seed=%d/progress.csv' % (k, b, seed))
            df = pd.read_csv(opj(pemdatadir, expstr))
            error = (10 ** df['test/log10_error'].values)
            print(df['test/log10_error'].values[:10])
            (l_,) = ax.plot(df['time/epoch'], error, color=('C%d' % (i + 1)), alpha=0.55)
            if (seed == 42):
                l_.set_label(('Particle EM (%d traj) ' % b))
    except FileNotFoundError:
        pass
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0
"
heap_pos = self.buffer2heap[self._buffer_position]
self.full = True
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
my_mod.__warningregistry__.clear()
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
filename = readline.__self__.name
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
may_share_memory(b_, a_)
raise Exception('An error was expected')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
return accimage.Image(path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
f.__name__ = '{}list'.format(scalar_validator.__name__)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
version = tuple(map(int, torchvision.__version__.split('.')[:2]))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
assert (pointer.shape == array.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
f = h5py.File(self.detections_path, 'r')
precomp_data = f[('%d_features' % image_id)][()]
if self.sort_by_prob:
    precomp_data = precomp_data[np.argsort(np.max(f[('%d_cls_prob' % image_id)][()], (- 1)))[::(- 1)]]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from fairseq import libnat
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (len(val) == 10):
    d = datetime.date(int(val[:4]), int(val[5:7]), int(val[8:10]))
else:
    d = datetime.datetime(int(val[:4]), int(val[5:7]), int(val[8:10]), int(val[11:13]), int(val[14:16]), int(val[17:19]), microsecond, tz)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
ast = self.processor.build_ast()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0
"
from transformers.models.funnel.convert_funnel_original_tf_checkpoint_to_pytorch import convert_tf_checkpoint_to_pytorch
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
for c in substring:
    while True:
        if string[pos].isspace():
            pos += 1
        elif (string[pos] == '#'):
            pos = string.index('\n', pos)
        else:
            break
    if (string[pos] != c):
        return False
    pos += 1
self.pos = pos
return True
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(step, (data, targets)) = next(self.iter)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(images, labels) = next(data_iter)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import re
import numpy as np
import tensorflow as tf
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
file_name = os.path.basename(file_path)
target_path = os.path.join(target_resource_dir, file_name)
print('copying {} to {}'.format(file_path, target_path))
shutil.copy2(file_path, target_path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
vals2 = np.zeros((0, 1, ((2 ** 31) - 1)))
vals3 = np.zeros((0, 1, (2 ** 31)))
e = bsr_matrix((vals2, indices, indptr), shape=(1, ((2 ** 31) - 1)))
f = bsr_matrix((vals3, indices, indptr), shape=(1, (2 ** 31)))
assert_equal(e.indptr.dtype, np.int32)
assert_equal(f.indptr.dtype, np.int64)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
alg_module = import_module('.'.join(['baselines', alg, submodule]))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
docdata = cls.__docdata__
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_archive_file = cached_path(archive_file, cache_dir=cache_dir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(j, bpe_tok) = next(bpe_toks)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return self.__dep_map
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return OrderedDict.__getitem__(self, key)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import instaboostfast as instaboost
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(_loss, sample_size, logging_output) = self.task.valid_step(sample, self.model, self.criterion)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with open(os.path.join(selected_dir, 'model_args.json'), 'r') as f:
    model_args = json.load(f)
model_class = model_args['model_class']
model_type = model_args['model_type']
model_name = selected_dir
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if ((len(param.stride) > 1) or (len(param.kernel_size) > 1) or (len(param.pad) > 1)):
    raise NotImplementedError('Translator currently does not support non-conventional pad/kernel/stride settings.')
stride = (param.stride[0] if len(param.stride) else 1)
pad = (param.pad[0] if len(param.pad) else 0)
kernel = (param.kernel_size[0] if len(param.kernel_size) else 0)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
cls = globals()[cls_name]
return cls(config)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
plt.plot(epochs, history['val_acc_metric'], 'r--', label='Val')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return list(map(type, x))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
checkpoint_suffix = args.model_name_or_path.split('-')[(- 1)].split('/')[0]
global_step = int(checkpoint_suffix)
epochs_trained = (global_step // (len(train_dataloader) // args.gradient_accumulation_steps))
steps_trained_in_current_epoch = (global_step % (len(train_dataloader) // args.gradient_accumulation_steps))
logger.info('  Continuing training from checkpoint, will skip to saved global_step')
logger.info('  Continuing training from epoch %d', epochs_trained)
logger.info('  Continuing training from global step %d', global_step)
logger.info('  Will skip the first %d steps in the first epoch', steps_trained_in_current_epoch)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
self.load_next_level()
self.state.screen = 'GAME'
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
index = int(elem_key)
merged_list[index] = merge(preferred_element, fallback_value[index])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
return get_numeric_sort_key_fn(all_values)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
value = unquote_to_bytes(value)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0
"
for epoch in range(num_epochs):
    print('Epoch {}/{}'.format((epoch + 1), num_epochs))
    print(('-' * 10))
    loss_per_batch = []
    for phase in ['train', 'validation']:
        if (phase == 'train'):
            model.train()
        else:
            model.eval()
        running_loss = 0.0
        running_acc = 0.0
        running_class = 0.0
        for (inputs, labels) in dataloaders[phase]:
            batch_size = inputs.size(0)
            inputs = inputs.to(device)
            if isinstance(labels, collections.Sequence):
                if boundary_loss:
                    dists = labels[1].to(device)
                    labels = labels[0].to(device)
                else:
                    labels = (labels[0].to(device), labels[1].to(device))
            else:
                labels = labels.to(device)
            optimizer.zero_grad()
            with torch.set_grad_enabled((phase == 'train')):
                outputs = model(inputs)
                if boundary_loss:
                    loss = criterion(outputs, dists, labels)
                else:
                    loss = criterion(outputs, labels)
                if probs2onehot:
                    mask = probs2one_hot(outputs.detach())
                else:
                    mask = outputs
                if (hasattr(criterion, 'cross_entropy') and criterion.cross_entropy):
                    outputs = ce_output_to_mask(outputs, numpy=False).to(device)
                if classify:
                    (acc, acc_class) = metric(outputs, labels)
                else:
                    acc = metric(mask, labels)
                if (phase == 'train'):
                    loss_per_batch.append(loss)
                    loss.backward()
                    optimizer.step()
            running_loss += (loss.item() * batch_size)
            running_acc += (acc * batch_size)
            if classify:
                running_class += (acc_class * batch_size)
        if (phase == 'train'):
            print('Learning rate step')
            scheduler.step()
        epoch_loss = (running_loss / dataset_sizes[phase])
        epoch_acc = (running_acc / dataset_sizes[phase])
        epoch_class = (running_class / dataset_sizes[phase])
        if (phase == 'train'):
            if boundary_loss:
                criterion.increment_weights()
            train_loss.append(epoch_loss)
            train_acc.append(epoch_acc)
            if classify:
                train_class.append(epoch_class)
            if inepoch_plot:
                plt.title(('Training Loss per batch, EPOCH: ' + str((epoch + 1))))
                plt.xlabel('Batch')
                plt.ylabel(loss_name)
                plt.plot(range(len(loss_per_batch)), loss_per_batch, 'b*-', label='Train')
                plt.show()
        elif (phase == 'validation'):
            val_loss.append(epoch_loss)
            val_acc.append(epoch_acc)
            if classify:
                val_class.append(epoch_class)
        else:
            raise ValueError('WRONG PHASE NAME, check folder names?')
        print(('{} {}: {:.4f} {}: {:.4f} '.format(phase, loss_name, epoch_loss, metric_name, epoch_acc) + (classify * 'Class ACC: {:.4f}'.format(epoch_class))))
        if (phase == 'validation'):
            if ((epoch_acc > best_acc) or (epoch_class > best_acc)):
                if (patience != 0):
                    patience_count = 0
                print('Best model so far, checkpoint...')
                best_acc = (epoch_acc if (epoch_acc > best_acc) else epoch_class)
                torch.save(model.state_dict(), os.path.join(savefolder, (model_name + '.pt')))
                best_model_wts = copy.deepcopy(model.state_dict())
            elif (patience != 0):
                patience_count += 1
                print('Patience {}/{}...'.format(patience_count, patience))
                if (patience_count >= patience):
                    print('{} epochs without improvement, ending training.'.format(patience_count))
                    raise KeyboardInterrupt('Patience interrupt')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex import amp
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if isinstance(model, ElectraForMaskedLM):
    name = name.replace('electra/embeddings/', 'generator/embeddings/')
if (discriminator_or_generator == 'generator'):
    name = name.replace('electra/', 'discriminator/')
    name = name.replace('generator/', 'electra/')
name = name.replace('dense_1', 'dense_prediction')
name = name.replace('generator_predictions/output_bias', 'generator_lm_head/bias')
name = name.split('/')
if any(((n in ['global_step', 'temperature']) for n in name)):
    logger.info('Skipping {}'.format(original_name))
    continue
pointer = model
for m_name in name:
    if re.fullmatch('[A-Za-z]+_\\d+', m_name):
        scope_names = re.split('_(\\d+)', m_name)
    else:
        scope_names = [m_name]
    if ((scope_names[0] == 'kernel') or (scope_names[0] == 'gamma')):
        pointer = getattr(pointer, 'weight')
    elif ((scope_names[0] == 'output_bias') or (scope_names[0] == 'beta')):
        pointer = getattr(pointer, 'bias')
    elif (scope_names[0] == 'output_weights'):
        pointer = getattr(pointer, 'weight')
    elif (scope_names[0] == 'squad'):
        pointer = getattr(pointer, 'classifier')
    else:
        pointer = getattr(pointer, scope_names[0])
    if (len(scope_names) >= 2):
        num = int(scope_names[1])
        pointer = pointer[num]
if m_name.endswith('_embeddings'):
    pointer = getattr(pointer, 'weight')
elif (m_name == 'kernel'):
    array = np.transpose(array)
try:
    assert (pointer.shape == array.shape), f'Pointer shape {pointer.shape} and array shape {array.shape} mismatched'
except AssertionError as e:
    e.args += (pointer.shape, array.shape)
    raise
print('Initialize PyTorch weight {}'.format(name), original_name)
pointer.data = torch.from_numpy(array)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return send_file('prosobeast.csv', as_attachment=True, attachment_filename='prosobeast.csv', mimetype='text/csv')
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (not os.path.isdir(video_path)):
    os.makedirs(video_path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
y = tensor.DimShuffle((False,), (0, 0))(x)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
resolved_vocab_files = {}
for (file_id, file_path) in vocab_files.items():
    if (file_path is None):
        resolved_vocab_files[file_id] = None
    else:
        resolved_vocab_files[file_id] = cached_path(file_path, cache_dir=cache_dir, force_download=force_download, proxies=proxies)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from .convert_xlnet_checkpoint_to_pytorch import convert_xlnet_checkpoint_to_pytorch
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
model = model_mappings[method](config['n_class']).cuda()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
text_a = line[q1_index]
text_b = line[q2_index]
label = (None if test_mode else line[5])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
mu -= torch.Tensor(noise).to(self.device)
",0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (pointer.shape == array.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return self.idxToLabel[idx]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return list(map(type, x))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
results = evaluate(args, valid_dataset, model, tokenizer)
break
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
generated_sequence = generated_sequence[:generated_sequence.index(tokenizer.eos_token_id)]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
return int(value)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
ret.pred_masks = [predictions[i]['segmentation'] for i in chosen]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
while True:
    (action, kwargs) = input_pipe.recv()
    action_fn = getattr(self, action)
    return_pipe.send(action_fn(rank, device_id, **kwargs))
",0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
my_module = importlib.import_module(module_name)
my_module.download(datapath)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
dtype = x.dtype
type_ = dtype.type
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import re
import numpy as np
import tensorflow as tf
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.unlink('latest_log_dir')
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import sentencepiece as spm
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
smile = Chem.MolToSmiles(mol)
if ((smile is not None) and (smile not in smile_set)):
    smile_set.add(smile)
    new_population.append(mol)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
_call_with_frames_removed(import_, from_name)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
sample_data(n_channels=n_channels, decays=(decays + [0.5]), scales=scales, epoch_length=200, batch_size=2000, mode='test')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
model.load_state_dict(get_sd(args.models[0], args))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
_ = text.SlidingWindow(0, 0)
assert False
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
if (pointer.shape != array.shape):
    raise ValueError(f'Pointer shape {pointer.shape} and array shape {array.shape} mismatched')
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
class_names = MetadataCatalog.get(dataset_names[0]).thing_classes
check_metadata_consistency('thing_classes', dataset_names)
print_instances_class_histogram(dataset_dicts, class_names)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
setattr(self, key, value)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if ((version[0] == 0) and (version[1] <= 10) and (version[2] == 0)):
    m = re.search('values_block_(\\d+)', name)
    if m:
        grp = m.groups()[0]
        name = f'values_{grp}'
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
xshape = node.fgraph.shape_feature.shape_of[x]
ushape = node.fgraph.shape_feature.shape_of[u]
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
face_detector = configs['face_detector']
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
shelf = OfflineDatasetFile.cache.pop(self._file_name)
OfflineDatasetFile.cache[self._file_name] = shelf
return shelf
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
get_ipython = sys.modules['IPython'].get_ipython
if ('IPKernelApp' not in get_ipython().config):
    raise ImportError('console')
if ('VSCODE_PID' in os.environ):
    raise ImportError('vscode')
return (importlib.util.find_spec('IPython') is not None)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_vocab_files = {}
for (file_id, file_path) in vocab_files.items():
    if (file_path is None):
        resolved_vocab_files[file_id] = None
    else:
        resolved_vocab_files[file_id] = cached_path(file_path, cache_dir=cache_dir, force_download=force_download, proxies=proxies, resume_download=resume_download)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(scores, indices, states) = simScoreNext(template_vec, word_list, ee, prevs_state=bu.elmo_state, batch_size=batch_size, prevs_align=(bu.align_loc if mono else None), normalized=normalized, elmo_layer=elmo_layer)
scores_logprob = F.log_softmax(scores, dim=0)
sim_cum_logprob = (scores_logprob + torch.tensor(bu.sim_score, dtype=torch.float, device=self.device))
sim_cum_allbeam = (sim_cum_logprob if (sim_cum_allbeam is None) else torch.cat([sim_cum_allbeam, sim_cum_logprob]))
indices_allbeam = (indices if (indices_allbeam is None) else torch.cat([indices_allbeam, indices]))
states_allbeam = (states_allbeam + states)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return cls(s)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0
"
input_str = input_str.encode('utf8')
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
value = self._data_frame.loc[label_number][key]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from fairseq.model_parallel.megatron.mpu import get_model_parallel_rank, initialize_model_parallel, model_parallel_cuda_manual_seed
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
xn = vconv.input_range(vc, vc, y)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
mat = sio.loadmat(filepath)
targets = None
if targets_key:
    targets = mat[targets_key]
return (mat[sequence_key], targets)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
import instaboostfast as instaboost
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
base_value = inherited_dict[name]
if (value is base_value):
    to_remove.append(name)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from subword_nmt import apply_bpe
bpe_parser = apply_bpe.create_parser()
bpe_args = bpe_parser.parse_args(['--codes', codes, '--separator', args.bpe_separator])
self.bpe = apply_bpe.BPE(bpe_args.codes, bpe_args.merges, bpe_args.separator, None, bpe_args.glossaries)
self.bpe_symbol = (bpe_args.separator + ' ')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
n = int(input('type a number: '))
selected_file_path = pth_files_paths[n]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
prepare_fields_transforms(opt)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0
"
resolved_vocab_files = {}
for (file_id, file_path) in vocab_files.items():
    if (file_path is None):
        resolved_vocab_files[file_id] = None
    else:
        resolved_vocab_files[file_id] = cached_path(file_path, cache_dir=cache_dir, force_download=force_download, proxies=proxies, resume_download=resume_download, local_files_only=local_files_only)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import re
import numpy as np
import tensorflow as tf
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import apex.optimizers
if (self.options.optimizer == 'apex_adam'):
    optimizer = apex.optimizers.FusedAdam
elif (self.options.optimizer == 'apex_lamb'):
    optimizer = apex.optimizers.FusedLAMB
else:
    optimizer = apex.optimizers.FusedSGD
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_archive_file = cached_path(archive_file, cache_dir=cache_dir, force_download=force_download, proxies=proxies, resume_download=resume_download, local_files_only=local_files_only, use_auth_token=use_auth_token, user_agent=user_agent)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
_CONFIG_VARS['abiflags'] = sys.abiflags
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
rho = (rhonum / rhoden)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1
"
mdl = importlib.import_module(('.' + module_name), 'fastmri.transforms')
classobj = getattr(mdl, class_name)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
exp_path = exp
params_json_path = os.path.join(exp_path, 'params.json')
variant_json_path = os.path.join(exp_path, 'variant.json')
progress_csv_path = os.path.join(exp_path, 'progress.csv')
progress = load_progress(progress_csv_path)
if disable_variant:
    params = load_params(params_json_path)
else:
    try:
        params = load_params(variant_json_path)
    except IOError:
        params = load_params(params_json_path)
exps_data.append(ext.AttrDict(progress=progress, params=params, flat_params=flatten_dict(params)))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex.parallel import DistributedDataParallel as DDP
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
server_id = 0
machine_id = 0
lines = [line.rstrip('\n') for line in open(filename)]
for line in lines:
    result = line.split()
    if (len(result) == 2):
        port = int(result[1])
    elif (len(result) == 1):
        port = DEFUALT_PORT
    else:
        raise RuntimeError('length of result can only be 1 or 2.')
    ip_addr = result[0]
    for s_count in range(num_servers):
        server_namebook[server_id] = [machine_id, ip_addr, (port + s_count), num_servers]
        server_id += 1
    machine_id += 1
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(yield next(result_source))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
f = (((2.0 * p) * r) / (p + r))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1
"
os.makedirs(log_path)
",0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(line, field) = line.rstrip().rsplit(' ', 1)
if (field == '#fairseq:overwrite'):
    overwrite = True
    (line, field) = line.rsplit(' ', 1)
else:
    overwrite = False
count = int(field)
word = line
if ((word in self) and (not overwrite)):
    raise RuntimeError(""Duplicate word found when loading Dictionary: '{}'. Duplicate words can overwrite earlier ones by adding the #fairseq:overwrite flag at the end of the corresponding row in the dictionary file. If using the Camembert model, please download an updated copy of the model file."".format(word))
self.add_symbol(word, n=count, overwrite=overwrite)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
import _manylinux
return bool(getattr(_manylinux, (name + '_compatible')))
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
my_module = importlib.import_module(module_name)
world_class = getattr(my_module, world_name)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
next(module.parameters())
return True
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import instaboostfast as instaboost
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
value_f1 = (((2 * prec) * rec) / (prec + rec))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1
"
return comm.Get_rank()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (not self._module.batch_first):
    raise ConfigurationError('Our encoder semantics assumes batch is always first!')
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
repo_dpath = dirname(dirname(__file__))
repo_dpath = join(repo_dpath, '..')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
tmp = Variable(torch.LongTensor([int(self.rel2id[relation_id])]))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
character = entity.character
return 'a Sprite or Drape handling character {}'.format(repr(character))
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.remove(input_path)
os.remove(output_path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
for _ in range(N_tries):
    (obj, pose) = self.place_in_room(i, j, Floor(level_0_cp[c][1]))
    room = self.get_room(i, j)
    offsets = [((- 1), (- 1)), (0, (- 1)), (1, (- 1)), ((- 1), 0), (1, 0), ((- 1), 1), (0, 1), (1, 1)]
    flag = 0
    for offset in offsets:
        n_pose = (pose + offset)
        tar = self.grid.get(*n_pose)
        if (tar is not None):
            if ((tar.type is 'floor') and (tar.color in contig_colors)):
                flag += 1
            elif (tar.type is 'door'):
                flag += 2
    if (flag > 1):
        self.grid.set(pose[0], pose[1], None)
        room.objs.pop((- 1))
    else:
        break
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
future_mask = future_mask.bool()
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import jieba
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (self.args.distributed_world_size > 1):
    if (i < (len(samples) - 1)):
        self.model.accumulate_grads = True
    else:
        self.model.accumulate_grads = False
(loss, sample_size, logging_output) = self.task.train_step(sample, self.model, self.criterion, self.optimizer, ignore_grad)
if (not ignore_grad):
    logging_outputs.append(logging_output)
    sample_sizes.append(sample_size)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with open(manifest_in, 'r') as f:
    for line in f:
        if line.startswith('include '):
            for include in line.split()[1:]:
                simple_includes.add(include)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(image1_name, image2_name, mask_name) = did.strip('\n').split(' ')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
while True:
    losses = []
    corrects = []
    for loader in loaders:
        (data, label) = next(loader)
        (data, label) = (data.cuda(), label.cuda())
        pred = model(data)
        loss = loss_fn(pred, label)
        losses.append(loss.detach().cpu().numpy())
        (_, pred) = pred.topk(1, 1, True, True)
        pred = pred.t()
        correct = pred.eq(label.view(1, (- 1)).expand_as(pred)).detach().cpu().numpy()
        corrects.append(correct)
        del loss, correct, pred, data, label
    losses = np.concatenate(losses)
    losses_min = np.min(losses, axis=0).squeeze()
    corrects = np.concatenate(corrects)
    corrects_max = np.max(corrects, axis=0).squeeze()
    metrics.add_dict({'minus_loss': ((- 1) * np.sum(losses_min)), 'correct': np.sum(corrects_max), 'cnt': len(corrects_max)})
    del corrects, corrects_max
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
res = solve(linop, B)
assert False, 'A RuntimeError must be raised if the A linear operator in solve not square'
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (self.args.is_tpu or self.args.torchscript):
    logger.info('Do inference on TPU or torchscript. Running model 5 times to stabilize compilation')
    timeit.repeat(func, repeat=1, number=5)
runtimes = timeit.repeat(func, repeat=self.args.repeat, number=10)
if (self.args.is_tpu and self.args.torch_xla_tpu_print_metrics):
    import torch_xla.debug.metrics as met
    self.print_fn(met.metrics_report())
return (min(runtimes) / 10.0)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import moviepy
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import ftfy
from spacy.lang.en import English
_nlp = English()
self.nlp = _nlp.Defaults.create_tokenizer(_nlp)
self.fix_text = ftfy.fix_text
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
logging.debug('Try to load dataset as multi-label-images')
(train_ds, val_ds, test_ds) = multi_label_image_folder_dataset.load_dataset(dataset_folder, inmem, workers)
(mean, std) = _load_mean_std_from_file(dataset_folder, inmem, workers, kwargs['runner_class'])
logging.debug('Setting up dataset transforms')
transform = transforms.Compose([transforms.Resize(model_expected_input_size), transforms.ToTensor(), transforms.Normalize(mean=mean, std=std)])
train_ds.transform = transform
val_ds.transform = transform
test_ds.transform = transform
(train_loader, val_loader, test_loader) = _dataloaders_from_datasets(batch_size, train_ds, val_ds, test_ds, workers)
logging.info('Dataset loaded as images')
_verify_dataset_integrity(dataset_folder, disable_dataset_integrity, enable_deep_dataset_integrity)
return (train_loader, val_loader, test_loader, len(train_ds.classes))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex import amp
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
n = len(res_dict[x])
for i in range(n):
    try:
        ll = len(res_dict[x][i])
        for j in range(ll):
            flattened_dict[((((x + '_') + str(i)) + '_') + str(j))] = int(res_dict[x][i][j])
    except:
        flattened_dict[((x + '_') + str(i))] = float(res_dict[x][i])
        pass
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
sample[k] = ds.collater([s[k] for s in samples])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import numpy as np
import tensorflow as tf
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return datetime.strptime(t[0], fmt).date()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
os.mkdir(self.exp_dir)
os.mkdir(self.log_dir)
os.mkdir(self.checkpoint_dir)
os.mkdir(self.sample)
os.mkdir(self.web)
os.mkdir(self.img)
os.mkdir(self.test_dir)
print(('Creating: %s\n          %s\n          %s\n          %s\n          %s' % (self.exp_dir, self.log_dir, self.sample, self.checkpoint_dir, self.test_dir)))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
scores = [x['score'] for x in sinfo]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
write(local_struct_pack(format, element))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0
"
with open(cls.path_token, 'r') as f:
    return f.read()
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.translator = build_translator(self.opt, report_score=False, out_file=open(os.devnull, 'w'))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import re
import numpy as np
import tensorflow as tf
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
loss = F.binary_cross_entropy_with_logits(logits, labels.type(torch.cuda.FloatTensor))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
l1_regularizer = Net_l1_regularizer(scale)
l1_regularizer(weights)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
batch = [_pooled_next(iters[i], pool[i]) for i in indices[:self.batch_size]]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
out = common_lib.get_command_stdout('nnet3-info {0} | head -4 '.format(input_model))
for line in out.split('\n'):
    parts = line.split(':')
    if (len(parts) != 2):
        continue
    if (parts[0].strip() == 'left-context'):
        variables['model_left_context'] = int(parts[1].strip())
    elif (parts[0].strip() == 'right-context'):
        variables['model_right_context'] = int(parts[1].strip())
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
cpu_sum = float(x.float().sum())
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return self._data._unbox_scalar(key)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
host = ifaddresses(nic_name).setdefault(AF_INET, [{'addr': 'No IP addr'}])[0]['addr']
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0
"
checkpoint_suffix = args.model_name_or_path.split('-')[(- 1)].split('/')[0]
global_step = int(checkpoint_suffix)
epochs_trained = (global_step // (len(train_dataloader) // args.gradient_accumulation_steps))
steps_trained_in_current_epoch = (global_step % (len(train_dataloader) // args.gradient_accumulation_steps))
logger.info('  Continuing training from checkpoint, will skip to saved global_step')
logger.info('  Continuing training from epoch %d', epochs_trained)
logger.info('  Continuing training from global step %d', global_step)
logger.info('  Will skip the first %d steps in the first epoch', steps_trained_in_current_epoch)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
img = render_single_obj(obj.as_posix(), False)
cv2.imwrite((out_dir / obj.with_suffix('.png').name).as_posix(), cv2.cvtColor(img, cv2.COLOR_RGB2BGR))
orig_img = render_single_obj(ground_truth_path, True)
cv2.imwrite((out_dir / 'ground_truth.png').as_posix(), cv2.cvtColor(orig_img, cv2.COLOR_RGB2BGR))
for csg in tqdm.tqdm(list((((shapes / object_name) / instance_name) / 'csg_path').glob('*.obj'))):
    (out_dir / 'csg_path').mkdir(exist_ok=True)
    img = render_single_obj(csg.as_posix(), False)
    cv2.imwrite(((out_dir / 'csg_path') / csg.with_suffix('.png').name).as_posix(), cv2.cvtColor(img, cv2.COLOR_RGB2BGR))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
with h5py.File(hdf5_path, 'w') as f:
    dtype = h5py.special_dtype(vlen='uint8')
    video = f.create_dataset('video', (len(list(dst_dir_path.glob('*.jpg'))),), dtype=dtype)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
batch_size = batch.size
(targets, outputs) = self.autoencoder(batch)
loss_data = self.loss_function(outputs, targets.data)
if (self.auto_encoder_type == 'Variational'):
    m = self.autoencoder.variational_layer.mean
    std = self.autoencoder.variational_layer.std
    m = m.mul(m)
    one = torch.ones(m.size())
    if m.is_cuda:
        one = one.cuda()
    var_loss = ((((m + std) - std.log()) - one) * 0.5).sum()
    report_mse += loss_data.item()
    report_kl += var_loss.item()
    report_mu += m.sum().item()
    report_sig += std.sum().item()
    report_el += m.numel()
    loss_data = (loss_data + var_loss)
loss_data.backward()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import cityscapesscripts.evaluation.evalInstanceLevelSemanticLabeling as CSEval
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import revtok
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (pointer.shape == array.shape), f'Pointer shape {pointer.shape} and array shape {array.shape} mismatched'
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from tensorboardX import SummaryWriter
self.SummaryWriter = SummaryWriter
self._writers = {}
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(tree, last_idx) = _unflatten(0)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
message = console.read()
ws.send(message)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (excess_storage and (random.random() < remove_random_chance)):
    continue
base_names = [os.path.basename(fname)[:11] for fname in audio_comb]
if (len(base_names) != len(set(base_names))):
    continue
if audio_set:
    noise_input = sample_audio_set()
    noises.append(':'.join(noise_input))
    audio_comb = (*audio_comb, *noise_input)
audio_inputs.append(audio_comb)
video_inputs.append(tuple((os.path.join(VIDEO_DIR, (retrieve_name(f) + video_ext)) for f in audio_comb)))
audio_mix_input = ''
for audio in audio_comb:
    audio_mix_input += f'-i {audio} '
mixed_audio_name = os.path.join(MIXED_AUDIO_DIR, f'{(indx + offset)}{audio_ext}')
audio_command = (((AUDIO_MIX_COMMAND_PREFIX + audio_mix_input) + audio_mix_command_suffix.format(len(audio_comb))) + mixed_audio_name)
process = subprocess.Popen(audio_command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
mixed_audio.append(mixed_audio_name)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
version = getattr(self, 'version', None)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
from fairscale.nn import Pipe
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
p = subprocess.run(['nvidia-smi', '-L'], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
real_image = next(data_loader)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import lvis
assert (lvis.__version__ >= '10.5.3')
from lvis import LVIS
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(src_idx, tgt_idx) = align.split('-')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
return im.resize(new_size, resample=PIL.Image.LANCZOS)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex import amp
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from convert_gpt2_original_tf_checkpoint_to_pytorch import convert_gpt2_checkpoint_to_pytorch
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
j = word.index(first, i)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
original_format = np.array(Image.open(os.path.join(source_folder, file_name)), dtype=np.uint32)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
shutil.copy2(infile, outfile)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(args.outpath)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
type_declaration = self.parse_type_declaration()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import apex
apex.amp.register_half_function(torch, 'einsum')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(model_dir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
obj = float(obj)
return (0.0 <= obj <= 1.0)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
return {'dropout': MPNDropoutModel, 'twooutput': MPNTwoOutputModel, 'mve': MPNTwoOutputModel, 'none': MPNModel}.get(conf_method, 'none')(conf_method=conf_method, **kwargs)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
module = importlib.import_module(module_name)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
input_values = [var.x for var in self._input_variables.select()]
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
first_el = next(chunk_it)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
for epoch in range(1, (args.epochs + 1)):
    epoch_start_time = time.time()
    train(model, train_loader, loss_fn, args.batch_size, args.cuda)
    (_, val_loss) = evaluate(model, valid_loader, loss_fn)
    if (val_loss < best_val_loss):
        best_val_loss = val_loss
        best_model = copy.deepcopy(model)
    print(('-' * 89))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from transformers import load_tf2_checkpoint_in_pytorch_model
model = load_tf2_checkpoint_in_pytorch_model(model, resolved_archive_file, allow_missing_keys=True)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (hasattr(numpy.distutils, '__config__') and numpy.distutils.__config__):
    blas_info = numpy.distutils.__config__.blas_opt_info
else:
    import numpy.distutils.system_info
    with warnings.catch_warnings(record=True):
        numpy.distutils.system_info.system_info.verbosity = 0
        blas_info = numpy.distutils.system_info.get_info('blas_opt')
if ('EPD' in sys.version):
    use_unix_epd = True
    if (sys.platform == 'win32'):
        return ' '.join(([('-L%s' % os.path.join(sys.prefix, 'Scripts'))] + [('-l%s' % l) for l in ['mk2_core', 'mk2_intel_thread', 'mk2_rt']]))
    elif (sys.platform == 'darwin'):
        new_path = os.path.join(sys.prefix, 'lib')
        v = os.getenv('DYLD_FALLBACK_LIBRARY_PATH', None)
        if (v is not None):
            v = os.path.realpath(v)
        if ((v is None) or (new_path not in v.split(':'))):
            _logger.warning((""The environment variable 'DYLD_FALLBACK_LIBRARY_PATH' does not contain the '%s' path in its value. This will make Theano use a slow version of BLAS. Update 'DYLD_FALLBACK_LIBRARY_PATH' to contain the said value, this will disable this warning."" % new_path))
            use_unix_epd = False
    if use_unix_epd:
        return ' '.join(([('-L%s' % os.path.join(sys.prefix, 'lib'))] + [('-l%s' % l) for l in blas_info['libraries']]))
if ('Canopy' in sys.prefix):
    subsub = 'lib'
    if (sys.platform == 'win32'):
        subsub = 'Scripts'
    lib_path = os.path.join(sys.base_prefix, subsub)
    if (not os.path.exists(lib_path)):
        p = os.path.join(sys.base_prefix, '..', '..', 'appdata')
        assert os.path.exists(p), 'Canopy changed the location of MKL'
        lib_paths = os.listdir(p)
        for sub in lib_paths:
            if (not os.path.exists(os.path.join(p, sub, subsub))):
                lib_paths.remove(sub)
        assert (len(lib_paths) == 1), ('Unexpected case when looking for Canopy MKL libraries', p, lib_paths, [os.listdir(os.path.join(p, sub)) for sub in lib_paths])
        lib_path = os.path.join(p, lib_paths[0], subsub)
        assert os.path.exists(lib_path), 'Canopy changed the location of MKL'
    if ((sys.platform == 'linux2') or (sys.platform == 'darwin')):
        return ' '.join(([('-L%s' % lib_path)] + [('-l%s' % l) for l in blas_info['libraries']]))
    elif (sys.platform == 'win32'):
        return ' '.join(([('-L%s' % lib_path)] + [('-l%s' % l) for l in ['mk2_core', 'mk2_intel_thread', 'mk2_rt']]))
if (('Anaconda' in sys.version) and (sys.platform == 'win32')):
    try:
        import mkl
    except ImportError as e:
        _logger.info('Conda mkl is not available: %s', e)
    else:
        lib_path = os.path.join(sys.prefix, 'DLLs')
        flags = [('-L%s' % lib_path)]
        flags += [('-l%s' % l) for l in ['mkl_core', 'mkl_intel_thread', 'mkl_rt']]
        res = try_blas_flag(flags)
        if res:
            return res
ret = (([('-L%s' % l) for l in blas_info.get('library_dirs', [])] + [('-l%s' % l) for l in blas_info.get('libraries', [])]) + blas_info.get('extra_link_args', []))
if any((('mkl' in fl) for fl in ret)):
    ret.extend(['-lm', '-lm'])
res = try_blas_flag(ret)
if res:
    return res
ret.extend([('-Wl,-rpath,' + l) for l in blas_info.get('library_dirs', [])])
res = try_blas_flag(ret)
if res:
    return res
if ((('Anaconda' in sys.version) or ('Continuum' in sys.version)) and ('linux' in sys.platform)):
    lib_path = os.path.join(sys.prefix, 'lib')
    ret.append(('-Wl,-rpath,' + lib_path))
    res = try_blas_flag(ret)
    if res:
        return res
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_archive_file = cached_path(archive_file, cache_dir=cache_dir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import re
import numpy as np
import tensorflow as tf
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
while True:
    read_input = connection_read_fn()
    with DelaySignalHandling():
        if (len(read_input) == 3):
            (sampler_index, command, data) = read_input
            assert (command != CLOSE_COMMAND), 'Must close all processes at once.'
            assert (command != RESUME_COMMAND), 'Must resume all task samplers at once.'
            if (command == PAUSE_COMMAND):
                sp_vector_sampled_tasks.pause_at(sampler_index=sampler_index)
                connection_write_fn('done')
            else:
                connection_write_fn(sp_vector_sampled_tasks.command_at(sampler_index=sampler_index, command=command, data=data))
        else:
            (commands, data_list) = read_input
            assert (commands != PAUSE_COMMAND), 'Cannot pause all task samplers at once.'
            if (commands == CLOSE_COMMAND):
                sp_vector_sampled_tasks.close()
                break
            elif (commands == RESUME_COMMAND):
                sp_vector_sampled_tasks.resume_all()
                connection_write_fn('done')
            else:
                if isinstance(commands, str):
                    commands = ([commands] * sp_vector_sampled_tasks.num_unpaused_tasks)
                connection_write_fn(sp_vector_sampled_tasks.command(commands=commands, data_list=data_list))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.mdp_prob_dict.pop(mdp)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
while True:
    (cmd, data) = pipe.recv()
    if (cmd == 'reset'):
        pipe.send(_write_obs(env.reset()))
    elif (cmd == 'step'):
        (obs, reward, done, info) = env.step(data)
        if done:
            obs = env.reset()
        pipe.send((_write_obs(obs), reward, done, info))
    elif (cmd == 'render'):
        pipe.send(env.render(mode='rgb_array'))
    elif (cmd == 'close'):
        pipe.send(None)
        break
    else:
        raise RuntimeError(('Got unrecognized cmd %s' % cmd))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self._word_vecs = init_fn(size=[len(vocab), self._hparams.dim], **init_fn_kwargs)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
pointer = getattr(pointer, scope_names[0])
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.fsync(self.file_handle.fileno())
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
future_mask = future_mask.bool()
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self._control_local_metrics(disabled=True)
loss = (0 * self.compute_loss(self._dummy_batch(batchsize, maxlen)))
self._control_local_metrics(enabled=True)
self._temporarily_disable_local_metrics = False
self.backward(loss)
self.buffer_initialized = True
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return theano.tensor.basic.pow(self, other)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
obj = load_back(mod, name)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_archive_file = cached_path(archive_file, cache_dir=cache_dir, force_download=force_download, proxies=proxies, resume_download=resume_download, local_files_only=local_files_only)
if (resolved_archive_file is None):
    raise EnvironmentError
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(_loss, sample_size, logging_output) = self.task.valid_step(sample, self.model, self.criterion)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.agent.save(filename=(permanent_folder / 'latest.tar'))
episode_path = self.agent.save(filename=episode_path)
if episode_path:
    logger.info('Saved {} model to {}'.format(self.agent.__class__.__name__, episode_path))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import re
import numpy as np
import tensorflow as tf
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (b'nd' in obj):
    if (obj[b'nd'] is True):
        if ((b'kind' in obj) and (obj[b'kind'] == b'V')):
            descr = [tuple(((tostr(t) if (type(t) is bytes) else t) for t in d)) for d in obj[b'type']]
        else:
            descr = obj[b'type']
        return np.frombuffer(obj[b'data'], dtype=np.dtype(descr)).reshape(obj[b'shape'])
    else:
        descr = obj[b'type']
        return np.frombuffer(obj[b'data'], dtype=np.dtype(descr))[0]
elif (b'complex' in obj):
    return complex(tostr(obj[b'data']))
else:
    return (obj if (chain is None) else chain(obj))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(message, payload) = self._conn.recv()
",0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
evaluate_on_slice(train_slice[:5000], slice_label='Train subset')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
return bpe.is_beginning_of_word(tok)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
os.makedirs(result)
usable = True
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
try:
    label = np.loadtxt(label_path, dtype='str', delimiter=' ').reshape(((- 1), 16))
except:
    label = np.loadtxt(label_path, dtype='str', delimiter=' ').reshape(((- 1), 15))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from habitat.datasets.object_nav.object_nav_dataset import ObjectNavDatasetV1
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex import amp
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from tokenizers import ByteLevelBPETokenizer
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
systematics_names = file['systematics/names'][()]
systematics_types = file['systematics/types'][()]
systematics_values = file['systematics/values'][()]
systematics_scales = file['systematics/scales'][()]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
v = torch.tensor(v)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0
"
import unidic
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
raw_data['dets'][t] = np.atleast_2d(time_data[:, 2:6])
raw_data['ids'][t] = np.atleast_1d(time_data[:, 1]).astype(int)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_vocab_files = {}
for (file_id, file_path) in vocab_files.items():
    if (file_path is None):
        resolved_vocab_files[file_id] = None
    else:
        resolved_vocab_files[file_id] = cached_path(file_path, cache_dir=cache_dir, force_download=force_download, proxies=proxies, resume_download=resume_download, local_files_only=local_files_only)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
vector = model[word]
embeddings[index] = vector
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
batch = next(iterator)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(missing_keys, unexpected_keys) = load_tf_weights(model, resolved_archive_file)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
fd = self._selector._fileobj_lookup(fileobj)
return self._selector._fd_to_key[fd]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
mask_color = [(x / 255) for x in self.metadata.stuff_colors[category_idx]]
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
benchmark_args = parser.parse_args_into_dataclasses()[0]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
from fairseq.fb_pathmgr import fb_pathmgr
global fb_pathmgr_registerd
if (not fb_pathmgr_registerd):
    fb_pathmgr.register()
    fb_pathmgr_registerd = True
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(_, valid_loader_kwargs) = load_numpy(args.chunks, args.directory)
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
trees = list(grammar.cfg_parser.parse(sent))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
model.encoder.load_state_dict(params['encoder_state_dict'])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_vocab_file = cached_path(vocab_file, cache_dir=cache_dir)
resolved_merges_file = cached_path(merges_file, cache_dir=cache_dir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with open(cls.path_token, 'r') as f:
    return f.read()
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
tensorized_scalar = torch.Tensor(scalars).cuda()
output_tensors = [tensorized_scalar.clone() for _ in range(torch.distributed.get_world_size())]
torch.distributed.all_gather(output_tensors, tensorized_scalar)
concat = torch.cat(output_tensors, dim=0)
if (num_total_examples is not None):
    concat = concat[:num_total_examples]
return concat
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return (self.network == other.network)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
output_batch = ([], [])
for _ in range(self.num_device):
    batch = next(data_iter)
    for (i, v) in enumerate(batch):
        output_batch[i].append(v[None])
(yield (torch.cat(_, dim=0) for _ in output_batch))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex import amp
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
ver = check_output([cc, '--version']).decode('utf-8')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0
"
import torch
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import re
import numpy as np
import tensorflow as tf
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (model.tokens_embed.weight.shape == init_params[1].shape)
assert (model.positions_embed.weight.shape == init_params[0].shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
_valid_extensions = set(val.split(','))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
os.mkdir(dir_checkpoint)
logging.info('Created checkpoint directory')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self._base_f = sde.f
self._base_g = sde.g
self._base_h = sde.h
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
full_filenames = [os.path.join(dirpath, fn) for fn in filenames]
dirsize = sum((os.path.getsize(fn) for fn in full_filenames))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
mask = int(string_network.split('/')[1])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
print(f'{key}: shape={value.shape}')
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
src_ind = src_word2ind[src]
trg_ind = trg_word2ind[trg]
validation[src_ind].add(trg_ind)
vocab.add(src)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
repo_dpath = dirname(dirname(__file__))
repo_dpath = join(repo_dpath, '..')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from petrel_client import client
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
wandb.run.id
initialized = True
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
joined = Parser.join(argv)
assert (argv == Parser.split(joined))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (not chunked):
    resp = conn.urlopen(method=request.method, url=url, body=request.body, headers=request.headers, redirect=False, assert_same_host=False, preload_content=False, decode_content=False, retries=self.max_retries, timeout=timeout)
else:
    if hasattr(conn, 'proxy_pool'):
        conn = conn.proxy_pool
    low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)
    try:
        low_conn.putrequest(request.method, url, skip_accept_encoding=True)
        for (header, value) in request.headers.items():
            low_conn.putheader(header, value)
        low_conn.endheaders()
        for i in request.body:
            low_conn.send(hex(len(i))[2:].encode('utf-8'))
            low_conn.send(b'\r\n')
            low_conn.send(i)
            low_conn.send(b'\r\n')
        low_conn.send(b'0\r\n\r\n')
        try:
            r = low_conn.getresponse(buffering=True)
        except TypeError:
            r = low_conn.getresponse()
        resp = HTTPResponse.from_httplib(r, pool=conn, connection=low_conn, preload_content=False, decode_content=False)
    except:
        low_conn.close()
        raise
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
instance = next(dataset)
instance.fields[self._dataset_field_name] = MetadataField(key)
(yield instance)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
f_iter = iter(field)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
resolved_corpus_file = cached_path(corpus_file, cache_dir=cache_dir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return int(v)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0
"
index = faiss.index_factory(10, 'PQ4')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return list(map(type, x))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
(rgb_face, AU_box_dict) = FaceMaskCropper.get_cropface_and_box(rgb_path, rgb_path, channel_first=True, mc_manager=self.mc_manager, key_prefix=key_prefix)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
src_input = input('\nPlease enter a source sentence (pre-processed): \n')
if (not src_input.strip()):
    break
test_data = _load_line_as_data(line=src_input)
hypotheses = _translate_data(test_data)
print('JoeyNMT: {}'.format(hypotheses[0]))
",0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
mode = int(arg, 16)
return mode
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
j = word.index(first, i)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
from .convert_transfo_xl_checkpoint_to_pytorch import convert_transfo_xl_checkpoint_to_pytorch
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
nlp = spacy_nlp()
spacy_tokenizer._tokenizer = nlp.Defaults.create_tokenizer(nlp)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
while (n_filled < self.bptt):
    if ((streams[i] is None) or (len(streams[i]) <= 1)):
        streams[i] = next(sent_stream)
    n_new = min((len(streams[i]) - 1), (self.bptt - n_filled))
    data[(n_retain + n_filled):((n_retain + n_filled) + n_new), i] = streams[i][:n_new]
    target[n_filled:(n_filled + n_new), i] = streams[i][1:(n_new + 1)]
    streams[i] = streams[i][n_new:]
    n_filled += n_new
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
setattr(self, key, value)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
plt.switch_backend(backend)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
nn.utils.remove_weight_norm(module)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
samples = h5file['samples'][orientation]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.remove((module_name + '.pyx'))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return fn(timeout)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
sequence += _symbols_to_sequence(_clean_text(text, cleaner_names))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
ip = get_ipython()
return ('zmq' in str(type(ip)).lower())
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
for e in range(self.nepochs):
    clock0 = time.time()
    self.train_epoch(t, xtrain, ytrain)
    clock1 = time.time()
    (train_loss, train_acc) = self.eval(t, xtrain, ytrain)
    clock2 = time.time()
    print('| Epoch {:3d}, time={:5.1f}ms/{:5.1f}ms | Train: loss={:.3f}, acc={:5.1f}% |'.format((e + 1), (((1000 * self.sbatch) * (clock1 - clock0)) / xtrain.size(0)), (((1000 * self.sbatch) * (clock2 - clock1)) / xtrain.size(0)), train_loss, (100 * train_acc)), end='')
    (valid_loss, valid_acc) = self.eval(t, xvalid, yvalid)
    print(' Valid: loss={:.3f}, acc={:5.1f}% |'.format(valid_loss, (100 * valid_acc)), end='')
    if (math.isnan(valid_loss) or math.isnan(train_loss)):
        print('saved best model and quit because loss became nan')
        break
    if (valid_loss < best_loss):
        best_loss = valid_loss
        best_model = copy.deepcopy(self.model.state_dict())
        patience = self.lr_patience
        print(' *', end='')
    else:
        patience -= 1
        if (patience <= 0):
            lr /= self.lr_factor
            print(' lr={:.1e}'.format(lr), end='')
            if (lr < self.lr_min):
                print()
                break
            patience = self.lr_patience
            params_dict = self.update_lr(is_first_itr, adaptive_lr=True, lr=lr)
            self.optimizer = BayesianSGD(params=params_dict)
    print()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
repo_dpath = dirname(dirname(__file__))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
model.set_params(model.prior.sample())
start_time = timer()
train(model, training_loader, optimizer, num_epochs, loss_fn=loss_fn, monitor_step=None, save_loss=False, save_metric=False, save_metric_mean=False, pred_fn=pred_fn, metric_fn=metric_fn)
end_time = timer()
runtime = (end_time - start_time)
if (validation_loader is not None):
    validation_output = model(validation_input)
    metric_val = metric_fn(pred_fn(validation_output), validation_target)
    accept = (True if check_fn(metric_val) else False)
else:
    accept = True
if accept:
    with open(Path(path).joinpath('solutions.csv'), 'a') as file:
        np.savetxt(file, model.get_params().cpu().detach().numpy()[np.newaxis], delimiter=',')
    with open(Path(path).joinpath('runtimes.txt'), 'a') as file:
        file.write('{}\n'.format(runtime))
    if (validation_loader is not None):
        with open(Path(path).joinpath('metric_vals.txt'), 'a') as file:
            file.write('{}\n'.format(metric_val))
    i = (i + 1)
    if verbose:
        print('Succeeded', end='')
else:
    j = (j + 1)
    if verbose:
        print('Failed due to not meeting quality metric', end='')
if verbose:
    if print_runtime:
        print('; runtime = {}'.format(timedelta(seconds=runtime)), end='')
    print('\n')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
mode = Split[mode]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from pretty import pretty
return pretty(obj, verbose=verbose)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return self.instance2index[instance]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs('images')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from .convert_gpt2_checkpoint_to_pytorch import convert_gpt2_checkpoint_to_pytorch
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.mkdir((('results/' + str(samples_per_class)) + '_samples_plots'))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return (rout['f2pyenhancements']['fortranname'] == '')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
j = word.index(first, i)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
os.makedirs(model_dir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
i = usecols.index(j)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
del reg[cid]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
fst_period_idx = words.index('.')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
t = biject_to(constraint)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
for epoch in range(opt.num_epochs):
    last_epoch = (step // num_iter_per_epoch)
    if (epoch < last_epoch):
        continue
    epoch_loss = []
    progress_bar = tqdm(training_generator)
    for (it, data) in enumerate(progress_bar):
        if (it < (step - (last_epoch * num_iter_per_epoch))):
            progress_bar.update()
            continue
        try:
            imgs = data['img']
            annot = data['annot']
            if (params.num_gpus == 1):
                imgs = imgs.cuda()
                annot = annot.cuda()
            global_validation_it += 1
            optimizer.zero_grad()
            (cls_loss, reg_loss) = model(imgs, annot)
            cls_loss = cls_loss.mean()
            reg_loss = reg_loss.mean()
            loss = (cls_loss + reg_loss)
            if ((loss == 0) or (not torch.isfinite(loss))):
                continue
            loss.backward()
            optimizer.step()
            epoch_loss.append(float(loss))
            progress_bar.set_description('Step: {}. Epoch: {}/{}. Iteration: {}/{}. Cls loss: {:.5f}. Reg loss: {:.5f}. Total loss: {:.5f}'.format(step, epoch, opt.num_epochs, (it + 1), num_iter_per_epoch, cls_loss.item(), reg_loss.item(), loss.item()))
            writer.add_scalars('Loss', {'train': loss}, step)
            writer.add_scalars('Regression_loss', {'train': reg_loss}, step)
            writer.add_scalars('Classfication_loss', {'train': cls_loss}, step)
            current_lr = optimizer.param_groups[0]['lr']
            writer.add_scalar('learning_rate', current_lr, step)
            step += 1
            if (((step % opt.save_interval) == 0) and (step > 0)):
                save_checkpoint(model, f'efficientdet-d{opt.compound_coef}_{epoch}_{step}.pth')
                print('checkpoint...')
        except Exception as e:
            print('[Error]', traceback.format_exc())
            print(e)
            continue
    scheduler.step(np.mean(epoch_loss))
    import time
    time.sleep(30)
    if ((epoch % opt.val_interval) == 0):
        model.eval()
        loss_regression_ls = []
        loss_classification_ls = []
        for (it, data) in enumerate(val_generator):
            with torch.no_grad():
                imgs = data['img']
                annot = data['annot']
                if (params.num_gpus == 1):
                    imgs = imgs.cuda()
                    annot = annot.cuda()
                if (it < 12):
                    plot_tensorboard(imgs, annot, model, writer, global_validation_it, it, '')
                    global_validation_it += 1
                if (params.num_gpus == 1):
                    imgs = imgs.cuda()
                    annot = annot.cuda()
                (cls_loss, reg_loss) = model(imgs, annot, obj_list=params.obj_list)
                cls_loss = cls_loss.mean()
                reg_loss = reg_loss.mean()
                loss = (cls_loss + reg_loss)
                if ((loss == 0) or (not torch.isfinite(loss))):
                    continue
                loss_classification_ls.append(cls_loss.item())
                loss_regression_ls.append(reg_loss.item())
        cls_loss = np.mean(loss_classification_ls)
        reg_loss = np.mean(loss_regression_ls)
        loss = (cls_loss + reg_loss)
        print('Val. Epoch: {}/{}. Classification loss: {:1.5f}. Regression loss: {:1.5f}. Total loss: {:1.5f}'.format(epoch, opt.num_epochs, cls_loss, reg_loss, loss))
        writer.add_scalars('Loss', {'val': loss}, step)
        writer.add_scalars('Regression_loss', {'val': reg_loss}, step)
        writer.add_scalars('Classfication_loss', {'val': cls_loss}, step)
        if ((loss + opt.es_min_delta) < best_loss):
            best_loss = loss
            best_epoch = epoch
            save_checkpoint(model, f'efficientdet-d{opt.compound_coef}_{epoch}_{step}.pth')
        model.train()
        if ((epoch - best_epoch) > opt.es_patience > 0):
            print('[Info] Stop training at epoch {}. The lowest loss achieved is {}'.format(epoch, best_loss))
            break
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
preds.remove(pred)
succs.remove(succ)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import unidic_lite
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
for (idx, batch) in enumerate(test_batch):
    if ((idx % 10) == 0):
        print('Idx: {}'.format(idx))
    (seq_len, batch_sz) = batch.size()
    if self.data.condition:
        seq_len -= 1
        bit = batch[0, :]
        batch = batch[1:, :]
        bit = GVar(bit)
    else:
        bit = None
    feed = self.data.get_feed(batch)
    if (self.args.swap > 1e-05):
        feed = swap_by_batch(feed, self.args.swap)
    if (self.args.replace > 1e-05):
        feed = replace_by_batch(feed, self.args.replace, self.model.ntoken)
    target = GVar(batch)
    (recon_loss, kld, aux_loss, tup, vecs, decoded) = self.model(feed, target, bit)
    bag = self.analyze_batch(target, kld, tup, vecs, decoded)
    sample_bag += bag
    acc_loss += ((recon_loss.data * seq_len) * batch_sz)
    acc_kl_loss += torch.sum(kld).data
    acc_aux_loss += torch.sum(aux_loss).data
    acc_avg_cos += tup['avg_cos'].data
    acc_avg_norm += tup['avg_norm'].data
    cnt += 1
    batch_cnt += batch_sz
    all_cnt += (batch_sz * seq_len)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
save_dir = AdjacentTempDirectory(path)
save_dir.create()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (pointer.shape == array.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return models.__dict__[configs['arch']]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return legend_handler_map[handle_type]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.flake8.exit()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0
"
assert (pointer.shape == array.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.set_shape(r, self.shape_tuple(r))
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
fd = open(file_or_fd, 'w')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
morphing_components = np.asarray(f['morphing/components'][()], dtype=np.int)
morphing_matrix = np.asarray(f['morphing/morphing_matrix'][()])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import numpy as np
import tensorflow as tf
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
sock = socket.socket(af, socktype, proto)
_set_socket_options(sock, socket_options)
if (timeout is not socket._GLOBAL_DEFAULT_TIMEOUT):
    sock.settimeout(timeout)
if source_address:
    sock.bind(source_address)
sock.connect(sa)
return sock
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import apex
apex.amp.register_half_function(torch, 'einsum')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
categorical_columns = [i for i in range(n_features) if (data.iloc[:, i].dtype == 'O')]
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import numpy as np
import tensorflow as tf
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
act = deepcopy(agents[0].act())
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import accimage
return accimage.Image(path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.loss = getattr(nn, self.hparams.loss)()
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with open(pickle_file, 'rb') as f:
    pickle_data = pickle.load(f)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0
"
os.makedirs(path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
frontend_contents = os.listdir(os.path.join(task_directory_path, 'frontend'))
if ('package.json' in frontend_contents):
    self.task_files_to_copy['needs_build'] = os.path.join(task_directory_path, 'frontend')
for dir in frontend_contents:
    if (dir in self.task_files_to_copy):
        for file_name in os.listdir(os.path.join(task_directory_path, 'frontend', dir)):
            self.task_files_to_copy[dir].append(os.path.join(task_directory_path, 'frontend', dir, file_name))
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
value = int(s)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
import re
import numpy as np
import tensorflow as tf
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
number = int(word)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
self.sent_tok = nltk.data.load(st_path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
speed: float = ((self.frequent * self.batch_size) / (time.time() - self.tic))
speed_total = (speed * self.world_size)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1
"
from fairseq import libnat_cuda
return (libnat_cuda, True)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return int(val)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
resolved_corpus_file = cached_path(corpus_file, cache_dir=cache_dir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
torch.save(ckpt, ckpt_path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
real_image = next(self.iterator)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
_FUNCTION_HASHES[self.func] = func_hash
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
print('Loading Adam weights')
optimizer_dict = torch.load(optimizer_load_path)
self.model_optimizer.load_state_dict(optimizer_dict)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
pointer = getattr(pointer, m_name)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (store is not None):
    store.close()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
_ = NoOp().summary
self.fail('summary did not fail')
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (pointer.shape == array.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
significand = tup[0].rstrip('0').rstrip(decimal_point)
sign = tup[1][0].replace(positive_sign, '')
exponent = tup[1][1:].lstrip('0')
if (self._useMathText or self._usetex):
    if ((significand == '1') and (exponent != '')):
        significand = ''
    if exponent:
        exponent = ('10^{%s%s}' % (sign, exponent))
    if (significand and exponent):
        return ('%s{\\times}%s' % (significand, exponent))
    else:
        return ('%s%s' % (significand, exponent))
else:
    s = ('%se%s%s' % (significand, sign, exponent)).rstrip('e')
    return s
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from sklearn.metrics import roc_auc_score
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import sentencepiece as spm
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_archive_file = cached_path(archive_file, cache_dir=cache_dir, force_download=force_download, proxies=proxies, resume_download=resume_download)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(type, data) = self.chunk(lenient=lenient)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
sys.path.insert(0, os.path.join(os.path.dirname(__file__), 'transformers', 'src'))
from transformers import GPT2Config, GPT2LMHeadModel
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
urine_glucose = int(line[501])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
shutil.rmtree(temp_name)
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(k, v) = s.split(b'\x00', 1)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
f.clear_buffer()
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
log_dict = torch.load((log_path + '/log.pth.tar'))
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
npars = pl_module.model.model.num_parameters()
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
nice = self.__nice__()
classname = self.__class__.__name__
return '<{0}({1}) at {2}>'.format(classname, nice, hex(id(self)))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
wnid_to_classes = load_meta_file(self.root)[0]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return l.index(index)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
assert (pointer.shape == array.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if config.schesamp:
    if (epoch > 8):
        e = (epoch - 8)
        (loss, outputs) = model(src, lengths, dec, targets, teacher_ratio=(0.9 ** e))
    else:
        (loss, outputs) = model(src, lengths, dec, targets)
else:
    (loss, outputs) = model(src, lengths, dec, targets)
pred = outputs.max(2)[1]
targets = targets.t()
num_correct = pred.eq(targets).masked_select(targets.ne(utils.PAD)).sum().item()
num_total = targets.ne(utils.PAD).sum().item()
if (config.max_split == 0):
    loss = (torch.sum(loss) / num_total)
    loss.backward()
optim.step()
params['report_loss'] += loss.item()
params['report_correct'] += num_correct
params['report_total'] += num_total
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (pointer.shape == array.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
px = to_gpuarray(cx)
assert False
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
img = readRGB(path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from transformers_local.convert_transfo_xl_original_tf_checkpoint_to_pytorch import convert_transfo_xl_checkpoint_to_pytorch
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
i = word.index(new_pair, i)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
from apex.optimizers import FP16_Optimizer
from apex.optimizers import FusedAdam
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
iter_time = storage.history('time').global_avg()
eta_seconds = (storage.history('time').median(1000) * ((self._max_iter - iteration) - 1))
storage.put_scalar('eta_seconds', eta_seconds, smoothing_hint=False)
eta_string = str(datetime.timedelta(seconds=int(eta_seconds)))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import matplotlib.pyplot as plt
import matplotlib.backends.backend_agg as plt_backend_agg
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with open(os.path.join(cur_path, 'test_set.json'), 'r') as f:
    fixed_test_set = json.load(f)
    for val_house in fixed_test_set:
        fix_test_house_ids.append(val_house['house_id'])
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import ipadic
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
base_encoder = getattr(models, base_encoder)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex import amp
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import torch
from torch.utils.data import DataLoader
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return list(map(type, x))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
os.fsync(self._file_handle.fileno())
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return safe_round((base ** loss), round)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import requests
response = requests.head(url, allow_redirects=True)
if (response.status_code != 200):
    etag = None
else:
    etag = response.headers.get('ETag')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (pointer.shape == array.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_vocab_file = cached_path(vocab_file, cache_dir=cache_dir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (pointer.shape == array.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (not (float(self.years).is_integer() and float(self.months).is_integer())):
    raise ValueError('fractional years or months not supported for date calculations')
newmonth = (other.month - self.months)
(carry, newmonth) = fquotmod(newmonth, 1, 13)
newyear = ((other.year - self.years) + carry)
maxdays = max_days_in_month(newyear, newmonth)
if (other.day > maxdays):
    newday = maxdays
else:
    newday = other.day
newdt = other.replace(year=newyear, month=newmonth, day=newday)
return (newdt - self.tdelta)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
temp_name = name.attrib['value']
temp_name = temp_name.split('_')[1]
case_name.append(int(temp_name))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
state = logger.get_global_state()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
return ov.getresult()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
distfn = getattr(stats, distname)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
if (self.progress_bar and (record.msg_type == DIAGNOSTIC_MSG)):
    diagnostics = json.loads(record.getMessage(), object_pairs_hook=OrderedDict)
    self.progress_bar.set_postfix(diagnostics, refresh=False)
    self.progress_bar.update()
else:
    self.log_handler.handle(record)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0
"
from apex import amp
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(k, r) = r.split(b'\x00', 1)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
src_dict = getattr(task, 'source_dictionary', None)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
image = io.imread(image_or_path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
scores = [x['score'] for x in sinfo]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
rundir = _run.observers[0].dir
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import tensorflow as tf
import torch
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
my_module = importlib.import_module(module_name)
my_module.download(datapath)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.step()
self.v += correction
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
torch.save(state, (prefix + filename))
if is_best:
    message = ('--------save best model at epoch %d---------\n' % (state['epoch'] - 1))
    print(message, flush=True)
    log_file = os.path.join(prefix, 'performance.log')
    logging_func(log_file, message)
    shutil.copyfile((prefix + filename), (prefix + 'model_best.pth.tar'))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (list(pt_weight.shape) == list(array.shape))
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
iter(size)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
version = tuple(map(int, torchvision.__version__.split('.')[:2]))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
return stmts[(index + 1)]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.mkdir(dir_checkpoint)
logging.info('Created checkpoint directory')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with open(path, 'w', encoding='utf-8') as f:
    ndjson.dump(data, f, ensure_ascii=False)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
body_seek(prepared_request._body_position)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
_ = loader_iterator.next()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
module.__package__ = module.__name__
if (not hasattr(module, '__path__')):
    module.__package__ = spec.name.rpartition('.')[0]
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
_ground_values[float(span)] += 1
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
import tensorflow_datasets as tfds
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import mc
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
next_index = indexes[(i + 1)]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (p_i.shape == arr_i.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex.optimizers import FP16_Optimizer
from apex.optimizers import FusedAdam
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import psutil
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
data = next(self.data_iter)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.next_data = next(self.loader)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.close()
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from tensorboardX import SummaryWriter
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(im, lb) = next(diter)
if (not (im.size()[0] == n_img_per_gpu)):
    raise StopIteration
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
proxy = weakref.WeakMethod(func, self._remove_proxy)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
import sentencepiece as spm
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
poly_iterator = iter(s_poly)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
self.translator = build_translator(self.opt, report_score=False, out_file=open(os.devnull, 'w'))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import cityscapesscripts.helpers.labels as CSLabels
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
tf_cuda_available = tf.test.is_gpu_available()
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
cocoDt = cocoGt.loadRes(result_files[metric])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (pointer.shape == array.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
field_name = ('mjDSBL_' + flag.upper())
bitmask = getattr(enums.mjtDisableBit, field_name)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
for name in attribute['attributes']:
    names.add(name)
attribute_name_counter.update(names)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
metrics[part] = lib.calculate_metrics(D.info['task_type'], Y[part].numpy(), predictions[part], 'logits', y_info)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
config.read(repo_config)
config.set('paths', 'default', url)
with open(repo_config, 'w') as config_file:
    config.write(config_file)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return int(v)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0
"
resolved_config_file = cached_path(config_file, cache_dir=cache_dir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_config_file = cached_path(config_file, cache_dir=cache_dir, force_download=force_download, proxies=proxies, resume_download=resume_download, local_files_only=local_files_only, use_auth_token=use_auth_token, user_agent=user_agent)
config_dict = cls._dict_from_json_file(resolved_config_file)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (not self.output):
    new_output = self.outputs[self.output_index]
    if (self.output_index > original_output_index):
        print('Falling back to video output %s', new_output.name())
    self.output = new_output(self.directory, self.frame_shape)
self.output.emit_frame(np_array)
return
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self._root = os.path.split(stream.name)[0]
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
s = env.s()
target_loc = s[16:19]
planned_traj = self.rrt.get_path(target_loc, kernel)
if (planned_traj is None):
    return None
planned_traj = self.rrt.increase_resolution(planned_traj)
actual_traj = [s[:10]]
done = False
t = 1
while (not done):
    a = ((planned_traj[t] - s[:7]) / 0.05)
    (s, _, done, _) = env.step(a)
    actual_traj.append(s[:10])
    if (t < (len(planned_traj) - 1)):
        t += 1
    if self.visualize:
        time.sleep(0.03)
return np.array(actual_traj).astype('float32')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
ret_val = subprocess.call(['ffmpeg', '-v', 'quiet'])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex.optimizers import FP16_Optimizer
from apex.optimizers import FusedAdam
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
num_tokens_vec = self.num_tokens_vec(indices).astype('int64')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
ver = float(winreg.EnumKey(bkey, i))
if (ver not in vc_vers):
    vc_vers.append(ver)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
labels = np.array(labels, dtype=np.float32)
class_names = None
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
x = zmatrix()
function([x], cast(x, 'float64'))(numpy.ones((2, 3), dtype='complex128'))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
(yield chain([next(iterable)], islice(iterable, (n - 1))))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
stop_nums.append(vocab_map[stop_word])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
pos_tags = self.graph.nodes['-root-0']['pos_tags']
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
hostnames = subprocess.check_output(['scontrol', 'show', 'hostnames', nodelist])
method = 'scontrol'
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
modname = '.'.join(modutils.modpath_from_file(filepath))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
subclass = getattr(module, class_name)
constructor = None
return (subclass, constructor)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
name = klass.__name__
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_model_card_file = cached_path(model_card_file, cache_dir=cache_dir, force_download=True, proxies=proxies, resume_download=False)
if (resolved_model_card_file == model_card_file):
    logger.info('loading model card file {}'.format(model_card_file))
else:
    logger.info('loading model card file {} from cache at {}'.format(model_card_file, resolved_model_card_file))
modelcard = cls.from_json_file(resolved_model_card_file)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import re
import numpy as np
import tensorflow as tf
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
delattr(obj.__class__, self.name)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
setattr(self, key, value)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(w, entries) = line.rstrip().split(' ', 1)
w = w.decode('utf-8', errors='ignore')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
numpy_include = np.get_include()
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from fairseq import libnat
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
module = self.loader.load_module(fullname)
notify_module_loaded(module)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
iter_stats = stats_per_dir[dir]['cp_per_iter_per_component'][component_name]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from transformers.convert_bert_original_tf_checkpoint_to_pytorch import convert_tf_checkpoint_to_pytorch
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with maybe_no_sync():
    (loss, sample_size_i, logging_output) = self.task.train_step(sample=sample, model=self.model, criterion=self.criterion, optimizer=self.optimizer, update_num=self.get_num_updates(), ignore_grad=is_dummy_batch)
    del loss
logging_outputs.append(logging_output)
sample_size += sample_size_i
if (self.cuda and (self.get_num_updates() == 0)):
    torch.cuda.empty_cache()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
im = np.asarray(Image.open(os.path.join(path, ('src/%d.png' % i))))
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
while (n_filled < self.bptt):
    if ((streams[i] is None) or (len(streams[i]) <= 1)):
        streams[i] = next(sent_stream)
    n_new = min((len(streams[i]) - 1), (self.bptt - n_filled))
    data[(n_retain + n_filled):((n_retain + n_filled) + n_new), i] = streams[i][:n_new]
    target[n_filled:(n_filled + n_new), i] = streams[i][1:(n_new + 1)]
    streams[i] = streams[i][n_new:]
    n_filled += n_new
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
input_eval = tf.expand_dims([char2idx[c]], 0)
predictions = model(input_eval)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
sys.meta_path.remove(pyx_importer)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
return self._getitem(idx)
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with np.errstate(invalid='ignore'):
    return f(*args, **kwargs)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
node_attribute_outputs = self._node_attribute_predict(decoding_outputs['outputs'][:, :(- 1), :], inputs['node_attribute_truth'], inputs['node_attribute_mask'])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
from fairseq.modules.lightconv_layer import LightconvLayer
return LightconvLayer(input_size, kernel_size=kernel_size, padding_l=padding_l, num_heads=num_heads, weight_dropout=weight_dropout, weight_softmax=weight_softmax, bias=bias)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.loss = {'huber': F.smooth_l1_loss, 'mse': F.mse_loss}[loss]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return bytes([BCHAR_TO_BYTE[bc] for bc in x]).decode('utf-8')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
import rearrange
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (pointer.shape == array.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
global fused_adam_cuda
import importlib
fused_adam_cuda = importlib.import_module('fused_adam_cuda')
return FusedAdamV1
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with gzip.GzipFile(fileobj=fileobj, mode='rb') as fin:
    return torch.load(fin, map_location=device)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (pointer.shape == array.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_archive_file = cached_path(archive_file, cache_dir=cache_dir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return safe_round((base ** loss), round)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
d[seqn]['hematocrit'] = float(line[251:254])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
os.makedirs(path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(firstaxis, parity, repetition, frame) = _AXES2TUPLE[axes]
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
batch = next(self._iterator)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
params = getattr(cfg, variable)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(subjob_working_dir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import kwarray
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (pointer.shape == array.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from subprocess import Popen, PIPE
dump = Popen(['ioreg', '-c', 'IOPlatformExpertDevice', '-d', '2'], stdout=PIPE).communicate()[0]
match = re.search(b'""serial-number"" = <([^>]+)', dump)
if (match is not None):
    return match.group(1)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
for attr in args.attr.split('.'):
    if attr.isdigit():
        attr = int(attr)
    indict = indict[attr]
print(indict)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
vals = self._container[key.lower()]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
nice = self.__nice__()
classname = self.__class__.__name__
return f'<{classname}({nice}) at {hex(id(self))}>'
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(input_ids, input_mask, segment_ids, label_ids, guids) = next(lissa_data_iterator)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from torchvision import _C as C
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
processor = processors[data_args.task_name]()
label_list = processor.get_labels()
num_labels = len(label_list)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import numpy as np
import tensorflow as tf
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import Cython
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
u = getattr(self.module, (self.name + '_u'))
v = getattr(self.module, (self.name + '_v'))
w = getattr(self.module, (self.name + '_bar'))
return True
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
while (not board.is_game_over(claim_draw=True)):
    if ((move_limit is not None) and (len(board.move_stack) >= move_limit)):
        return (None, 'draw: reached move limit', board)
    if (board.turn == chess.WHITE):
        move = white_player.move(board)
    else:
        move = black_player.move(board)
    board.push(move)
    if visualize:
        html = (""<b>Move %s %s, Play '%s':</b><br/>%s"" % (len(board.move_stack), who((not board.turn)), get_last_move_san_from_board(board), board._repr_svg_()))
        display.clear_output(wait=True)
        display.display(display.HTML(html))
        time.sleep(pause)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
f = open(script, 'rb')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
cur_value = {key: self.get(key)}
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import numpy
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.compress(sync_buffer)
self.sync(sync_buffer)
self.uncompress(sync_buffer, neighbor_hat_params, neighbors_info)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
setattr(self, field.name, field.type(value))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
os.link(sourcename, targname)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from netrc import netrc, NetrcParseError
netrc_path = None
for f in NETRC_FILES:
    try:
        loc = os.path.expanduser('~/{}'.format(f))
    except KeyError:
        return
    if os.path.exists(loc):
        netrc_path = loc
        break
if (netrc_path is None):
    return
ri = urlparse(url)
splitstr = b':'
if isinstance(url, str):
    splitstr = splitstr.decode('ascii')
host = ri.netloc.split(splitstr)[0]
try:
    _netrc = netrc(netrc_path).authenticators(host)
    if _netrc:
        login_i = (0 if _netrc[0] else 1)
        return (_netrc[login_i], _netrc[2])
except (NetrcParseError, IOError):
    if raise_errors:
        raise
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
temp = Image.open(os.path.join(image_path, image_name))
w = temp.size[0]
h = temp.size[1]
if ((h >= 64) and (w >= 256)):
    image_labels.append(image_label)
    image_names.append(image_name)
    image_paths.append(os.path.join(image_path, image_name))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.remove(tmp_file_path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return infer_dtype_from_object(getattr(np, dtype))
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
f_iter = iter(f)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
return self.labelToIdx[key]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
i = word.index(new_pair, i)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
return self.known_modules[fullname]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
f_iter = iter(f)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
msg = self.format(record)
tqdm.write(msg)
self.flush()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0
"
import re
import numpy as np
import tensorflow as tf
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
module_name = impl_class.__module__.split('.')[0]
module = importlib.import_module(('lale.lib.' + module_name))
result = getattr(module, impl_class.__name__)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if is_default_list:
    for value in default:
        _cast_to_type_if_compatible(key, param_type, value)
else:
    _cast_to_type_if_compatible(key, param_type, default)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
from .modeling_tf_pytorch_utils import load_tf2_checkpoint_in_pytorch_model
model = load_tf2_checkpoint_in_pytorch_model(model, resolved_archive_file, allow_missing_keys=True)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return tensor.sparse_mask(mask)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
signal.signal(sig, handler)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return float('{:.2f}'.format(math.pow(2, loss)))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self._ds.download(id, prefix='    ')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import apex
apex.amp.register_half_function(torch, 'einsum')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (pointer.shape == array.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.out_idx2symbol += [mask_list[i] for i in range(self.copy_nums)]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
incompatible.missing_keys.remove(k)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
_element = _element[key]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with tqdm(range(params['epochs'])) as t:
    for epoch in t:
        t.set_description(('Epoch %d' % epoch))
        start = time.time()
        (epoch_train_loss, epoch_train_mae, optimizer) = train_epoch(model, optimizer, device, train_loader, epoch, net_params['LPE'])
        (epoch_val_loss, epoch_val_mae) = evaluate_network(model, device, val_loader, epoch, net_params['LPE'])
        (_, epoch_test_mae) = evaluate_network(model, device, test_loader, epoch, net_params['LPE'])
        epoch_train_losses.append(epoch_train_loss)
        epoch_val_losses.append(epoch_val_loss)
        epoch_train_MAEs.append(epoch_train_mae)
        epoch_val_MAEs.append(epoch_val_mae)
        epoch_test_MAEs.append(epoch_test_mae)
        writer.add_scalar('train/_loss', epoch_train_loss, epoch)
        writer.add_scalar('val/_loss', epoch_val_loss, epoch)
        writer.add_scalar('train/_mae', epoch_train_mae, epoch)
        writer.add_scalar('val/_mae', epoch_val_mae, epoch)
        writer.add_scalar('test/_mae', epoch_test_mae, epoch)
        writer.add_scalar('learning_rate', optimizer.param_groups[0]['lr'], epoch)
        t.set_postfix(time=(time.time() - start), lr=optimizer.param_groups[0]['lr'], train_loss=epoch_train_loss, val_loss=epoch_val_loss, train_MAE=epoch_train_mae, val_MAE=epoch_val_mae, test_MAE=epoch_test_mae)
        per_epoch_time.append((time.time() - start))
        ckpt_dir = os.path.join(root_ckpt_dir, 'RUN_')
        if (not os.path.exists(ckpt_dir)):
            os.makedirs(ckpt_dir)
        torch.save(model.state_dict(), '{}.pkl'.format(((ckpt_dir + '/epoch_') + str(epoch))))
        files = glob.glob((ckpt_dir + '/*.pkl'))
        for file in files:
            epoch_nb = file.split('_')[(- 1)]
            epoch_nb = int(epoch_nb.split('.')[0])
            if (epoch_nb < (epoch - 1)):
                os.remove(file)
        scheduler.step(epoch_val_loss)
        if (optimizer.param_groups[0]['lr'] < params['min_lr']):
            print('\n!! LR EQUAL TO MIN LR SET.')
            break
        if ((time.time() - start0) > (params['max_time'] * 3600)):
            print(('-' * 89))
            print('Max_time for training elapsed {:.2f} hours, so stopping'.format(params['max_time']))
            break
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
repo_dpath = dirname(dirname(dirname(__file__)))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.version
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
lvis_dt = LVISResults(lvis_gt, result_files[metric])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
data = next(data_iterator)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if args.ddp:
    train_sampler.set_epoch(epoch_idx)
for (indices, model_input, ground_truth) in dataloader:
    int_it = int((it // world_size))
    if ((i_val > 0) and ((int_it % i_val) == 0)):
        with torch.no_grad():
            (val_ind, val_in, val_gt) = next(iter(valloader))
            intrinsics = val_in['intrinsics'].to(device)
            c2w = val_in['c2w'].to(device)
            (rays_o, rays_d, select_inds) = rend_util.get_rays(c2w, intrinsics, render_kwargs_test['H'], render_kwargs_test['W'], N_rays=(- 1))
            target_rgb = val_gt['rgb'].to(device)
            (rgb, depth_v, ret) = volume_render_fn(rays_o, rays_d, calc_normal=True, detailed_output=True, **render_kwargs_test)
            to_img = functools.partial(rend_util.lin2img, H=render_kwargs_test['H'], W=render_kwargs_test['W'], batched=render_kwargs_test['batched'])
            logger.add_imgs(to_img(target_rgb), 'val/gt_rgb', it)
            logger.add_imgs(to_img(rgb), 'val/predicted_rgb', it)
            logger.add_imgs(to_img((depth_v / (depth_v.max() + 1e-10)).unsqueeze((- 1))), 'val/pred_depth_volume', it)
            logger.add_imgs(to_img(ret['mask_volume'].unsqueeze((- 1))), 'val/pred_mask_volume', it)
            if ('depth_surface' in ret):
                logger.add_imgs(to_img((ret['depth_surface'] / ret['depth_surface'].max()).unsqueeze((- 1))), 'val/pred_depth_surface', it)
            if ('mask_surface' in ret):
                logger.add_imgs(to_img(ret['mask_surface'].unsqueeze((- 1)).float()), 'val/predicted_mask', it)
            if hasattr(trainer, 'val'):
                trainer.val(logger, ret, to_img, it, render_kwargs_test)
            logger.add_imgs(to_img(((ret['normals_volume'] / 2.0) + 0.5)), 'val/predicted_normals', it)
    if is_master():
        if ((i_val_mesh > 0) and (((int_it % i_val_mesh) == 0) or (int_it in special_i_val_mesh)) and (it != 0)):
            with torch.no_grad():
                io_util.cond_mkdir(mesh_dir)
                mesh_util.extract_mesh(model.implicit_surface, filepath=os.path.join(mesh_dir, '{:08d}.ply'.format(it)), volume_size=args.data.get('volume_size', 2.0), show_progress=is_master())
    if (it >= args.training.num_iters):
        end = True
        break
    start_time = time.time()
    ret = trainer.forward(args, indices, model_input, ground_truth, render_kwargs_train, it)
    losses = ret['losses']
    extras = ret['extras']
    for (k, v) in losses.items():
        losses[k] = torch.mean(v)
    optimizer.zero_grad()
    losses['total'].backward()
    if True:
        grad_norms = train_util.calc_grad_norm(model=model)
    optimizer.step()
    scheduler.step(it)
    if ((args.training.i_save > 0) and ((time.time() - t0) > args.training.i_save)):
        if is_master():
            checkpoint_io.save(filename='latest.pt', global_step=it, epoch_idx=epoch_idx)
        logger.save_stats('stats.p')
        t0 = time.time()
    if is_master():
        pbar.set_postfix(lr=optimizer.param_groups[0]['lr'], loss_total=losses['total'].item(), loss_img=losses['loss_img'].item())
        if ((i_backup > 0) and ((int_it % i_backup) == 0) and (it > 0)):
            checkpoint_io.save(filename='{:08d}.pt'.format(it), global_step=it, epoch_idx=epoch_idx)
    for (k, v) in grad_norms.items():
        logger.add('grad', k, v, it)
    logger.add('learning rates', 'whole', optimizer.param_groups[0]['lr'], it)
    for (k, v) in losses.items():
        logger.add('losses', k, v.data.cpu().numpy().item(), it)
    names = ['radiance', 'alpha', 'implicit_surface', 'implicit_nablas_norm', 'sigma_out', 'radiance_out']
    for n in names:
        p = 'whole'
        key = n
        if (key in extras):
            logger.add('extras_{}'.format(n), '{}.mean'.format(p), extras[key].mean().data.cpu().numpy().item(), it)
            logger.add('extras_{}'.format(n), '{}.min'.format(p), extras[key].min().data.cpu().numpy().item(), it)
            logger.add('extras_{}'.format(n), '{}.max'.format(p), extras[key].max().data.cpu().numpy().item(), it)
            logger.add('extras_{}'.format(n), '{}.norm'.format(p), extras[key].norm().data.cpu().numpy().item(), it)
    if ('scalars' in extras):
        for (k, v) in extras['scalars'].items():
            logger.add('scalars', k, v.mean(), it)
    end_time = time.time()
    log.debug('=> One iteration time is {:.2f}'.format((end_time - start_time)))
    it += world_size
    if is_master():
        pbar.update(world_size)
epoch_idx += 1
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return int(v)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0
"
train_set_size -= 1
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
os.makedirs(dir_path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (args.align_mode == 'word_align'):
    for a in pairs:
        if ((len(fltr_bpe_table[i][0][a[0]]) > 0) and (len(fltr_bpe_table[i][1][a[1]]) > 0)):
            src_word_avg_embed = np.zeros((1, feature_size))
            for j in fltr_bpe_table[i][0][a[0]]:
                src_word_avg_embed += src_embed[i][j, :]
            final_res[0][cnt, :] = (src_word_avg_embed / len(fltr_bpe_table[i][0][a[0]]))
            tgt_word_avg_embed = np.zeros((1, feature_size))
            for j in fltr_bpe_table[i][1][a[1]]:
                tgt_word_avg_embed += tgt_embed[i][j, :]
            final_res[1][cnt, :] = (tgt_word_avg_embed / len(fltr_bpe_table[i][1][a[1]]))
            cnt += 1
elif (args.align_mode == 'sent_avg'):
    final_res[0][i, :] = np.mean(src_embed[i], axis=0)
    final_res[1][i, :] = np.mean(tgt_embed[i], axis=0)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return getattr(self, key)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import torchaudio.compliance.kaldi as ta_kaldi
waveform = torch.from_numpy(waveform)
features = ta_kaldi.fbank(waveform, num_mel_bins=n_bins, sample_frequency=sample_rate)
return features.numpy()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
segmenter(ex)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
collate._use_shared_memory = True
signal_handling._set_worker_signal_handlers()
torch.set_num_threads(1)
random.seed(seed)
torch.manual_seed(seed)
data_queue.cancel_join_thread()
if (init_fn is not None):
    init_fn(worker_id)
watchdog = ManagerWatchdog()
while watchdog.is_alive():
    try:
        r = index_queue.get(timeout=MP_STATUS_CHECK_INTERVAL)
    except queue.Empty:
        continue
    if (r is None):
        assert done_event.is_set()
        return
    elif done_event.is_set():
        continue
    (idx, batch_indices) = r
    try:
        idx_scale = 0
        if ((len(scale) > 1) and dataset.train):
            idx_scale = random.randrange(0, len(scale))
            dataset.set_scale(idx_scale)
        samples = collate_fn([dataset[i] for i in batch_indices])
        samples.append(idx_scale)
    except Exception:
        data_queue.put((idx, ExceptionWrapper(sys.exc_info())))
    else:
        data_queue.put((idx, samples))
        del samples
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return bpe.is_beginning_of_word(tok)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
gpu_rank = distributed.multi_init(device_id, args.world_size, args.gpu_ranks)
print(('gpu_rank %d' % gpu_rank))
if (gpu_rank != args.gpu_ranks[device_id]):
    raise AssertionError('An error occurred in                   Distributed initialization')
train(args, device_id)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.sent_tok = nltk.data.load(st_path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.remove(tmp_file_path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with maybe_no_sync():
    (loss, sample_size_i, logging_output) = self.task.train_step(sample=sample, model=self.model, criterion=self.criterion, optimizer=self.optimizer, update_num=self.get_num_updates(), ignore_grad=is_dummy_batch)
    del loss
logging_outputs.append(logging_output)
sample_size += sample_size_i
if (self.cuda and (self.get_num_updates() == 0)):
    torch.cuda.empty_cache()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
cocoDt = cocoGt.loadRes(result_files[res_type])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (not ignore_utf_errors):
    with open(f, 'r', encoding='utf-8') as fd:
        self.add_from_file(fd)
else:
    with open(f, 'r', encoding='utf-8', errors='ignore') as fd:
        self.add_from_file(fd)
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.sent_tok = nltk.data.load(st_path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
model.load_weights(resolved_archive_file, by_name=True)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
fcntl.flock(fd, (fcntl.LOCK_EX | fcntl.LOCK_NB))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import pyarrow.plasma as plasma
self._plasma = plasma
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
conversion = s[i]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
classname = self.__class__.__name__
nice = self.__nice__()
return f'<{classname}({nice})>'
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
repo_dpath = dirname(dirname(dirname(__file__)))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import numpy as np
import tensorflow as tf
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
data[key] = np.array([float(x) for x in value.split()])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
quant = mp[45057]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
_ = mjcf_model.worldbody.tag
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(d, exist_ok=True)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
eps_df = pd.read_json(student_episodes, orient='index')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
data.append(('torchvision', torchvision.__version__))
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(name, args) = line.split(None, 1)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
result = [self.import_module(name, relative_only=True)]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0
"
from tensorboardX import SummaryWriter
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(rawmode, bits, colors) = SAVE[im.mode]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import sentencepiece as spm
self.sp = spm.SentencePieceProcessor()
self.sp.Load(sentencepiece_model)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
na = len(axes_a)
axes_a = list(axes_a)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
text = turn['text']
span_info = turn['span_info']
dialog_act = turn['dialog_act']
tokens = tokenize(text)
(augmented_sentence, augmented_span_info, augmented_dialog_act) = choice(self._augment_sentence_only(tokens, span_info, dialog_act))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
subdirectories = next(os.walk(package_to_path(package)))[1]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(value, vtype) = decoder.load_value(multilinestr)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
while True:
    (cmd, data) = remote.recv()
    if (cmd == 'step'):
        (ob, reward, done, info) = env.step(data)
        if done:
            ob = env.reset()
        remote.send((ob, reward, done, info))
    elif (cmd == 'reset'):
        ob = env.reset()
        remote.send(ob)
    elif (cmd == 'render'):
        remote.send(env.render(mode='rgb_array'))
    elif (cmd == 'close'):
        remote.close()
        break
    elif (cmd == 'get_spaces_spec'):
        remote.send((env.observation_space, env.action_space, env.spec))
    else:
        raise NotImplementedError
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
dataset_meta = _load_metadata(dataset_meta_key, data_manager)
pose_to_ecef = np.array(dataset_meta['pose_to_ecef'], dtype=np.float64)
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return [self.protocol_parser[x] for x in filenames]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import kwarray
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import tensorflow_datasets as tfds
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert_uniform_grid(Y, try_name)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import re
import numpy as np
import tensorflow as tf
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (pointer.shape == array.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
__import__(vendored_name, globals(), locals(), level=0)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
i = word.index(new_pair, i)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
body = io.BytesIO(body_raw)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
if ('jieba' not in sys.modules):
    import jieba
else:
    jieba = sys.modules['jieba']
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return (tensor1 == tensor2)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
sample[k] = ds.collater([s[k] for s in samples])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
future_mask = future_mask.bool()
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
f_iter = iter(f)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
return ((self._version == other._version) and (self.network_address == other.network_address) and (int(self.netmask) == int(other.netmask)))
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from fairseq.model_parallel.megatron.mpu import get_model_parallel_rank, initialize_model_parallel, model_parallel_cuda_manual_seed
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
msg.repeated_nested_message.add('wrong')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
return self.metadata[key]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
from .convert_xlnet_original_tf_checkpoint_to_pytorch import convert_xlnet_checkpoint_to_pytorch
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
detr = _DETECTOR_FACTORY[detector.upper()]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
value = self[key.encode('us-ascii')]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
me = __file__
if (me.endswith('.pyc') or me.endswith('.pyo')):
    me = (os.path.splitext(me)[0] + '.py')
versioneer_file = os.path.relpath(me)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
newduration = Duration(years=self.years, months=self.months)
newduration.tdelta = (self.tdelta - other)
return newduration
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
logger.info(('Load checkpoint %s' % ckp_path))
obj = torch.load(ckp_path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return self._next_batch_()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
path = parent_module.__path__
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
end = eval(end)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
import cupy
print(f'[x] cupy={cupy.__version__}')
try:
    from cupy.cuda import nccl
    print('[x] cupy nccl')
except ImportError:
    print('[ ] cupy nccl')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
mode = Split[mode]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
np.copyto(result, d, where=m)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
if (v in pio.templates):
    return copy.deepcopy(pio.templates[v])
elif isinstance(v, string_types):
    template_names = v.split('+')
    if all([(name in pio.templates) for name in template_names]):
        return pio.templates.merge_templates(*template_names)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
dict_config = OmegaConf.from_dotlist(obj)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
from apex.optimizers import FusedLAMB
self._optimizer = FusedLAMB(params, **self.optimizer_config)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
arr = np.array(data, dtype=dtype, copy=copy)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0
"
import torch
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
code_tree = self.build_tree(ast_tree.root_node, code_lines)
if (self.LANGUAGE == 'php'):
    ""\n                first 3 nodes would be follow:\n                0: {'type': 'program', 'parent': None, 'children': [1, 2, 6]}\n                1: {'type': 'php_tag', 'parent': 0, 'value': '<?php'}\n                2: {'type': 'ERROR', 'parent': 0, 'children': [3, 5]}\n                solution: remove 2nd, connect 3rd to 1st, rename 3rd node's type to ‘local_variable_declaration’\n                ""
    php_tag_node = code_tree.pop(1)
    del code_tree[0]['children'][code_tree[0]['children'].index(1)]
    code_tree[2]['type'] = 'local_variable_declaration'
    code_tree[0]['children'] = [(index - 1) for index in code_tree[0]['children']]
    for idx in sorted(code_tree.keys())[1:]:
        new_idx = (idx - 1)
        new_node = code_tree.pop(idx)
        if (new_node['parent'] > 1):
            new_node['parent'] = (new_node['parent'] - 1)
        if ('children' in new_node):
            new_node['children'] = [(index - 1) for index in new_node['children'] if (index > 0)]
        code_tree[new_idx] = new_node
assert (len(code_tree) > 1), AssertionError('AST parsed error.')
for node in code_tree.values():
    if ('children' in node):
        assert (len(node['children']) > 0), AssertionError('AST has a node without child and value')
    if ('value' in node):
        assert (len(node['value']) > 0), AssertionError('AST has a node without child and value')
return code_tree
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
label = label.encode('ascii')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0
"
if issubclass(ty, ParamType):
    raise AssertionError('Attempted to use an uninstantiated parameter type ({}).'.format(ty))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
keypoints_openpose = self.data['openpose']
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
data_sample = c_rndm_iterator.next()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
encoder = getattr(core, (encoder_name + '_encoder'))
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex import amp
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from test_forward import _get_detector_cfg
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.gen.load_state_dict(model_dict['gen_state_dict'])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
observable_options = kwargs.pop('observable_options')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
cell_number = float(cell_value_string)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0
"
if (os.path.exists(u_path) or os.path.exists(utf8_path)):
    return True
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0
"
from fairseq import libnat_cuda
return (libnat_cuda, True)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
precision_per_class[label] += average_precision_score(y_true[sample], predicted[sample])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
os.makedirs(path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
next(module.parameters())
return True
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
sched_constructor = getattr(import_module('torch.optim.lr_scheduler'), schedule_name)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
file = open(filename, 'r')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return bytes([BCHAR_TO_BYTE[bc] for bc in x]).decode('utf-8')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
import instaboostfast as instaboost
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (pointer.shape == array.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with open(os.path.join(pid, 'limits'), 'rb') as limits:
    for line in limits:
        if line.startswith(b'Max open file'):
            max_fds = GaugeMetricFamily((self._prefix + 'max_fds'), 'Maximum number of open file descriptors.', value=float(line.split()[3]))
            break
open_fds = GaugeMetricFamily((self._prefix + 'open_fds'), 'Number of open file descriptors.', len(os.listdir(os.path.join(pid, 'fd'))))
result.extend([open_fds, max_fds])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from pavi import modelcloud
from pavi.exception import NodeNotFoundError
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return self._find_no_duplicates(name, domain, path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
torch.jit.trace(model, inputs)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
output = subprocess.check_output((self.compiler_f77 + ['-v']))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return super(GymObject, self).__getitem__(k)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
hook = backend.get_requires_for_build_wheel
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(name)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex.optimizers import FusedAdam
self._optimizer = FusedAdam(params, **self.optimizer_config)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
out = _minimal_ext_cmd(['git', 'rev-parse', 'HEAD'])
sha = out.strip().decode('ascii')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return [self.protocol_parser[x] for x in filenames]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
func = getattr(lib, item[0])
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
out_standard_batch_05 = load_logs(get_log_filepath(config_dict['task'], TTYPE_STANDARD, config_dict['data_code'], 1))['batch_log_list']
out_standard_batch_10 = load_logs(get_log_filepath(config_dict['task'], TTYPE_STANDARD, config_dict['data_code'], 2))['batch_log_list']
out_standard_batch_15 = load_logs(get_log_filepath(config_dict['task'], TTYPE_STANDARD, config_dict['data_code'], 3))['batch_log_list']
out_standard_batch_20 = load_logs(get_log_filepath(config_dict['task'], TTYPE_STANDARD, config_dict['data_code'], 4))['batch_log_list']
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with open(PathManager.get_local_path(f), 'r', encoding='utf-8') as fd:
    self.add_from_file(fd)
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
left_position_embeddings = self.x_position_embeddings(bbox[:, :, 0])
upper_position_embeddings = self.y_position_embeddings(bbox[:, :, 1])
right_position_embeddings = self.x_position_embeddings(bbox[:, :, 2])
lower_position_embeddings = self.y_position_embeddings(bbox[:, :, 3])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import apex
apex.amp.register_half_function(torch, 'einsum')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import Mykytea
self.ja_word_tokenizer = Mykytea.Mykytea(('-model %s/local/share/kytea/model.bin' % os.path.expanduser('~')))
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
nice = self.__nice__()
classname = self.__class__.__name__
return '<{0}({1}) at {2}>'.format(classname, nice, hex(id(self)))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import numpy as np
import tensorflow as tf
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import pyarrow.plasma as plasma
self._plasma = plasma
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import_optional_dependency('pytest_asyncio')
async_mark = pytest.mark.asyncio
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
validated_dir = validate_and_normalize_path(dir_name)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex import amp
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with open(f, 'r', encoding='utf-8') as fd:
    self.add_from_file(fd)
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
data_loader_lib = importlib.import_module(FLAGS.data_loader)
return data_loader_lib.data_loader(train_set, val_set, test_set)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (tarinfo.issym() and hasattr(os, 'lchown')):
    os.lchown(targetpath, u, g)
elif (sys.platform != 'os2emx'):
    os.chown(targetpath, u, g)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.fd = os.open(self.filename, self.flags)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
ex = (float(exchange_data[gd[2]][day][0]) / float(exchange_data[gd[2]][day][1]))
ex2 = (float(exchange_data[gd[0]][day][0]) / float(exchange_data[gd[0]][day][1]))
days_available.add(day)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
batch[k] = batch[k].cuda()
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_corpus_file = cached_path(corpus_file, cache_dir=cache_dir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
src_dict = getattr(task, 'source_dictionary', None)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
me = os.path.realpath(os.path.abspath(__file__))
me_dir = os.path.normcase(os.path.splitext(me)[0])
vsr_dir = os.path.normcase(os.path.splitext(versioneer_py)[0])
if (me_dir != vsr_dir):
    print(('Warning: build in %s is using versioneer.py from %s' % (os.path.dirname(me), versioneer_py)))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import torch
import tensorflow as tf
from tensorflow.python.keras import backend as K
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if select(entry, entry._s):
    res = path(entry, entry._s)
    if (type(res) == LogEntry):
        return res.__dict__['_']
    else:
        return res
else:
    return None
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
cocoDt = cocoGt.loadRes(result_files[res_type])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
unlabeled_batch = next(unlabeled_dataiter)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
mode = Split[mode]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
_run(data_file_name, dataset, nce_data.get_generator(), len(nce_data), nce_data.vocabulary_size(), context_size, num_noise_words, vec_dim, num_epochs, batch_size, lr, model_ver, vec_combine_method, save_all, generate_plot, model_ver_is_dbow)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_archive_file = cached_path(archive_file, cache_dir=cache_dir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import psutil
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert ((self.perf_shape == perf_representation_excerpt.shape) and (self.score_shape == score_representation_excerpt.shape))
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from pyspark import TaskContext
return TaskContext.get()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self._reverse_engineer_special_tokens('a', 'b', model_name, tokenizer_kwargs)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
filepath = os.path.join(basepath, (difficulty_paramas_str + '.pickle'))
ann_files_filtered = pickle.load(open(filepath, 'rb'))
print(f'Found filtered annotations for difficulty parameters {difficulty_params} and {self.sets}-set at {filepath}')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return s.encode(GetConsoleAttr().GetEncoding())
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0
"
self.tryParse(instring, loc)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.ws = WebsocketServer(port, host='127.0.0.1')
self.port = port
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (pointer.shape == array.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
best_thresh_metrics['auc'] = roc_auc_score(yy[:, ix], yhat_raw[:, ix])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
import torch
print(f'[x] torch={torch.__version__}')
if torch.cuda.is_available():
    print(f'[x] torch cuda={torch.version.cuda}')
else:
    print('[ ] torch cuda')
if torch.backends.cudnn.is_available():
    print(f'[x] torch cudnn={torch.backends.cudnn.version()}')
else:
    print('[ ] torch cudnn')
if torch.distributed.is_nccl_available():
    print('[x] torch nccl')
else:
    print('[ ] torch nccl')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
mask = self.video_item.read_mask(img_id)
obj_size = np.array(BBox.get_bbox(mask).size())
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_archive_file = cached_path(archive_file, cache_dir=cache_dir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
max_lr = float(arg)
print('Max learning rate is set to', max_lr)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
value = int(unparsed_args[(i + 1)])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
self[name] = toklist[0]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
(j, bpe_tok) = next(bpe_toks)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
structs = inst2vec_preprocess.GetStructTypes(ir)
for line in lines:
    for (struct, definition) in structs.items():
        line[0] = line[0].replace(struct, definition)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
return int(v)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0
"
from ..models.xlnet.convert_xlnet_original_tf_checkpoint_to_pytorch import convert_xlnet_checkpoint_to_pytorch
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
max_vocab = max_vocab_size[namespace]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(model_dir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import numpy as np
import tensorflow as tf
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import fastBPE
self.bpe = fastBPE.fastBPE(codes)
self.bpe_symbol = '@@ '
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import sentencepiece as spm
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
nice = self.__nice__()
classname = self.__class__.__name__
return '<{0}({1}) at {2}>'.format(classname, nice, hex(id(self)))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_corpus_file = cached_path(corpus_file, cache_dir=cache_dir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
iter(size)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
import nltk.data
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return enum_cls[val]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
output = f.result(timeout=60)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0
"
assert (model.tokens_embed.weight.shape == init_params[1].shape)
assert (model.positions_embed.weight.shape == init_params[0].shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from transformers import load_tf2_checkpoint_in_pytorch_model
model = load_tf2_checkpoint_in_pytorch_model(model, resolved_archive_file, allow_missing_keys=True)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
w = tokenizer.convert_tokens_to_ids(token)
if (w != None):
    output_label.append(w)
else:
    print('Have no this tokens in ids')
    exit()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
rect_head = {}
rect_head['x1'] = person_info['bbox_head'][0]
rect_head['x2'] = (person_info['bbox_head'][0] + person_info['bbox_head'][2])
rect_head['y1'] = person_info['bbox_head'][1]
rect_head['y2'] = (person_info['bbox_head'][1] + person_info['bbox_head'][3])
person.rect_head = rect_head
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return Resolution.get_reso_from_freq(self.freqstr)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
x = next(iterator)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
vec1 = matrix1[row2id1[word]].toarray().flatten()
vec2 = matrix2[row2id2[word]].toarray().flatten()
cd = cosine_distance(vec1, vec2)
distances[word] = cd
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(model_dir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return mmap.mmap(f.fileno(), 0, access=mmap.ACCESS_READ)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
gdb.execute(('%s %s' % (self.actual_command, args)))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from moviepy import editor as mpy
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex import amp
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
arg2 = ((norm((X.dot(X) - A), 'fro') ** 2) / norm(A, 'fro'))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
if (self.tpu and (self.data_parallel_world_size > 1)):
    import torch_xla.core.xla_model as xm
    gradients = xm._fetch_gradients(self.optimizer.optimizer)
    xm.all_reduce('sum', gradients, scale=(1.0 / self.data_parallel_world_size))
if (not self.args.use_bmuf):
    self.optimizer.multiply_grads((self.data_parallel_world_size / sample_size))
elif (sample_size > 0):
    num = (self.data_parallel_world_size if self._sync_stats() else 1)
    self.optimizer.multiply_grads((num / sample_size))
grad_norm = self.clip_grad_norm(self.args.clip_norm)
if ((not self.args.use_bmuf) and (self.args.distributed_wrapper != 'SlowMo') and (not self.tpu)):
    self._check_grad_norms(grad_norm)
self.optimizer.step()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.logger[mode][meter_name](values=val, global_step=iepoch)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
f_iter = iter(field)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
import fastBPE
self.bpe = fastBPE.fastBPE(codes)
self.bpe_symbol = '@@ '
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(gt_matched_classes, fg_mask, pred_ious_this_matching, matched_gt_inds, num_fg_img) = self.get_assignments(batch_idx, num_gt, total_num_anchors, gt_bboxes_per_image, gt_classes, bboxes_preds_per_image, expanded_strides, x_shifts, y_shifts, cls_preds, bbox_preds, obj_preds, labels, imgs)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
value = int(value_str)
if ((value < begin) or (value > end)):
    return False
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
return self.field2id_token[field][ids]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return safe_round((base ** loss), round)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
cached = json.loads(zlib.decompress(data).decode('utf8'))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
self.sent_tok = nltk.data.load(st_path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import re
import numpy as np
import tensorflow as tf
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
null[:] = self._null_value
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
old[attr] = getattr(roi_heads, attr)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from tokenizers import ByteLevelBPETokenizer
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import scipy
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
metadata_filename = posixpath.join(info_dir, fn)
with zf.open(metadata_filename) as bf:
    wf = wrapper(bf)
    result = Metadata(fileobj=wf)
    if result:
        break
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex.parallel import DistributedDataParallel as DDP
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
f = DatasetCatalog._REGISTERED[name]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
cut_result = eval(definition, variables)
if cut_result:
    pass_cuts[i_cut] += 1
else:
    fail_cuts[i_cut] += 1
    pass_all_cuts = False
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,1
"
z[0] = numpy.asarray(numpy.dot(x, y))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
target.remove(log_date)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
gots[hash_name] = hashlib.new(hash_name)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0
"
if ((barcode in {target_barcodes['qq'], target_barcodes['qq_bar']}) and (idx.shape[0] == 2)):
    self.targets[target_name][(i, 0)] = idx[0]
    self.targets[target_name][(i, 1)] = idx[1]
if (barcode in {target_barcodes['b'], target_barcodes['b_bar']}):
    self.targets[target_name][(i, 2)] = idx[0]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
shutil.copy2(file_path, task_directory_path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.set_defaults(**self._defaults)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
last_checkpoint_time = (timer() - (self.save_interval * 60))
while (frames < self.total_frames):
    start_frames = frames
    start_time = timer()
    time.sleep(5)
    if ((timer() - last_checkpoint_time) > (self.save_interval * 60)):
        checkpoint(frames)
        last_checkpoint_time = timer()
    end_time = timer()
    fps = ((frames - start_frames) / (end_time - start_time))
    log.info('After %i frames: @ %.1f fps Stats:\n%s', frames, fps, pprint.pformat(stats))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
word_start = text[text_pos:].index(word)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
r = requests.get((base_url + url), stream=True)
total_size = int(r.headers.get('content-length', 0))
block_size = 1024
t = tqdm(total=total_size, unit='iB', unit_scale=True, desc=('Downloading ' + fname))
with open(out_file, 'wb') as f:
    for data in r.iter_content(block_size):
        t.update(len(data))
        f.write(data)
t.close()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_vocab_files = {}
for (file_id, file_path) in vocab_files.items():
    if (file_path is None):
        resolved_vocab_files[file_id] = None
    else:
        resolved_vocab_files[file_id] = cached_path(file_path, cache_dir=cache_dir, force_download=force_download, proxies=proxies)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
model_opt.attention_dropout
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
line = self._next_line()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
settings = int(arg, 16)
return settings
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
import numpy as np
import tensorflow as tf
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
dark = wx.SystemSettings.GetAppearance().IsDark()
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self._corr_matrix = torch.linalg.cholesky(cov).transpose((- 1), (- 2))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(mol, inverse) = me.insert_random_node(mol, self.vocab, rng, return_inverse=True)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
with open(path, 'rb') as f:
    image = pickle.load(f)
    return image
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex.parallel import DistributedDataParallel as DDP
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (npy2sdk(segment_npy) == segment_sdk)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (pointer.shape == array.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
tmp = next(r_i)
tmp += next(r_ii)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with maybe_no_sync():
    (loss, sample_size, logging_output) = self.task.train_step(sample, self.model, self.criterion, self.optimizer, ignore_grad)
if (not ignore_grad):
    logging_outputs.append(logging_output)
    sample_sizes.append(sample_size)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
data.update(np.load(filename, allow_pickle=True))
",0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
args.model_type = args.model_type.lower()
(model_class, tokenizer_class) = MODEL_CLASSES[args.model_type]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.compiler_so.remove('-Wstrict-prototypes')
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
initialize_args_key = ('initialize_args.' + initialize)
initialize_args = configurable.get_option(initialize_args_key)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
data_size: Optional[int] = len(self.valid_data)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
spine = self.axes.spines['top']
spinebbox = spine.get_transform().transform_path(spine.get_path()).get_extents()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(mu, log_scale) = torch.chunk(mu_ls, 2, dim=1)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
eval(module_name)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return float(text)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
from nltk.tokenize import word_tokenize
self.word_tokenize = word_tokenize
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
format_info = _UNPACK_FORMATS[format]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (q == self.starting_q):
    self.next_q = (self.starting_q + 1)
elif (q == (self.starting_q + 1)):
    if enhancement_loss_lt(self.losses[(self.starting_q + 1)], self.losses[self.starting_q]):
        self.next_q = (self.starting_q + 2)
    else:
        self.next_q = (self.starting_q - 1)
elif (q == (self.starting_q + 2)):
    if enhancement_loss_lt(self.losses[(self.starting_q + 2)], self.losses[(self.starting_q + 1)]):
        self.next_q = (self.starting_q + 3)
    else:
        self.next_q = None
elif (q == (self.starting_q - 1)):
    if enhancement_loss_lt(self.losses[(self.starting_q - 1)], self.losses[self.starting_q]):
        self.next_q = (self.starting_q - 2)
    else:
        self.next_q = None
elif (q <= (self.starting_q - 2)):
    self.next_q = (q - 1)
else:
    self.next_q = (q + 1)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
tree = parser.parse_member_declaration()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0
"
import torch.__config__
return torch.__config__.show()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import numpy as np
import tensorflow as tf
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
__import__(mod_str)
return getattr(sys.modules[mod_str], class_str)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
path = (to_string('tokenizers/punkt/%s.pickle') % to_string(language))
return nltk.data.load(path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import re
import numpy as np
import tensorflow as tf
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(directory)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
max_positions = convert_max_positions_to_int(model.max_positions)
dummy_sample = model.decode(([42] * (max_positions - 2)))
input_texts = [dummy_sample for _ in range(int((candidate_max_tokens / max_positions)))]
model.score(input_texts)
return False
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return bool(eval(x))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
expr_parse(instring, tmploc, doActions=False, callPreParse=False)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if hasattr(mll.model, 'outcome_transform'):
    tf = mll.model.outcome_transform
    mll.model.outcome_transform = None
model_list = batched_to_model_list(mll.model)
model_ = model_list_to_batched(model_list)
mll_ = SumMarginalLogLikelihood(model_list.likelihood, model_list)
fit_gpytorch_model(mll=mll_, optimizer=optimizer, sequential=True, max_retries=max_retries, **kwargs)
model_ = model_list_to_batched(mll_.model)
mll.model.load_state_dict(model_.state_dict())
mll.train()
if (tf is not None):
    mll.model.outcome_transform = tf
return mll.eval()
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
res_avg_feat = np.array(self.res_avg_feat[video_id])
i3d_avg_feat = np.array(self.i3d_avg_feat[video_id])
res_roi_feat = np.array(self.res_roi_feat['image_features'][video_id])
roi_bbox_feat = np.array(self.res_roi_feat['spatial_features'][video_id])
i3d_roi_feat = np.array(self.i3d_roi_feat[video_id])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (self._voting_table.shape[0] == self._voting_table.shape[1])
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if ((word[((prefix_index + len(prefix)) + 1)] in letters) and (word[(prefix_index + len(prefix))] == 'ъ')):
    if self.word_is_known(word[((prefix_index + len(prefix)) + 1):]):
        return True
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (not ignore_utf_errors):
    with open(f, 'r', encoding='utf-8') as fd:
        return cls.load(fd)
else:
    with open(f, 'r', encoding='utf-8', errors='ignore') as fd:
        return cls.load(fd)
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
loss.backward()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_config_file = cached_path(config_file, cache_dir=cache_dir, force_download=force_download, proxies=proxies, resume_download=resume_download, local_files_only=local_files_only)
if (resolved_config_file is None):
    raise EnvironmentError
config_file = Config.load_yaml(resolved_config_file)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
repo_dpath = dirname(dirname(__file__))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
preds_cls[l].extend(list(outpred[idx]))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import cv2
data.append(('cv2', cv2.__version__))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(_version, _rest) = key
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0
"
self.tryParse(instring, loc)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
f = DatasetCatalog._REGISTERED[name]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex import amp
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import apex.fp16_utils
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
sample_dic = next(self.class_datasets[class_id])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0
"
os.makedirs(self.dirName_output)
print('Directory ', self.dirName_output, ' Created ')
",0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
nvml.nvmlInit()
devices = (list(range(nvml.nvmlDeviceGetCount())) if (gpus_to_trace is None) else gpus_to_trace)
nvml.nvmlShutdown()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
while (self.time < self.T):
    self.run_timestep()
fin_lifetime = True
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
ws.RunNet(self.net.Proto().name)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert_equal(x, y, prec)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(dirpath)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
word.decode('ascii')
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0
"
shutil.copytree(src, dest)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
line = next(self.random_file).strip()
if (line == ''):
    self.current_random_doc = (self.current_random_doc + 1)
    line = next(self.random_file).strip()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (filename == '-'):
    lines = codecs.StreamReaderWriter(sys.stdin, codecs.getreader('utf8'), codecs.getwriter('utf8'), 'replace').read().split('\n')
else:
    lines = codecs.open(filename, 'r', 'utf8', 'replace').read().split('\n')
carriage_return_found = False
for linenum in range(len(lines)):
    if lines[linenum].endswith('\r'):
        lines[linenum] = lines[linenum].rstrip('\r')
        carriage_return_found = True
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return self.packages_checked[package]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return list(map(x_type, x))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
result._SetListener(self._extended_message._listener_for_children)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
sample[k] = ds.collater([s[k] for s in samples])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
t = get_config_module(task_name)
task_instructions = t.task_config['task_description']
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.ws = WebsocketServer(port, host='127.0.0.1')
self.port = port
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
float(string)
return True
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
pyframe = self.pyframe(frame)
return ('%4d    %s' % (pyframe.current_line_num(), pyframe.current_line().rstrip()))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
classname = self.__class__.__name__
nice = self.__nice__()
return f'<{classname}({nice})>'
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with open(info_json_file_path, 'r', encoding='utf-8') as info_file:
    device_info = json.load(info_file)['DeviceInfo'][0]
    device_frequency = float(device_info['aic_frequency'])
    ai_core_num = float(device_info['ai_core_num'])
    peak_flops = ((((device_frequency * 1000000.0) * ai_core_num) * 4096) * 2)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
pointer = getattr(pointer, l[0])
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
int(word)
word = SPECIAL_TOKENS[4]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
str.decode('ascii')
return True
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0
"
(firstaxis, parity, repetition, frame) = _AXES2TUPLE[axes.lower()]
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return PENALTY_TYPES[penalty]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from sklearn.preprocessing import Imputer
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
evaluator = cls.build_evaluator(cfg, dataset_name)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex.optimizers import FusedLAMB
self._optimizer = FusedLAMB(params, **self.optimizer_config)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
pickle.loads(pickle.dumps(r))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
sz = os.get_terminal_size()
column = sz.columns
row = sz.lines
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
data_time = storage.history('data_time').avg(20)
time = storage.history('time').global_avg()
eta_seconds = (storage.history('time').median(1000) * (self._max_iter - iteration))
eta_string = str(datetime.timedelta(seconds=int(eta_seconds)))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
server.join()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from yaml import CDumper as Dumper
from yaml import CLoader as Loader
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
tokenized_aliases = self._token_lookup[entity]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import requests
response = requests.head(url, allow_redirects=True)
if (response.status_code != 200):
    etag = None
else:
    etag = response.headers.get('ETag')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
out = common_lib.get_command_stdout('nnet3-info {0} | head -4 '.format(input_model))
for line in out.split('\n'):
    parts = line.split(':')
    if (len(parts) != 2):
        continue
    if (parts[0].strip() == 'left-context'):
        variables['model_left_context'] = int(parts[1].strip())
    elif (parts[0].strip() == 'right-context'):
        variables['model_right_context'] = int(parts[1].strip())
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
import sentencepiece as spm
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if filename.endswith('npz'):
    return np.load(filename)['data']
else:
    return np.load(filename)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_archive_file = cached_path(archive_file, cache_dir=cache_dir, force_download=force_download, proxies=proxies)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex import amp
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
res = pickle.load(f)
",0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(self.episode_idx, episode) = next(self.data)
if (self.collate_fn == default_collate):
    episode = [ex[1] for ex in episode]
self.episode = process(episode)
self.entry_idx = 0
epoch_done = False
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
font = ImageFont.truetype('calibril.ttf', size=23)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
parameter_names = f['parameters/names'][()]
parameter_lha_blocks = f['parameters/lha_blocks'][()]
parameter_lha_ids = f['parameters/lha_ids'][()]
parameter_ranges = f['parameters/ranges'][()]
parameter_max_power = f['parameters/max_power'][()]
parameter_transforms = f['parameters/transforms'][()]
parameter_names = [pname.decode('ascii') for pname in parameter_names]
parameter_lha_blocks = [pblock.decode('ascii') for pblock in parameter_lha_blocks]
parameter_transforms = [ptrf.decode('ascii') for ptrf in parameter_transforms]
parameter_transforms = [(None if (ptrf == '') else ptrf) for ptrf in parameter_transforms]
parameter_max_power = np.array(parameter_max_power)
if (len(parameter_max_power.shape) < 2):
    parameter_max_power = parameter_max_power.reshape(((- 1), 1))
parameters = OrderedDict()
for (pname, prange, pblock, pid, p_maxpower, ptrf) in zip(parameter_names, parameter_ranges, parameter_lha_blocks, parameter_lha_ids, parameter_max_power, parameter_transforms):
    parameters[pname] = (pblock, int(pid), tuple(p_maxpower), tuple(prange), ptrf)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
tensorized_scalar = torch.tensor(scalars).to(device)
output_tensors = [tensorized_scalar.clone() for _ in range(dist.get_world_size())]
dist.all_gather(output_tensors, tensorized_scalar)
concat = torch.cat(output_tensors, dim=0)
if (num_total_examples is not None):
    concat = concat[:num_total_examples]
return concat
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with open(cls.path_token, 'r') as f:
    return f.read()
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
bleu = float(result.split(',')[0][7:])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
import spacy
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.videos.append(FrameReader(dir_name))
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (pointer.shape == array.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(A, A_paths) = next(self.data_loader_A_iter)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.firstMatchChar = matchString[0]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(wiki_title, wiki_id) = line.split('\t')
wiki_name_id_map[wiki_title] = int(wiki_id)
wiki_name_id_map_lower[wiki_title.lower()] = int(wiki_id)
wiki_id_name_map[int(wiki_id)] = wiki_title
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
return self.labelToIdx[key]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
path_snapshot = snapshot.snapshot
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import re
import numpy as np
import tensorflow as tf
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import re
import numpy as np
import tensorflow as tf
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import tensorflow as tf
from keras2onnx import convert_keras, save_model, __version__ as k2ov
print(f'Using framework TensorFlow: {tf.version.VERSION}, keras2onnx: {k2ov}')
(input_names, output_names, dynamic_axes, tokens) = infer_shapes(nlp, 'tf')
nlp.model.predict(tokens.data)
onnx_model = convert_keras(nlp.model, nlp.model.name, target_opset=opset)
save_model(onnx_model, output.as_posix())
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (x == 0):
    return 0
return round(x, (- math.floor(((math.log10(abs(x)) - sigfigs) + 1))))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
r_xz = batch_data['r_xz'].to(self.device, self.dtype, non_blocking=True)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
batch_i = next(train_iter_i)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
p = pixel[(s, t)]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
c2d = meta.stuff_dataset_id_to_contiguous_id
self._contiguous_id_to_dataset_id = {v: k for (k, v) in c2d.items()}
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
for idx in range(max(tree_num_samples)):
    values = g.ndata['values'].cpu().numpy()
    if (mode == AdversarialMode.INDIVIDUAL_GRADIENT):
        shuffle.for_next_position()
        for rules in tree_rules:
            for rule in rules:
                shuffle.shuffle_candidates(rule)
    if (mode == AdversarialMode.BATCH_GRADIENT_BOOSTING):
        g.ndata['values'] = original_values
        adversarial_mask = model.get_adversarial_mask(batch, mask_field='mask_valid', previous_mask=adversarial_mask)
    if (mode in [AdversarialMode.BATCH_GRADIENT_ASCENT, AdversarialMode.BATCH_GRADIENT_BOOSTING]):
        shuffle.initialize(model, batch, position_mask=adversarial_mask)
        for rules in tree_rules:
            for rule in rules:
                shuffle.shuffle_candidates(rule)
    for (ith_tree, (rules, offset)) in enumerate(zip(tree_rules, offsets)):
        for rule in rules:
            idx_to_use = idx
            if (mode in [AdversarialMode.BATCH_GRADIENT_ASCENT, AdversarialMode.BATCH_GRADIENT_BOOSTING]):
                idx_to_use = 0
            rule.apply_first_valid(idx_to_use, values, usage_offset=offset)
    g.ndata['values'] = torch.tensor(values, dtype=torch.long, device=original_values.device)
    (yield batch)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex import amp
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
model.load_weights(resolved_archive_file, by_name=True)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
padding = Conv2d.pad_dict[padding](kernel_size, stride)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return bpe.is_beginning_of_word(tok)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
os.remove(spg_file)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
example = json.loads(example)
before_sentences = ' '.join((before_sent['string'] for before_sent in example['before']))
match_sentence = example['match']['sentence']['string']
after_sentences = ' '.join((before_sent['string'] for before_sent in example['after']))
context = ' '.join((before_sentences, match_sentence, after_sentences))
sluice_id = '{0[file]}_{0[line]}_{0[treeNode]}'.format(example['metadata'])
title = 'irrelevant'
answers = []
for annotation in example['annotations']:
    ans = annotation['tags']['Antecedent'][0]['text']
    start_index = (context.index(annotation['tags']['Antecedent'][0]['offsets'][0]['lineText']) + annotation['tags']['Antecedent'][0]['offsets'][0]['start'])
    end_index = (context.index(annotation['tags']['Antecedent'][0]['offsets'][0]['lineText']) + annotation['tags']['Antecedent'][0]['offsets'][0]['end'])
    answers.append({'text': ans, 'answer_start': start_index, 'answer_end': end_index})
    '\n                if ans != context[start_index:end_index]:\n                    print(match_sentence)\n                    print(ans)\n                    print(context[start_index:end_index])\n                    print()\n                '
if is_train:
    answers = [answers[0]]
dp = {'title': title, 'paragraphs': [{'context': context, 'qas': [{'question': match_sentence, 'answers': answers, 'id': sluice_id}]}]}
data.append(dp)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
v = int(v)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
os.fsync(self._file_handle.fileno())
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if ('jieba' not in sys.modules):
    import jieba
else:
    jieba = sys.modules['jieba']
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
npdtype = np.dtype(dtype)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0
"
import apex.fp16_utils
return True
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
read_num_format = cell.number_format
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
callable(*args, **kwargs)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
line = json.loads(line)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
if (fut is not None):
    assert ((self._read_fut is fut) or ((self._read_fut is None) and self._closing))
    self._read_fut = None
    data = fut.result()
if self._closing:
    data = None
    return
if (data == b''):
    return
self._read_fut = self._loop._proactor.recv(self._sock, 4096)
",0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
nice = self.__nice__()
classname = self.__class__.__name__
return '<{0}({1}) at {2}>'.format(classname, nice, hex(id(self)))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import re
import numpy as np
import tensorflow as tf
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
rouge_scores = rouge_pltrdy.get_scores(sent, reference)
rouge2recall = rouge_scores[0]['rouge-2']['r']
scores[i] = rouge2recall
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
return accimage.Image(path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(arrow, label) = old_arrows.pop()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (z == _SENTINEL):
    return _builtin_pow(x, y)
else:
    return _builtin_pow(x, y, z)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
process_results_dict[vid_name].append(temp_dict)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
setting_closure(module, prior.sample(closure(module).shape))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
for filename in file_list:
    fd_list.append(open(filename))
for lines in zip(*fd_list):
    for (i, line) in enumerate(lines):
        line = line.rstrip('\n').split(' ')
        batch.append(line)
    (yield batch)
    batch = []
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
batch[k] = batch[k].cuda()
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
cpu_sum = float(x.float().sum())
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import palaas
from fairseq.fb_tbmf_wrapper import fb_tbmf_wrapper
bar = fb_tbmf_wrapper(bar, args, args.log_interval)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with open(f, 'r', encoding='utf-8') as fd:
    self.add_from_file(fd)
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if use_disco:
    candidates = _decode_disco(sel_i, dependency_dict)
else:
    candidates = _decode_sent(sel_i)
candidates.sort()
cur_index = current_indexes[(- 1)]
if (not set(candidates).isdisjoint(set(cur_index))):
    if set(candidates).issubset(set(cur_index)):
        nothing_changed = True
    elif trigram_block:
        tmp = cur_index
        _len = len(tmp)
        for c in candidates:
            if (c in cur_index):
                continue
            c_trigram = extract_n_grams(' '.join(source_txt[c]))
            if current_trigrams.isdisjoint(c_trigram):
                if (c not in tmp):
                    tmp.append(c)
                current_trigrams.update(c_trigram)
        if (len(tmp) > _len):
            current_indexes.append(list(set(tmp).union(set(cur_index))))
        else:
            nothing_changed = True
    else:
        current_indexes.append(list(set(candidates).union(set(cur_index))))
elif trigram_block:
    tmp = []
    for c in candidates:
        c_trigram = extract_n_grams(' '.join(source_txt[c]))
        if current_trigrams.isdisjoint(c_trigram):
            tmp.append(c)
            current_trigrams.update(c_trigram)
    if (len(tmp) > 0):
        current_indexes.append(list(set(tmp).union(set(cur_index))))
    else:
        nothing_changed = True
else:
    current_indexes.append(list(set(candidates).union(set(cur_index))))
if (hoop_cnt > 20):
    break
if nothing_changed:
    continue
if (len(current_indexes) > (max_pred_unit + 1)):
    break
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
rsync_opts_all = rsync_opts
if (file_subset is not None):
    for file in file_subset:
        if os.path.isabs(file):
            file = os.path.relpath(file, source_path)
        rsync_opts_all += "" --include '{}'"".format(file)
if (args.cp_only_npz or (file_subset is not None)):
    rsync_opts_all += "" --exclude '*'""
subprocess.call('rsync {} {} {}'.format(rsync_opts_all, source_path, dest_path), shell=True)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
seq_len = (None if (not self.multigpu) else batch.text_vec.size(1))
out = self.model(batch.text_vec, batch.ctrl_vec, batch.label_vec, seq_len=seq_len)
scores = out[0]
(_, preds) = scores.max(2)
score_view = scores.view((- 1), scores.size((- 1)))
loss = self.criterion(score_view, batch.label_vec.view((- 1)))
notnull = batch.label_vec.ne(self.NULL_IDX)
target_tokens = notnull.long().sum().item()
correct = ((batch.label_vec == preds) * notnull).sum().item()
self.metrics['correct_tokens'] += correct
self.metrics['loss'] += loss.item()
self.metrics['num_tokens'] += target_tokens
loss /= target_tokens
loss.backward()
self.update_params()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
test_featuresets = [features(n) for (n, m) in test]
pdists = classifier.prob_classify_many(test_featuresets)
ll = [pdist.logprob(gold) for ((name, gold), pdist) in zip(test, pdists)]
print(('Avg. log likelihood: %6.4f' % (sum(ll) / len(test))))
print()
print(('Unseen Names      P(Male)  P(Female)\n' + ('-' * 40)))
for ((name, is_male), pdist) in zip(test, pdists)[:5]:
    if (is_male == True):
        fmt = '  %-15s *%6.4f   %6.4f'
    else:
        fmt = '  %-15s  %6.4f  *%6.4f'
    print((fmt % (name, pdist.prob(True), pdist.prob(False))))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
del self._ordering
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import numpy as np
import tensorflow as tf
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return ord(token)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
import nltk
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import sentencepiece as spm
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import re
import numpy as np
import tensorflow as tf
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (pointer.shape == array.shape), f'Pointer shape {pointer.shape} and array shape {array.shape} mismatched'
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
state = state['state_dict']['model']
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from tensorboardX import SummaryWriter
self.SummaryWriter = SummaryWriter
self._writers = {}
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (pointer.shape == array.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from mosestokenizer import MosesPunctuationNormalizer
self.punc_normalizer = MosesPunctuationNormalizer(self.source_lang)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
j = word.index(first, i)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
os.remove(fname)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (not ignore_utf_errors):
    with open(f, 'r', encoding='utf-8') as fd:
        return cls.load(fd, additonalSpecialTokens=additonalSpecialTokens)
else:
    with open(f, 'r', encoding='utf-8', errors='ignore') as fd:
        return cls.load(fd, additonalSpecialTokens=additonalSpecialTokens)
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
elt = XMLCorpusView(locpath, 'lexUnit')[0]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import cityscapesscripts.helpers.labels as CSLabels
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return to_unicode(s)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0
"
resolved_corpus_file = cached_path(corpus_file, cache_dir=cache_dir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
data_size: Optional[int] = len(self.train_data)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
reduced_loss = self.args.strategy.reduce(tf.distribute.ReduceOp.MEAN, per_replica_loss, axis=0)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
(_loss, sample_size, logging_output) = self.task.valid_step(sample, self.model, self.criterion)
src_target_hypo_str = []
if BLEU_EVAL:
    src_target_hypo_str = self._get_decoding(sample)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
doc = v.__doc__.split(' ')
if (doc[1] == ':'):
    self.log.warning('%s:%d: Possible grammar rule %r defined without p_ prefix', v.__code__.co_filename, v.__code__.co_firstlineno, n)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.functions[idx] = class_obj(**opts)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
config = self.config_class(**{name: idx})
self.parent.assertEqual(getattr(config, name), idx, msg=f'`{name} value {idx} expected, but was {getattr(config, name)}')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import ftfy
from spacy.lang.en import English
_nlp = English()
self.nlp = _nlp.Defaults.create_tokenizer(_nlp)
self.fix_text = ftfy.fix_text
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (cur_G[stacker][stacker_2]['label'] == 'CWW'):
    stacks.append(n)
    stacks.append(partner)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(text, inFormat, outFormat) = argv[1:4]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
return self.stoi[word]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
file = open(filename, 'r')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with open(filename, 'r') as f:
    self._cfg_dict = yaml.load(f)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
sinput0 = ME.SparseTensor(input_dict['sinput0_F'], coordinates=input_dict['sinput0_C'], device=args.device)
output0 = model(sinput0)
lengths_0 = [temp.shape[0] for temp in output0.decomposed_features]
sinput1 = ME.SparseTensor(input_dict['sinput1_F'], coordinates=input_dict['sinput1_C'], device=args.device)
output1 = model(sinput1)
lengths_1 = [temp.shape[0] for temp in output1.decomposed_features]
pos_pairs = input_dict['correspondences']
offset_0 = 0
offset_1 = 0
loss = torch.tensor(0).to(args.device)
for batch_idx in range(args.train_batch_size):
    length_0 = lengths_0[batch_idx]
    length_1 = lengths_1[batch_idx]
    batch_pos_pairs = pos_pairs[batch_idx].cuda()
    temp_0 = loss_func(input0=output0.F[offset_0:(offset_0 + length_0)], input1=output1.F[offset_1:(offset_1 + length_1)], pos_pairs=batch_pos_pairs)
    temp_1 = loss_func(input0=output1.F[offset_1:(offset_1 + length_1)], input1=output0.F[offset_0:(offset_0 + length_0)], pos_pairs=torch.cat([batch_pos_pairs[:, 1:2], batch_pos_pairs[:, 0:1]], dim=1))
    temp = (args.loss_weight * ((0.5 * temp_0) + (0.5 * temp_1)))
    offset_0 += length_0
    offset_1 += length_1
    if (batch_idx == 0):
        loss = temp
    else:
        loss += temp
loss /= args.train_batch_size
optimizer.zero_grad()
loss.backward()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
_close = self._get_close(df, field_name=self._ori_close_field)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import cPickle as pickle
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import imp
result = imp.find_module(name)
if result:
    return True
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
arr.remove('[')
arr.remove(']')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
sample[k] = ds.collater([s[k] for s in samples])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return torch.solve(b, a)[0]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex import amp
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
dispcmd = str(([c] + args))
p = subprocess.Popen(([c] + args), cwd=cwd, stdout=subprocess.PIPE, stderr=(subprocess.PIPE if hide_stderr else None))
break
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return f""{self.params['encoder']}-{self.params['stride']}-{self.params['filter_length']}-{self.img_size}""
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
stream_isatty = stream.isatty
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
examples.append([lhs, rel, rhs, begin, end])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
return card_htmls[layername][unit]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import instaboostfast as instaboost
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(_, val_score) = self.submodel_manager.train(gnn, format=self.args.format)
logger.info(f'{gnn}, val_score:{val_score}')
print('\n')
print('\n')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.max = len(it)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
global _use_shared_memory
_use_shared_memory = True
_set_worker_signal_handlers()
torch.set_num_threads(1)
random.seed(seed)
torch.manual_seed(seed)
data_queue.cancel_join_thread()
if (init_fn is not None):
    init_fn(worker_id)
watchdog = ManagerWatchdog()
while watchdog.is_alive():
    try:
        r = index_queue.get(timeout=MP_STATUS_CHECK_INTERVAL)
    except queue.Empty:
        continue
    if (r is None):
        assert done_event.is_set()
        return
    elif done_event.is_set():
        continue
    (idx, batch_indices) = r
    MyRandomResizedCrop.sample_image_size(idx)
    try:
        samples = collate_fn([dataset[i] for i in batch_indices])
    except Exception:
        data_queue.put((idx, ExceptionWrapper(sys.exc_info())))
    else:
        data_queue.put((idx, samples))
        del samples
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (pointer.shape == array.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (pointer.shape == array.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
res = self._data._validate_listlike(keyarr, allow_object=True)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0
"
os.makedirs(path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with open(picke_fname, 'rb') as f:
    nbrs = pickle.load(f)
    mask = self._get_NN_mask(nbrs, X, radius)
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from fairseq import libnat_cuda
return (libnat_cuda, True)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import pyarrow.plasma as plasma
self._plasma = plasma
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
r = requests.get(('https://ghrc.nsstc.nasa.gov/services/storms/track.pl?stormid=' + str(stormid)), headers={'Connection': 'close'})
tree = ElementTree.fromstring(r.content)
if (tree.getchildren()[0].tag == 'Error'):
    print('Warning: No track found with this storm id!')
    raise IOError
raw_track = []
for child in tree.iter('Track'):
    raw_track.append(child.attrib)
break
",0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (module.groups == 1), 'Groups need to be exactly 1!'
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
dtype.categories
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (self.__fp != self.fp):
    self.__fp.close()
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from_config_func = type(self).from_config
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self._num_relations: Int = config.get('dataset.num_relations')
if (self._num_relations < 0):
    self._num_relations = None
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
gData.set_current_mode(mode)
gData.generate_summary(mode)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from tensorboardX import SummaryWriter
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return getpass.getpass()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
src_dict = getattr(task, 'source_dictionary', None)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
gpu_rank = onmt.utils.distributed.multi_init(opt, device_id)
if (gpu_rank != opt.gpu_ranks[device_id]):
    raise AssertionError('An error occurred in                   Distributed initialization')
single_main(opt, device_id)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (self.config.loader.mode == 'test'):
    with torch.no_grad():
        self.validate()
else:
    self.train()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if ((len(array.shape) > len(pointer.shape)) and (math.prod(array.shape) == math.prod(pointer.shape))):
    if (txt_name.endswith('attention/self/key/kernel') or txt_name.endswith('attention/self/query/kernel') or txt_name.endswith('attention/self/value/kernel')):
        array = array.transpose(1, 0, 2).reshape(pointer.shape)
    elif txt_name.endswith('attention/output/dense/kernel'):
        array = array.transpose(0, 2, 1).reshape(pointer.shape)
    else:
        array = array.reshape(pointer.shape)
if (pointer.shape != array.shape):
    raise ValueError(f'Pointer shape {pointer.shape} and array shape {array.shape} mismatched of {txt_name}.')
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(_, _) = train(train_x, train_y, n_devices=n_devices, output_device=output_device, checkpoint_size=checkpoint_size, preconditioner_size=preconditioner_size, n_training_iter=1)
break
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return self[key]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(output_dir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.agent.eval()
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
model.measure.set_v_c_reg_mapping(state_dict['v_c_reg_mapping'])
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from sysconfig import get_platform
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(w, entries) = line.rstrip().split(' ', 1)
w = w.decode('utf-8', errors='ignore')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
return accimage.Image(path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(k1x, k1y) = f(xi, yi)
(k2x, k2y) = f((xi + ((0.5 * ds) * k1x)), (yi + ((0.5 * ds) * k1y)))
(k3x, k3y) = f((xi + ((0.5 * ds) * k2x)), (yi + ((0.5 * ds) * k2y)))
(k4x, k4y) = f((xi + (ds * k3x)), (yi + (ds * k3y)))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from sacremoses import MosesTokenizer, MosesDetokenizer
self.tok = MosesTokenizer(args.moses_source_lang)
self.detok = MosesDetokenizer(args.moses_target_lang)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (pointer.shape == array.shape), f'Pointer shape {pointer.shape} and array shape {array.shape} mismatched'
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return string.decode(encoding)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0
"
shutil.copytree(folder_path, copy_folder_path, ignore=shutil.ignore_patterns(*ignore_file))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
NT()
self.fail(""Shouldn't be able to construct namedtuple"")
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
if debug:
    print(f'cmd_num = {cmd_num}')
    print(f""cmd_args = {' '.join(cmd_args)}"")
process = Popen(cmd_args, stdout=PIPE, stderr=PIPE)
(p_out, p_err) = process.communicate()
if debug:
    print(p_out)
asm_code = str(p_out).split('\\n')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
return accimage.Image(path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
client = kwargs['client']
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
__import__(name)
skip_it = False
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (len(task.model.heads) == 1)
for j in range(task.model.heads[0].nmb_heads):
    module = getattr(task.model.heads[0], ('prototypes' + str(j)))
    ctx = contextlib.suppress()
    if hasattr(module, 'summon_full_params'):
        ctx = module.summon_full_params()
    with ctx:
        w = module.weight.data.clone()
        w = nn.functional.normalize(w, dim=1, p=2)
        module.weight.copy_(w)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
pointer = getattr(pointer, l[0])
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
model_class = archs_dict[arch.lower()]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
collate._use_shared_memory = True
signal_handling._set_worker_signal_handlers()
torch.set_num_threads(1)
random.seed(seed)
torch.manual_seed(seed)
data_queue.cancel_join_thread()
if (init_fn is not None):
    init_fn(worker_id)
watchdog = ManagerWatchdog()
while watchdog.is_alive():
    try:
        r = index_queue.get(timeout=MP_STATUS_CHECK_INTERVAL)
    except queue.Empty:
        continue
    if (r is None):
        assert done_event.is_set()
        return
    elif done_event.is_set():
        continue
    (idx, batch_indices) = r
    try:
        idx_scale = 0
        if ((len(scale) > 1) and dataset.train):
            idx_scale = random.randrange(0, len(scale))
            dataset.set_scale(idx_scale)
        samples = collate_fn([dataset[i] for i in batch_indices])
        samples.append(idx_scale)
    except Exception:
        data_queue.put((idx, ExceptionWrapper(sys.exc_info())))
    else:
        data_queue.put((idx, samples))
        del samples
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.queue.put(work_batch)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0
"
from apex.parallel import DistributedDataParallel as DDP
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
stdout = subprocess.check_output(['git-lfs', '--version']).decode('utf-8')
print(ANSI.gray(stdout.strip()))
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex import amp
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex import amp
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex.normalization import FusedProphetNetLayerNorm
return FusedProphetNetLayerNorm(normalized_shape, eps, elementwise_affine)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
checkpoint_suffix = args.model_name_or_path.split('-')[(- 1)].split('/')[0]
global_step = int(checkpoint_suffix)
epochs_trained = (global_step // (len(train_dataloader) // args.gradient_accumulation_steps))
steps_trained_in_current_epoch = (global_step % (len(train_dataloader) // args.gradient_accumulation_steps))
logger.info('  Continuing training from checkpoint, will skip to saved global_step')
logger.info('  Continuing training from epoch %d', epochs_trained)
logger.info('  Continuing training from global step %d', global_step)
logger.info('  Will skip the first %d steps in the first epoch', steps_trained_in_current_epoch)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
number = float(text)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
uchar = lookup_unicodechar(escape_sequence[3:(- 1)])
chrval = ord(uchar)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
w = vocab.id2word(i)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
return (annotated + tokens[(span_token_indices[(- 1)] + 1):])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (self.args.is_tpu or self.args.torchscript):
    logger.info('Do inference on TPU or torchscript. Running model 5 times to stabilize compilation')
    timeit.repeat(func, repeat=1, number=5)
runtimes = timeit.repeat(func, repeat=self.args.repeat, number=10)
if (self.args.is_tpu and self.args.torch_xla_tpu_print_metrics):
    import torch_xla.debug.metrics as met
    self.print_fn(met.metrics_report())
return (min(runtimes) / 10.0)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_config_file = cached_path(config_file, cache_dir=cache_dir, force_download=force_download, proxies=proxies, resume_download=resume_download, local_files_only=local_files_only)
if (resolved_config_file is None):
    raise EnvironmentError
config_dict = cls._dict_from_json_file(resolved_config_file)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
shape = tuple(shape)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
return l.index(index)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
self._thread_local.pos = r.body.tell()
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
date = datetime.datetime.strptime(text, in_pattern).date()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
self.data_length = int(task.split(':')[(- 1)])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
import requests
response = request_wrap_timeout(partial(requests.head, url, allow_redirects=True), url)
if (response.status_code != 200):
    etag = None
else:
    etag = response.headers.get('ETag')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.max = len(it)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
state_dict = torch.load((args.directory + '/model.pt'))
model.load_state_dict(state_dict)
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with open(pickle_file, 'rb') as f:
    pickle_data = pickle.load(f)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0
"
recarray = np.core.records.fromarrays(arrdata, dtype=dtypes)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
resolved_vocab_file = cached_path(vocab_file, cache_dir=cache_dir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.vae.load((df_enc_norm_data.shape[1] - 1))
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
paper[key] = json_dict[key]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import fastBPE
self.bpe = fastBPE.fastBPE(codes)
self.bpe_symbol = '@@ '
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
for attr in args.attr.split('.'):
    if attr.isdigit():
        attr = int(attr)
    indict = indict[attr]
print(indict)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import yaml
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return get_numeric_sort_key_fn(all_values)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
new_module = self.replacement_factory[type(module)](module, full_name, self.module_qbits_map)
msglogger.debug('Module {0}: Replacing \n{1} with \n{2}'.format(full_name, module, new_module))
setattr(container, name, new_module)
if ((not distiller.has_children(module)) and distiller.has_children(new_module)):
    for (sub_module_name, sub_module) in new_module.named_modules():
        self._add_qbits_entry(((full_name + '.') + sub_module_name), type(sub_module), current_qbits)
    self.module_qbits_map[full_name] = QBits(acts=current_qbits.acts, wts=None)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import pytest
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(_loss, sample_size, logging_output) = self.task.valid_step(sample, self.model, self.criterion)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import re
import numpy as np
import tensorflow as tf
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
future_mask = future_mask.bool()
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with hidden_cursor(sys.stdout):
    (yield spinner)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
attr = object.__getattr__(name)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
klass = getattr(module, klass_name)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
torch_rng_cuda = rng_state['torch_rng_cuda']
torch.cuda.set_rng_state(torch_rng_cuda)
print('Set torch rng cuda state')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
import sentencepiece as spm
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return accimage.Image(path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
task.load_dataset(subset, combine=False, epoch=1, task_cfg=saved_cfg.task)
dataset = task.dataset(subset)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with torch.no_grad():
    for conv in self.convolutions:
        x = F.dropout(F.relu(conv(x)), 0.5, self.training)
    x = x.transpose(1, 2)
    (outputs, _) = self.lstm(x)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
temp_name = name.attrib['value']
temp_name = temp_name.split('_')[1]
case_name.append(int(temp_name))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import h5py
self.h5py = h5py
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
model.init_hidden_state()
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
model.train_on_del(x, exp_counts, bead_counts, train_slice, valid_slice, true_labels=true_labels_R, batch_size=BATCH_SIZE, max_epochs=FLAGS.max_epochs, num_workers=FLAGS.num_workers, patience=FLAGS.patience, max_norm=FLAGS.max_norm, zscale=(lambda epoch: (1 + (9 * np.exp(((- epoch) / 2))))), device=FLAGS.device, output_size=NUM_TASKS, save_path=os.path.join(SAVE_ROOT, f'best_model_trial_{trial.number}.torch'), log_path=LOG_FILE, torch_seed=FLAGS.seed)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from fairseq.modules.dynamicconv_layer import DynamicconvLayer
return DynamicconvLayer(input_size, kernel_size=kernel_size, padding_l=padding_l, num_heads=num_heads, weight_dropout=weight_dropout, weight_softmax=weight_softmax, bias=bias)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.current = next(self._iter)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
write(((((GLOBAL + bytes(module_name, 'ascii')) + b'\n') + bytes(name, 'ascii')) + b'\n'))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0
"
import doodad
import doodad.mode
import doodad.ssh
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from subword_nmt import apply_bpe
bpe_parser = apply_bpe.create_parser()
bpe_args = bpe_parser.parse_args(['--codes', codes, '--separator', args.bpe_separator])
self.bpe = apply_bpe.BPE(bpe_args.codes, bpe_args.merges, bpe_args.separator, None, bpe_args.glossaries)
self.bpe_symbol = (bpe_args.separator + ' ')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.model.load_state_dict(state_dict)
return
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
fn_args = set(get_args(fn))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
fn = self.inplace_func([], (x <= y))
v = fn()
self.assertTrue(numpy.all((v == (l <= r))), (v, (l <= r)))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
from apex import amp
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
interpol_fnc = interpolate.interp1d(onsets_perf, onsets_score)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
src_dict = getattr(task, 'source_dictionary', None)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import ftfy
import spacy
self.nlp = spacy.load('en', disable=['parser', 'tagger', 'ner', 'textcat'])
self.fix_text = ftfy.fix_text
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
logging.debug(f'Weight norm is removed from {m}.')
torch.nn.utils.remove_weight_norm(m)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
sem_scene = self._sim.semantic_annotations()
object_id = goal.object_id
assert (int(sem_scene.objects[object_id].id.split('_')[(- 1)]) == int(goal.object_id)), f""Object_id doesn't correspond to id in semantic scene objects dictionary for episode: {episode}""
center = sem_scene.objects[object_id].aabb.center
(x_len, _, z_len) = (sem_scene.objects[object_id].aabb.sizes / 2.0)
corners = [(center + np.array([x, 0, z])) for (x, z) in [((- x_len), (- z_len)), ((- x_len), z_len), (x_len, z_len), (x_len, (- z_len)), ((- x_len), (- z_len))]]
map_corners = [maps.to_grid(p[0], p[2], self._coordinate_min, self._coordinate_max, self._map_resolution) for p in corners]
maps.draw_path(self._top_down_map, map_corners, maps.MAP_TARGET_BOUNDING_BOX, self.line_thickness)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
persistent_sorted = sorted(persistent, key=mapper._persistent_sortkey_fn)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
poll_obj = select.poll()
_retry_on_intr(poll_obj.poll, 0)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(yield iterator.__next__())
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
A_eq = _format_A_constraints(A_eq, n_x, sparse_lhs=sparse_lhs)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
import re
import numpy as np
import tensorflow as tf
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
prior_mean = [(float(t) / prior_mean_sum) for t in prior_mean]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1
"
st['key'] = 2.1
self.fail('cannot change type of value for set keys')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
from fairseq import libnat
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
checkpoint_suffix = args.model_name_or_path.split('-')[(- 1)].split('/')[0]
global_step = int(checkpoint_suffix)
epochs_trained = (global_step // (len(train_dataloader) // args.gradient_accumulation_steps))
steps_trained_in_current_epoch = (global_step % (len(train_dataloader) // args.gradient_accumulation_steps))
logger.info('  Continuing training from checkpoint, will skip to saved global_step')
logger.info('  Continuing training from epoch %d', epochs_trained)
logger.info('  Continuing training from global step %d', global_step)
logger.info('  Will skip the first %d steps in the first epoch', steps_trained_in_current_epoch)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
import requests
response = request_wrap_timeout(partial(requests.head, url, allow_redirects=True), url)
if (response.status_code != 200):
    etag = None
else:
    etag = response.headers.get('ETag')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
oldval = getattr(self, key)
assert (oldval == val), ""Attribute '{}' in the metadata of '{}' cannot be set to a different value!\n{} != {}"".format(key, self.name, oldval, val)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import sentencepiece as spm
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import regex as re
self.re = re
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.mkdir(dir_checkpoint)
logging.info('Created checkpoint directory')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
reg_loss = lossfunc(pred, [i.cuda() for i in inps])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
nice = self.__nice__()
classname = self.__class__.__name__
return f'<{classname}({nice}) at {hex(id(self))}>'
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
info['height'] = len(a)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
resolved_vocab_files[file_id] = cached_path(file_path, cache_dir=cache_dir, force_download=force_download, proxies=proxies, resume_download=resume_download, local_files_only=local_files_only, use_auth_token=use_auth_token, user_agent=user_agent)
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from .convert_bert_original_tf_checkpoint_to_pytorch import convert_tf_checkpoint_to_pytorch
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import instaboostfast as instaboost
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex.parallel import DistributedDataParallel as DDP
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import lvis
assert (lvis.__version__ >= '10.5.3')
from lvis import LVISResults, LVISEval
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
vectors = self.m.vectors
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import bz2
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
ret = self.cur_iter.next()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
model_class = ('TF' + config.architectures[0])
transformers_module = __import__('transformers', fromlist=[model_class])
model_cls = getattr(transformers_module, model_class)
model = model_cls(config)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(firstaxis, parity, repetition, frame) = _AXES2TUPLE[axes.lower()]
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with open(save_file, 'r') as f:
    last_saved = f.read()
    last_saved = last_saved.strip()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from pavi import SummaryWriter
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return _ffi_types[dtype]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
tokenizer = cls(*init_inputs, **init_kwargs)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
model_w = model.state_dict()[key]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
best_score = None
best_class_score = None
for epoch_i in range(1, (1 + args.epochs)):
    start_time = time()
    training = adversarial_domain(source_cnn, target_cnn, discriminator, source_train_loader, target_train_loader, target_test_loader, criterion, criterion, optimizer, d_optimizer, best_score, best_class_score, epoch_i, logger, args=args)
    best_score = training['best_score']
    best_class_score = training['best_class_score']
    n_iters = training['n_iters']
    validation = validate(target_cnn, target_test_loader, criterion, args=args)
    clsNames = validation['classNames']
    log = 'Epoch {}/{} '.format(epoch_i, args.epochs)
    log += 'D/Loss {:.3f} Target/Loss {:.3f} '.format(training['d/loss'], training['target/loss'])
    log += '[Val] Target/Loss {:.3f} Target/Acc {:.3f} '.format(validation['loss'], validation['acc'])
    log += log_source
    log += 'Time {:.2f}s'.format((time() - start_time))
    logger.info(log)
    is_best = ((best_score is None) or (validation['avgAcc'] > best_score))
    best_score = (validation['avgAcc'] if is_best else best_score)
    best_class_score = (validation['classAcc'] if is_best else best_class_score)
    state_dict = {'model': target_cnn.state_dict(), 'optimizer': optimizer.state_dict(), 'epoch': epoch_i, 'val/acc': best_score}
    save(args.logdir, state_dict, is_best)
    for (cls_idx, clss) in enumerate(clsNames):
        logger.info('{}: {}'.format(clss, validation['classAcc'][cls_idx]))
    logger.info('Current val. acc.: {}'.format(validation['avgAcc']))
    logger.info('Best val. acc.: {}'.format(best_score))
    classWiseDict = {}
    for (cls_idx, clss) in enumerate(clsNames):
        classWiseDict[clss] = validation['classAcc'][cls_idx].item()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from fairseq.modules.dynamicconv_layer import DynamicconvLayer
return DynamicconvLayer(input_size, kernel_size=kernel_size, padding_l=padding_l, num_heads=num_heads, weight_dropout=weight_dropout, weight_softmax=weight_softmax, bias=bias)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
existing_req = self.get_requirement(name)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (pointer.shape == array.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return int(v)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0
"
(assigned, _) = part.items[index]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex import amp
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
result = Timedelta(r, unit)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
resolved_archive_file = cached_path(archive_file, cache_dir=cache_dir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return distiller.models.create_model(False, checkpoint['dataset'], checkpoint['arch'], checkpoint['is_parallel'], device_ids=None)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import re
import numpy as np
import tensorflow as tf
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (model.embed.weight.shape == init_params[0].shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (list(pt_weight.shape) == list(array.shape))
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
model.decoder.batch_counter = len(training_data)
logger_inner.info(f'Batch counter setting done, value {model.batch_counter}')
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.mkdir(self.data_path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
h[ignore] = 0
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
next(fields)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
auc_[0] = sklearn.metrics.roc_auc_score(labels, probs)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
resolved_corpus_file = cached_path(corpus_file, cache_dir=cache_dir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
loss.backward()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
torch.testing.assert_allclose(a, b, rtol=rtol, atol=atol)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
src_dict = getattr(task, 'source_dictionary', None)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
content = str(self.content, encoding, errors='replace')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
if (len(dim) == 1):
    num_elem = (batch_size - 1.0)
else:
    num_elem = (batch_size * (batch_size - 1.0))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
level = loguru.logger.level(record.levelname).name
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
(im, targ) = next(self.loader)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
pointer = getattr(pointer, l[0])
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(samples, targets) = next(self.loader)
(samples, targets) = to_cuda(samples, targets, self.device)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
chunk = next(self.iterable)
self.read_length += len(chunk)
return chunk
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(self.root)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return self.data[item]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
model_pointer = getattr(model_pointer, sub_layer)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
src_dict = getattr(task, 'source_dictionary', None)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
file_name = os.path.basename(file_path)
target_path = os.path.join(target_resource_dir, file_name)
shutil.copy2(file_path, target_path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
kwargs['kg_path'] = cfg.DATASET.__getattribute__('{}_KG_PATH'.format(mode.upper()))
kwargs['fact_path'] = cfg.DATASET.__getattribute__('{}_KG_PATH'.format(mode.upper()))
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
del self.teacher.model.encoder
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(os.path.dirname(filename))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
len(res)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
import Mykytea
self.ja_word_tokenizer = Mykytea.Mykytea(('-model %s/local/share/kytea/model.bin' % os.path.expanduser('~')))
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import tensorflow as tf
import torch
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
for (it, image_idx) in enumerate(dataset_indices):
    timer.reset()
    with timer.env('Load Data'):
        (img, gt, gt_masks, h, w, num_crowd) = dataset.pull_item(image_idx)
        if cfg.mask_proto_debug:
            with open('scripts/info.txt', 'w') as f:
                f.write(str(dataset.ids[image_idx]))
            np.save('scripts/gt.npy', gt_masks)
        batch = Variable(img.unsqueeze(0))
        if args.cuda:
            batch = batch.cuda()
    with timer.env('Network Extra'):
        preds = net(batch)
    if args.display:
        img_numpy = prep_display(preds, img, h, w)
    elif args.benchmark:
        prep_benchmark(preds, h, w)
    else:
        prep_metrics(ap_data, preds, img, gt, gt_masks, h, w, num_crowd, dataset.ids[image_idx], detections)
    if (it > 1):
        frame_times.add(timer.total_time())
    if args.display:
        if (it > 1):
            print(('Avg FPS: %.4f' % (1 / frame_times.get_avg())))
        plt.imshow(img_numpy)
        plt.title(str(dataset.ids[image_idx]))
        plt.show()
    elif (not args.no_bar):
        if (it > 1):
            fps = (1 / frame_times.get_avg())
        else:
            fps = 0
        progress = (((it + 1) / dataset_size) * 100)
        progress_bar.set_val((it + 1))
        print(('\rProcessing Images  %s %6d / %6d (%5.2f%%)    %5.2f fps        ' % (repr(progress_bar), (it + 1), dataset_size, progress, fps)), end='')
if ((not args.display) and (not args.benchmark)):
    print()
    if args.output_coco_json:
        print('Dumping detections...')
        if args.output_web_json:
            detections.dump_web()
        else:
            detections.dump()
    else:
        if (not train_mode):
            print('Saving data...')
            with open(args.ap_data_file, 'wb') as f:
                pickle.dump(ap_data, f)
        return calc_map(ap_data)
elif args.benchmark:
    print()
    print()
    print('Stats for the last frame:')
    timer.print_stats()
    avg_seconds = frame_times.get_avg()
    print(('Average: %5.2f fps, %5.2f ms' % ((1 / frame_times.get_avg()), (1000 * avg_seconds))))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
setattr(self, key, value)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_vocab_file = cached_path(vocab_file, cache_dir=cache_dir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex import amp
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from transformers.convert_xlnet_original_tf_checkpoint_to_pytorch import convert_xlnet_checkpoint_to_pytorch
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
meth_node = parent[name]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
cmd = cls.rgetattr(cls, cmd_name)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
prediction = w.acts[(- 1)]['text']
word_statistics['context_list'].append(w.acts[0]['text'])
word_statistics['pure_pred_list'].append(prediction)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
text_a = line[3]
text_b = line[4]
label = line[0]
X.append([text_a, text_b])
Y.append(label)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
ret = next(self.iter)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import cityscapesscripts.evaluation.evalInstanceLevelSemanticLabeling as CSEval
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
download_from_github(repo_addr='csjunxu/PolyU-Real-World-Noisy-Images-Dataset', repo_dir='CroppedImages', output_dir=os.path.join(output_dir, 'Train'))
",0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
merged = self.identity_map[key]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from pysqlcipher import dbapi2 as sqlcipher
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import tensorflow_datasets as tfds
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (sample_size > 0):
    self.optimizer.multiply_grads((self.args.distributed_world_size / float(sample_size)))
grad_norm = self.optimizer.clip_grad_norm(self.args.clip_norm)
self._prev_grad_norm = grad_norm
self.optimizer.step()
self.set_num_updates((self.get_num_updates() + 1))
self.task.update_step(self._num_updates, self.model)
ntokens = logging_output.get('ntokens', 0)
nsentences = logging_output.get('nsentences', 0)
self.meters['wps'].update(ntokens)
self.meters['ups'].update(1.0)
self.meters['wpb'].update(ntokens)
self.meters['bsz'].update(nsentences)
self.meters['gnorm'].update(grad_norm)
self.meters['clip'].update((1.0 if ((grad_norm > self.args.clip_norm) and (self.args.clip_norm > 0)) else 0.0))
self.meters['train_loss'].update(logging_output.get('loss', 0), sample_size)
if ('train_acc' in self.meters):
    self.meters['train_acc'].update(logging_output.get('acc', 0), sample_size)
if ('nll_loss' in logging_output):
    self.meters['train_nll_loss'].update(logging_output.get('nll_loss', 0), ntokens)
if ((self.args.empty_cache_freq > 0) and ((((self.get_num_updates() + self.args.empty_cache_freq) - 1) % self.args.empty_cache_freq) == 0) and torch.cuda.is_available() and (not self.args.cpu)):
    torch.cuda.empty_cache()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
checkpoint_suffix = args.model_name_or_path.split('-')[(- 1)].split('/')[0]
global_step = int(checkpoint_suffix)
epochs_trained = (global_step // (len(train_dataloader) // args.gradient_accumulation_steps))
steps_trained_in_current_epoch = (global_step % (len(train_dataloader) // args.gradient_accumulation_steps))
logger.info('  Continuing training from checkpoint, will skip to saved global_step')
logger.info('  Continuing training from epoch %d', epochs_trained)
logger.info('  Continuing training from global step %d', global_step)
logger.info('  Will skip the first %d steps in the first epoch', steps_trained_in_current_epoch)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
self.tryParse(instring, loc)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs('./Result_txt/')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
check_is_fitted(ard, msg='Random message %(name)s, %(name)s')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
with torch.no_grad():
    for batch in tqdm(loader):
        input_tensor = batch['image'].to(device)
        locations = batch['location']
        logits = model(input_tensor)
        labels = logits.argmax(dim=CHANNELS_DIMENSION, keepdim=True)
        outputs = labels
        aggregator.add_batch(outputs, locations)
success = True
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex.parallel import DistributedDataParallel as DDP
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (filename is None):
    raise IOError('bad filename')
with open(filename, 'r') as f:
    self.cache = pickle.load(f)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if ('jieba' not in sys.modules):
    import jieba
else:
    jieba = sys.modules['jieba']
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import Mykytea
self.ja_word_tokenizer = Mykytea.Mykytea(('-model %s/local/share/kytea/model.bin' % os.path.expanduser('~')))
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
torch_type = x.type()
return (torch_type.endswith('FloatTensor') or torch_type.endswith('HalfTensor') or torch_type.endswith('DoubleTensor'))
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return (tensor1 == tensor2)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
e_error = evaluation_error[index]
for _ in range(noise_draws):
    e_error = sanitize_error_fn(e_error, V_n, B, test_epsilon)
upper_bound = ((e_error + (((4.0 * B) * np.log((((2.0 * i) * (i + 1)) / delta_upper))) / V_n)) + np.sqrt(((((2.0 * B) * e_error) * np.log((((2.0 * i) * (i + 1)) / delta_upper))) / V_n)))
if (correct_for_noise and (test_epsilon > 0)):
    upper_bound += ((noise_draws * np.log(((i * (i + 1)) / delta_upper))) / (V_n * test_epsilon))
if (upper_bound <= (2.0 * tau)):
    return (T_n, T_n)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
logging.info('Estimating ratios on single-theta test sample, testing theta0 grid')
theta_grid_points = np.meshgrid(*theta_grid, indexing='ij')
theta_grid_points = np.array(theta_grid_points).reshape((len(theta_grid), (- 1)))
theta_grid_points = theta_grid_points.T
log_r_hat_grid = []
for theta in theta_grid_points:
    logging.debug('Grid point %s vs %s', theta, theta1_grid)
    log_r_hat_grid.append(inference.predict_ratio(theta, theta1_grid, xs_singletheta[:grid_n_samples], log=True))
np.save((result_folder + '/theta_grid.npy'), theta_grid_points)
log_r_hat_grid = np.asarray(log_r_hat_grid)
np.save((((((result_folder + '/log_r_hat_') + test_filename) + '_singletheta_evaluated_on_grid_') + result_filename) + '.npy'), log_r_hat_grid)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
float(inp)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
(encoded_batch, batch) = chunks.pop()
result = self.model(encoded_batch, batch, cache=cache)
new_cache = result.get('cache')
if new_cache:
    updated_cache.extend(utils.split_or_chunk(new_cache, len(batch)))
full_logits = result['logits']
logits.append(full_logits[:, :, (- self.span):])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
systems.remove(uid)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
h = self.activation_function(F.linear(h, torch.t((M * W)), b))
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
SharedVariable(name='u', type=Tensor(broadcastable=[False], dtype='float64'), value=dict(), strict=False)
assert 0
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
usages2 = usages2[target]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
result = self.index[i].startswith(path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(_loss, sample_size, logging_output) = self.task.valid_step(sample, self.model, self.criterion)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
setattr(self, key, value)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
json.dump(run_info, f)
f.write('\n')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0
"
return self.instance2index[instance]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return (_model_extensions[(arch, dataset)] is not None)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.mkdir((('results/' + str(samples_per_class)) + '_samples_plots'))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
model.train_on_del(x, exp_counts, bead_counts, train_slice, valid_slice, true_labels=true_labels_R, batch_size=BATCH_SIZE, max_epochs=FLAGS.max_epochs, patience=FLAGS.patience, max_norm=FLAGS.max_norm, zscale=(lambda epoch: (1 + (9 * np.exp(((- epoch) / 2))))), device=FLAGS.device, output_size=NUM_TASKS, save_path=os.path.join(SAVE_ROOT, f'best_model_trial_{trial.number}.torch'), log_path=LOG_FILE, torch_seed=FLAGS.seed)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
src_dict = getattr(task, 'source_dictionary', None)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
mkdir(dirname, 493)
",0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import_module(package)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from torchvision import _C as C
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return bool(eval(x))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
return mapping[key]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(test_X, test_y) = next(test_iter)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
f_iter = iter(field)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
feats_dict = self.extract(device, model, self.path_list[idx])
action_on_extraction(feats_dict, self.path_list[idx], self.output_path, self.on_extraction)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
repo_dpath = dirname(dirname(dirname(__file__)))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from spacy.lang.en import English
spacy_nlp._nlp = English()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import torch
system_device_num = 0
if torch.cuda.is_available():
    system_device_num = torch.cuda.device_count()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import h5py
self.h5py = h5py
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(dir_path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from deepspeed.ops.op_builder import CPUAdamBuilder
return CPUAdamBuilder().load()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
c_vision.RandomResizeWithBBox((100, 100, 100))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
start_time = time.time()
opt.zero_grad()
if (discriminator is not None):
    opt_disc.zero_grad()
if is_copy_grad:
    model.zero_copy_grad()
train_tmp_buffer = []
for manifest_id in range(len(train_data_buffer)):
    train_tmp_buffer.insert(0, train_data_buffer[manifest_id].pop())
model.train()
for manifest_id in range(len(train_tmp_buffer)):
    (tr_data, val_data) = train_tmp_buffer.pop()
    (tr_inputs, tr_input_sizes, tr_percentages, tr_targets, tr_target_sizes) = tr_data
    (val_inputs, val_input_sizes, val_percentages, val_targets, val_target_sizes) = val_data
    if args.cuda:
        tr_inputs = tr_inputs.cuda()
        tr_targets = tr_targets.cuda()
    if (discriminator is None):
        (tr_loss, tr_cer, tr_num_char) = self.forward_one_batch(model, vocab, tr_inputs, tr_targets, tr_percentages, tr_input_sizes, tr_target_sizes, smoothing, loss_type, verbose=False, discriminator=None, accent_id=None)
    elif args.adversarial:
        (tr_loss, tr_cer, tr_num_char, disc_loss, enc_loss) = self.forward_one_batch(model, vocab, tr_inputs, tr_targets, tr_percentages, tr_input_sizes, tr_target_sizes, smoothing, loss_type, verbose=False, discriminator=discriminator, accent_id=manifest_id)
    else:
        (tr_loss, tr_cer, tr_num_char, disc_loss) = self.forward_one_batch(model, vocab, tr_inputs, tr_targets, tr_percentages, tr_input_sizes, tr_target_sizes, smoothing, loss_type, verbose=False, discriminator=discriminator, accent_id=manifest_id, multi_task=True)
    total_cer += tr_cer
    total_char += tr_num_char
    del tr_inputs, tr_input_sizes, tr_percentages, tr_targets, tr_target_sizes, tr_data
    total_loss += tr_loss.item()
    tr_loss = (tr_loss / len(train_data_list))
    if (discriminator is not None):
        if args.adversarial:
            if args.beta_decay:
                beta = (beta * beta_decay)
                disc_loss = (beta * disc_loss)
            else:
                disc_loss = (0.5 * disc_loss)
            total_disc_loss += disc_loss.item()
            total_enc_loss += enc_loss.item()
            disc_loss = (disc_loss / len(train_data_list))
            enc_loss = (enc_loss / len(train_data_list))
            tr_loss = ((tr_loss + disc_loss) + enc_loss)
            tr_loss.backward()
            del disc_loss, enc_loss
        else:
            total_disc_loss += disc_loss.item()
            disc_loss = (disc_loss / len(train_data_list))
            tr_loss = (tr_loss + disc_loss)
            tr_loss.backward()
            del disc_loss
    else:
        tr_loss.backward()
    del tr_loss
if args.clip:
    torch.nn.utils.clip_grad_norm_(model.parameters(), args.max_norm)
opt.step()
if (discriminator is not None):
    opt_disc.step()
last_sum_cer.append(total_cer)
last_sum_char.append(total_char)
last_sum_loss.append(total_loss)
end_time = time.time()
diff_time = (end_time - start_time)
total_time += diff_time
if (discriminator is None):
    print('(Iteration {}) TRAIN LOSS:{:.4f} CER:{:.2f}% LR:{:.7f} TOTAL TIME:{:.7f}'.format((it + 1), (total_loss / len(train_data_list)), ((total_cer * 100) / total_char), self.get_lr(opt), total_time))
    logging.info('(Iteration {}) TRAIN LOSS:{:.4f} CER:{:.2f}% LR:{:.7f} TOTAL TIME:{:.7f}'.format((it + 1), (total_loss / len(train_data_list)), ((total_cer * 100) / total_char), self.get_lr(opt), total_time))
elif args.adversarial:
    print('(Iteration {}) TRAIN LOSS:{:.4f} DISC LOSS:{:.4f} ENC LOSS:{:.4f} CER:{:.2f}% LR:{:.7f} TOTAL TIME:{:.7f}'.format((it + 1), (total_loss / len(train_data_list)), (total_disc_loss / len(train_data_list)), (total_enc_loss / len(train_data_list)), ((total_cer * 100) / total_char), self.get_lr(opt), total_time))
    logging.info('(Iteration {}) TRAIN LOSS:{:.4f} DISC LOSS:{:.4f} ENC LOSS:{:.4f} CER:{:.2f}% LR:{:.7f} TOTAL TIME:{:.7f}'.format((it + 1), (total_loss / len(train_data_list)), (total_disc_loss / len(train_data_list)), (total_enc_loss / len(train_data_list)), ((total_cer * 100) / total_char), self.get_lr(opt), total_time))
else:
    print('(Iteration {}) TRAIN LOSS:{:.4f} DISC LOSS:{:.4f} CER:{:.2f}% LR:{:.7f} TOTAL TIME:{:.7f}'.format((it + 1), (total_loss / len(train_data_list)), (total_disc_loss / len(train_data_list)), ((total_cer * 100) / total_char), self.get_lr(opt), total_time))
    logging.info('(Iteration {}) TRAIN LOSS:{:.4f} DISC LOSS:{:.4f} CER:{:.2f}% LR:{:.7f} TOTAL TIME:{:.7f}'.format((it + 1), (total_loss / len(train_data_list)), (total_disc_loss / len(train_data_list)), ((total_cer * 100) / total_char), self.get_lr(opt), total_time))
if (((it + 1) % last_summary_every) == 0):
    print('(Summary Iteration {} | MA {}) TRAIN LOSS:{:.4f} CER:{:.2f}%'.format((it + 1), window_size, (sum(last_sum_loss) / len(last_sum_loss)), ((sum(last_sum_cer) * 100) / sum(last_sum_char))), flush=True)
    logging.info('(Summary Iteration {} | MA {}) TRAIN LOSS:{:.4f} CER:{:.2f}%'.format((it + 1), window_size, (sum(last_sum_loss) / len(last_sum_loss)), ((sum(last_sum_cer) * 100) / sum(last_sum_char))))
if (((it + 1) % evaluate_every) == 0):
    print('')
    logging.info('VALID')
    model.eval()
    final_valid_losses = []
    final_valid_cers = []
    with torch.no_grad():
        for ind in range(len(valid_loader_list)):
            valid_loader = valid_loader_list[ind]
            (total_valid_loss, total_valid_cer, total_valid_wer, total_valid_char, total_valid_word) = (0, 0, 0, 0, 0)
            valid_pbar = tqdm(iter(valid_loader), leave=True, total=len(valid_loader))
            for (i, data) in enumerate(valid_pbar):
                (src, trg, src_percentages, src_lengths, trg_lengths) = data
                if args.cuda:
                    src = src.cuda()
                    trg = trg.cuda()
                (loss, cer, num_char) = self.forward_one_batch(model, vocab, src, trg, src_percentages, src_lengths, trg_lengths, smoothing, loss_type)
                total_valid_cer += cer
                total_valid_char += num_char
                total_valid_loss += loss.item()
                valid_pbar.set_description('(Iteration {}) VALID SET {} LOSS:{:.4f} CER:{:.2f}%'.format((it + 1), ind, (total_valid_loss / (i + 1)), ((total_valid_cer * 100) / total_valid_char)))
            final_valid_loss = (total_valid_loss / len(valid_loader))
            final_valid_cer = ((total_valid_cer * 100) / total_valid_char)
            final_valid_losses.append(final_valid_loss)
            final_valid_cers.append(final_valid_cer)
            print('(Iteration {}) VALID SET {} LOSS:{:.4f} CER:{:.2f}%'.format((it + 1), ind, final_valid_loss, final_valid_cer))
            logging.info('(Iteration {}) VALID SET {} LOSS:{:.4f} CER:{:.2f}%'.format((it + 1), ind, final_valid_loss, final_valid_cer))
    metrics = {}
    avg_valid_loss = (sum(final_valid_losses) / len(final_valid_losses))
    avg_valid_cer = (sum(final_valid_cers) / len(final_valid_cers))
    metrics['avg_valid_loss'] = (sum(final_valid_losses) / len(final_valid_losses))
    metrics['avg_valid_cer'] = (sum(final_valid_cers) / len(final_valid_cers))
    metrics['valid_loss'] = final_valid_losses
    metrics['valid_cer'] = final_valid_cers
    metrics['history'] = history
    history.append(metrics)
    print('(Iteration {}) AVG VALID LOSS:{:.4f} AVG CER:{:.2f}%'.format((it + 1), (sum(final_valid_losses) / len(final_valid_losses)), (sum(final_valid_cers) / len(final_valid_cers))))
    logging.info('(Iteration {}) AVG VALID LOSS:{:.4f} AVG CER:{:.2f}%'.format((it + 1), (sum(final_valid_losses) / len(final_valid_losses)), (sum(final_valid_cers) / len(final_valid_cers))))
    if (((it + 1) % args.save_every) == 0):
        save_joint_model(model, vocab, (it + 1), opt, metrics, args, best_model=False)
        if (discriminator is not None):
            save_discriminator(discriminator, (it + 1), opt_disc, args, best_model=False)
    (early_stop_criteria, early_stop_val)
    if (early_stop_criteria == 'cer'):
        print('CRITERIA: CER')
        if (best_valid_val > avg_valid_cer):
            count_stop = 0
            best_valid_val = avg_valid_cer
            save_joint_model(model, vocab, (it + 1), opt, metrics, args, best_model=True)
            if (discriminator is not None):
                save_discriminator(discriminator, (it + 1), opt_disc, args, best_model=True)
        else:
            print('count_stop:', count_stop)
            count_stop += 1
    else:
        print('CRITERIA: LOSS')
        if (best_valid_val > avg_valid_loss):
            count_stop = 0
            best_valid_val = avg_valid_loss
            save_meta_model(model, vocab, (it + 1), inner_opt, outer_opt, metrics, args, best_model=True)
        else:
            count_stop += 1
            print('count_stop:', count_stop)
    if (count_stop >= early_stop_val):
        logging.info('EARLY STOP')
        print('EARLY STOP\n')
        break
it += 1
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(save_folder)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
layer += [torch.nn.Conv2d(in_channels=in_channels, out_channels=v, kernel_size=1, bias=True), torch.nn.BatchNorm2d(v), torch.nn.ReLU()]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
resolved_archive_file = cached_path(archive_file, cache_dir=None)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (os.path.exists(u_path) or os.path.exists(utf8_path)):
    return True
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0
"
method = getattr(callback, notification)
method(*args, **kwargs)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
import sentencepiece as spm
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
global_step = int(args.model_name_or_path.split('-')[(- 1)].split('/')[0])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
repo_dpath = dirname(dirname(__file__))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
shutil.rmtree(f'{databin_dir}', ignore_errors=True)
os.mkdir(f'{databin_dir}')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
float(line[1])
word = line[0]
if (word in self.worddict):
    embeddings[word] = line[1:]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
iter_data.append(str(diff_per_component_per_iter[c][iter]))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
torch._utils._rebuild_tensor_v2
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if os.path.isdir(env.srcdir):
    shutil.rmtree(env.srcdir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (o.start == d.start)
assert (o.end == d.end)
assert (o.pitch == d.pitch)
assert (o.velocity == d.velocity)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
_ = self.unnecessary_tags.index(child.tag)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
from apex import amp
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
av = self.it_specs.av_param(self.iteration)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex import amp
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
library = cdll.LoadLibrary(self.get_filename())
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
metadata = state_dict._metadata
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
iv0 = theano.gof.op.get_test_value(inputs[0])
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
constraint = dist.arg_constraints[name]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
pointer = getattr(pointer, scope_names[0])
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
outside_position = pred_idx_list.tolist().index(outside_index)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
from transformers.convert_albert_original_tf_checkpoint_to_pytorch import convert_tf_checkpoint_to_pytorch
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
act = deepcopy(agents[0].act())
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from nltk.tokenize import word_tokenize
self.word_tokenize = word_tokenize
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import pandas as pd
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
score = float(row[args.score_col])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
ev0 = theano.gof.op.get_test_value(eval_points[0])
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(features, dataset, examples) = (features_and_dataset['features'], features_and_dataset['dataset'], features_and_dataset['examples'])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
c[:b]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
count = self._unique_id_handlers[unique_id].get('count', None)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
array = numpy.reshape(array, pt_weight.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import tensorflow as tf
import torch
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert False
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(('%s/start_scale=%d' % (dir2save, start_scale)))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
augmentation = perturbation_types[augment_name](**augment_kwargs)
augmentations.append([prob, augmentation])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(_loss, sample_size, logging_output) = self.task.valid_step(sample, self.model, self.criterion)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return bytes([BCHAR_TO_BYTE[bc] for bc in x]).decode('utf-8')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
from fairseq import libnat
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return self._get_parser_to_modify()[0]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
gpu_rank = onmt.utils.distributed.multi_init(opt, device_id)
if (gpu_rank != opt.gpu_ranks[device_id]):
    raise AssertionError('An error occurred in                   Distributed initialization')
single_main(opt, device_id, batch_queue, semaphore)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with open(save_file, 'r') as f:
    last_saved = f.read()
    last_saved = last_saved.strip()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
cocoDt = cocoGt.loadRes(result_files[metric])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (int(name.split('.')[2]) < cutoff):
    p.requires_grad = (False if (epoch <= 5) else True)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
return self._db_log_idx
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(self.next_input, self.next_target, _, _) = next(self.loader)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
data_time = storage.history('data_time').avg(20)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
tarinfo.uname = pwd.getpwuid(tarinfo.uid)[0]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (list(self.args.labels_map.keys()) == self.args.labels_list)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import cv2
data.append(('cv2', cv2.__version__))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
pi_temp = beamsearch.get_hypothesis(ends)
(cost_temp, _) = self.problem.get_costs(nodes, pi_temp)
(cost_temp, pi_temp) = (cost_temp.cpu().numpy(), pi_temp.cpu().numpy())
sequences.append(pi_temp)
costs.append(cost_temp)
ids.append(list(range(batch_size)))
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
traced_f = torch.jit.trace(f, (x,))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
module = importlib.import_module(script)
model_class = getattr(module, class_name)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import re
import numpy as np
import tensorflow as tf
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
metrics = trainer.train()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(_loss, sample_size, logging_output) = self.task.valid_step(sample, self.model, self.criterion)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
ddp_model.to(device)
assert False, 'Changing devices should be caught and not supported'
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
value = int(value)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
(k, v) = s.split(b'\x00', 1)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
x /= a
assert_equal(x, (y / a))
",0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
from nltk.tokenize import word_tokenize
self.word_tokenize = word_tokenize
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return next(self.parameters()).device
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return self.instance2index[instance]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
acts[index] = agent.act(timeout=None)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
os.makedirs(path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
mask_without_bos_eos = (word_inputs > 0).long()
embedded_inputs = self._word_embedding(word_inputs)
(type_representation, mask) = add_sentence_boundary_token_ids(embedded_inputs, mask_without_bos_eos, self._bos_embedding, self._eos_embedding)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(loc, tokens) = self.parseImpl(instring, preloc, doActions)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
setattr(self, key, value)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
console = distribution.get_entry_map('console_scripts')
gui = distribution.get_entry_map('gui_scripts')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex.normalization import FusedLayerNorm
return FusedLayerNorm(normalized_shape, eps, elementwise_affine)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (pointer.shape == array.shape), f'Pointer shape {pointer.shape} and array shape {array.shape} mismatched'
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex import amp
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
for es in embed_sets:
    dialog[es].append(vocabs[es][utter[token]])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
np.datetime64(s)
return s
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
from transformers.convert_transfo_xl_original_tf_checkpoint_to_pytorch import convert_transfo_xl_checkpoint_to_pytorch
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
label = int(label)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
from apex import amp
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
module = sys.modules[moduleOrReq]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
i1 = self.read_buffer.index(cut_start)
i2 = self.read_buffer.index(cut_end)
frac = self.read_buffer[i1:(i2 + 1)]
self.read_buffer = self.read_buffer[(i2 + 1):]
break
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
layer.mask
return True
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
img = Image.open(img_path).convert('RGB')
got_img = True
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (pointer.shape == array.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (len(y) == 1):
    x.__getitem__(*y)
else:
    x.__getitem__(y)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
return d[val_str]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex.optimizers import FP16_Optimizer
from apex.optimizers import FusedAdam
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (list(symbolic_weight.shape) == list(array.shape))
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
node = et.getroot()
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
npars = pl_module.model.model.num_parameters()
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with open(f, 'r', encoding='utf-8') as fd:
    self.add_from_file(fd)
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.optimize = int(self.optimize)
if (not (0 <= self.optimize <= 2)):
    raise ValueError
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
s = str(n.type())
s = s[(s.find('(') + 1):s.find(')')]
tensor['shape'] = tuple(map((lambda x: int(x)), s.split(',')))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
return self.__getitem__(key)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import pydot
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.flake8.exit()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0
"
processor = processors[data_args.task_name]()
label_list = processor.get_labels()
num_labels = len(label_list)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
state_dict = torch.load(pretrain_path, map_location=torch.device('cpu'))
logger.info(f'Loading pretrained model from {pretrain_path}')
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (pointer.shape == array.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import git
doodad_path = osp.abspath(osp.join(osp.dirname(doodad.__file__), os.pardir))
dirs = (conf.CODE_DIRS_TO_MOUNT + [doodad_path])
git_infos = []
for directory in dirs:
    try:
        repo = git.Repo(directory)
        try:
            branch_name = repo.active_branch.name
        except TypeError:
            branch_name = '[DETACHED]'
        git_infos.append(GitInfo(directory=directory, code_diff=repo.git.diff(None), code_diff_staged=repo.git.diff('--staged'), commit_hash=repo.head.commit.hexsha, branch_name=branch_name))
    except git.exc.InvalidGitRepositoryError:
        pass
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(save_path)
os.makedirs(f'{save_path}/ckpt')
os.makedirs(f'{save_path}/metrics')
",0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.state = state
p.callable(pslice)
symstack.append(sym)
state = goto[statestack[(- 1)]][pname]
statestack.append(state)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0
"
return int(v)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0
"
hasIgnoreExprs = (not (not self.ignoreExprs))
while 1:
    if check_ender:
        try_not_ender(instring, loc)
    if hasIgnoreExprs:
        preloc = self_skip_ignorables(instring, loc)
    else:
        preloc = loc
    (loc, tmptokens) = self_expr_parse(instring, preloc, doActions)
    if (tmptokens or tmptokens.haskeys()):
        tokens += tmptokens
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_archive_file = cached_path(archive_file, cache_dir=cache_dir, force_download=force_download, proxies=proxies, resume_download=resume_download, local_files_only=local_files_only, use_auth_token=use_auth_token)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
x = np.asarray(x, dtype=float)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
with maybe_no_sync():
    (loss, sample_size_i, logging_output) = self.task.train_step(sample=sample, model=self.model, criterion=self.criterion, optimizer=self.optimizer, update_num=self.get_num_updates(), ignore_grad=is_dummy_batch)
    del loss
logging_outputs.append(logging_output)
sample_size += sample_size_i
if (self.cuda and (self.get_num_updates() == 0)):
    torch.cuda.empty_cache()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
_ = audio.Fade(0, (- 1))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
s_expr = parser.parse_query(sparql, parse['TopicEntityMid'])
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import psutil
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (p_i.shape == arr_i.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
ckpt = torch.load(model_path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
args.model_type = args.model_type.lower()
(model_class, tokenizer_class) = MODEL_CLASSES[args.model_type]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
for _ in range(self.chunk_size):
    chunk.append(next(self.itr))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_archive_file = cached_path(archive_file, cache_dir=cache_dir, force_download=force_download, resume_download=resume_download, proxies=proxies)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if self.args.cuda:
    model.cuda()
optimizer = torch.optim.Adam(model.parameters(), lr=self.args.lr, weight_decay=self.args.weight_decay)
(model, val_acc) = self.run_model(model, optimizer, self.loss_fn, self.data, self.epochs, cuda=self.args.cuda)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
attr = object.__getattr__(name)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (not self._module.batch_first):
    raise ConfigurationError('Our encoder semantics assumes batch is always first!')
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
report = subprocess.check_output(command, cwd=self.texcache, stderr=subprocess.STDOUT)
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
dates.append(datetime(int(year_match), MONTH_NUMBERS[month], DAY_NUMBERS[day]))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
(firstaxis, parity, repetition, frame) = _AXES2TUPLE[axes.lower()]
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return functools.reduce(getattr, self.attrs, module)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.optimizer = tf.keras.optimizers.get({'class_name': self.args.optimizer_name, 'config': {'learning_rate': self.args.learning_rate, 'epsilon': self.args.adam_epsilon}})
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
out = _minimal_ext_cmd(['git', 'rev-parse', '--short', 'HEAD'])
GIT_REVISION = out.strip().decode('ascii')
if (len(GIT_REVISION) == 0):
    raise OSError
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return object.__format__(self, format_spec)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
return (zips.index(z), f)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
trace = torch.jit.trace(model, args)
graph = trace.graph
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(conn, address) = sock.accept()
conn.setblocking(False)
",0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import sentencepiece as spm
self.sp = spm.SentencePieceProcessor()
self.sp.Load(vocab)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
task = self.curr_params
task = np.concatenate([task[k].reshape((- 1)) for k in task.keys()])[:, np.newaxis]
return task
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
max_length = lengths[i]
if (column_length > max_length):
    lengths[i] = column_length
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (not self.for_bert):
    os.mkdir(os.path.join(data_dir, 'procressed_TR'))
else:
    os.mkdir(os.path.join(data_dir, 'procressed_TR_Bert'))
",0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(auth_type, auth_info) = value.split(None, 1)
auth_type = auth_type.lower()
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
setattr(self, key, value)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import instaboostfast as instaboost
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return proxies[module]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
pose_data = pose_label['people'][0]['pose_keypoints']
pose_data = np.array(pose_data)
pose_data = pose_data.reshape(((- 1), 3))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
iter(data[0])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
os.link(sourcename, targname)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
result.encode('ascii')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0
"
os.makedirs(directory)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
response = requests.head(url, allow_redirects=True)
if (response.status_code != 200):
    etag = None
else:
    etag = response.headers.get('ETag')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex.normalization import FusedLayerNorm
return FusedLayerNorm(normalized_shape, eps, elementwise_affine)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if go:
    prevWords += ('-' + corpus[(ind - bi)].split()[1])
else:
    prevWords += '-NONE'
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
batch_outputs[key] = torch.tensor(value)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
self.vis.images(images, nrow=ncols, win=(self.display_id + 1), padding=2, opts=dict(title=(title + ' images')))
label_html = ('<table>%s</table>' % label_html)
self.vis.text((table_css + label_html), win=(self.display_id + 2), opts=dict(title=(title + ' labels')))
",0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return spaces.Box(shape=self.observe().shape, low=0, high=1, dtype=np.float32)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
predictor = predictors.PREDICTOR_REGISTRY[pred](args)
decoder.add_predictor(pred, predictor)
logging.info('Initialized predictor {}'.format(pred))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(output_path_multi_task)
",0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
ipython_pylab = (not pyplot.show._needmain)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_config_file = cached_path(config_file, cache_dir=cache_dir, force_download=force_download, proxies=proxies, resume_download=resume_download, local_files_only=local_files_only)
if (resolved_config_file is None):
    raise EnvironmentError
config_file = Config.load_yaml(resolved_config_file)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
torch_type = x.type()
return (torch_type.endswith('FloatTensor') or torch_type.endswith('HalfTensor') or torch_type.endswith('DoubleTensor'))
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
id_test_seen = (att_feats_dat['test_seen_loc'].squeeze() - 1)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return getattr(self.stream, name)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
for _ in range(100):
    (yield next(frame_seq))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
repo_dpath = dirname(dirname(__file__))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex import amp
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import torch
import tensorflow as tf
from tensorflow.python.keras import backend as K
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(tag, type) = chunkTag.split('-', 1)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
chkpt['model'] = {k: v for (k, v) in chkpt['model'].items() if (model.state_dict()[k].numel() == v.numel())}
model.load_state_dict(chkpt['model'], strict=False)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_vocab_files = {}
for (file_id, file_path) in vocab_files.items():
    if (file_path is None):
        resolved_vocab_files[file_id] = None
    else:
        resolved_vocab_files[file_id] = cached_path(file_path, cache_dir=cache_dir, force_download=force_download, proxies=proxies, resume_download=resume_download, local_files_only=local_files_only)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (model.tokens_embed.weight.shape == init_params[1].shape)
assert (model.positions_embed.weight.shape == init_params[0].shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.firstMatchChar = matchString[0]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
image = self.image_loader.load(self.image_id_to_image_path(example['image_id']))
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import cityscapesscripts.helpers.labels as CSLabels
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex import amp
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_config_file = cached_path(config_file, cache_dir=cache_dir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.optimizer.load_state_dict(optimizer_state)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
tgt_inputs = next(tgt_iterator)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
config = runpy.run_path(data)['config_dict']
return config
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import spacy
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import instaboostfast as instaboost
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(file_type, filename, path) = _search_zip(module_parts, self._zipimporters)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from sacremoses import MosesTokenizer, MosesDetokenizer
self.tok = MosesTokenizer(args.moses_source_lang)
self.detok = MosesDetokenizer(args.moses_target_lang)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex import amp
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
es = self.es
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.mkdir(dir_path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
src_dict = getattr(task, 'source_dictionary', None)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
del module.target_input
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
user_paths = os.environ['PATH'].split(os.pathsep)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return bpe.is_beginning_of_word(tok)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
ax.zaxis.set_major_formatter(null_formatter)
ax.zaxis.set_minor_formatter(null_formatter)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
dtype = x.dtype
type_ = dtype.type
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import onnxruntime
ort_version = parse(onnxruntime.__version__)
if (ort_version < ORT_QUANTIZE_MINIMUM_VERSION):
    raise ImportError(f'''We found an older version of onnxruntime ({onnxruntime.__version__}) but we require onnxruntime to be >= {minimum_version} to enable all the conversions options.
Please update onnxruntime by running `pip install --upgrade onnxruntime`''')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
u = getattr(self.module, (self.name + '_u'))
v = getattr(self.module, (self.name + '_v'))
w = getattr(self.module, (self.name + '_bar'))
return True
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
repo_dpath = dirname(dirname(__file__))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
cocoDt = cocoGt.loadRes(result_files[res_type])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return [self.protocol_parser[x] for x in filenames]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with open(key_pkl, 'rb') as f:
    key_data = pickle.load(f)
",0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(ip, ap) = find_map_num(product, atom_tag)
if ((ar.GetChiralTag() != ChiralType.CHI_UNSPECIFIED) or (ap.GetChiralTag() != ChiralType.CHI_UNSPECIFIED)):
    tetrahedral_atoms.append((atom_tag, ar, ap))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
modname = klass.__module__
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.clear_location(item.path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (pointer.shape == array.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return self.data[item]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return spaces.Box(shape=self.shape, low=0, high=1, dtype=np.float32)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_archive_file = cached_path(archive_file, cache_dir=cache_dir, force_download=force_download, proxies=proxies)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from flax.metrics.tensorboard import SummaryWriter
summary_writer = SummaryWriter(log_dir=Path(training_args.output_dir))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
src_dict = getattr(task, 'source_dictionary', None)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (model.tokens_embed.weight.shape == init_params[1].shape)
assert (model.positions_embed.weight.shape == init_params[0].shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(yield next(it_cord))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
setter(var)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
next(module.parameters())
return True
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
p = getattr(m, buffer_name)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(in_queue, out_queue) = workers[device]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
int(string)
return True
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
os.makedirs(save_path)
",0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import ftfy
from spacy.lang.en import English
_nlp = English()
self.nlp = _nlp.Defaults.create_tokenizer(_nlp)
self.fix_text = ftfy.fix_text
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
checkpoint_suffix = args.model_name_or_path.split('-')[(- 1)].split('/')[0]
global_step = int(checkpoint_suffix)
epochs_trained = (global_step // (len(train_dataloader) // args.gradient_accumulation_steps))
steps_trained_in_current_epoch = (global_step % (len(train_dataloader) // args.gradient_accumulation_steps))
logger.info('  Continuing training from checkpoint, will skip to saved global_step')
logger.info('  Continuing training from epoch %d', epochs_trained)
logger.info('  Continuing training from global step %d', global_step)
logger.info('  Will skip the first %d steps in the first epoch', steps_trained_in_current_epoch)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
data_size: Optional[int] = len(data)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
nonlinearity = {'RNN_TANH': 'tanh', 'RNN_RELU': 'relu'}[rnn_type]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from gdown import download as drive_download
drive_download(gdrive_url, model_weights_filename, quiet=False)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (not self.output):
    new_output = self.outputs[self.output_index]
    if (self.output_index > original_output_index):
        print('Falling back to video output %s', new_output.name())
    self.output = new_output(self.directory, self.frame_shape)
self.output.emit_frame(np_array)
return
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.binsha = pctree[self.path].binsha
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex import amp
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.remove(cls.path_token)
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
x_lens = [x for x in torch.sum((xs > 0).int(), dim=1).data]
xes = pack_padded_sequence(xes, x_lens, batch_first=True)
packed = True
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
from distutils.dir_util import _path_created
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return [self.protocol_parser[x] for x in filenames]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(sha, ref) = line.split()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
import re
import numpy as np
import tensorflow as tf
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
revision = subprocess.check_output(REVISION_CMD.split()).strip()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
traced_gpt2 = torch.jit.trace(model, inputs)
torch.jit.save(traced_gpt2, 'traced_model.pt')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
response = requests.head(url, allow_redirects=True)
if (response.status_code != 200):
    etag = None
else:
    etag = response.headers.get('ETag')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import numpy as np
import tensorflow as tf
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.remove(filename)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
nn.init.xavier_uniform_(m.weight.data)
m.bias.data.fill_(0)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.evaluation = pd.read_csv((self.metrics_path + '.csv'))
self.evaluation.set_index('img_paths', inplace=True)
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
n = conv(string)
return True
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
tf_cuda_available = tf.test.is_gpu_available()
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
colors = [random_color(rgb=True, maximum=1) for k in category_ids]
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
cm = plt.get_cmap(cmap)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
data = data.to(device)
optimizer.zero_grad()
logits = model(data)
loss = multicls_criterion(logits, data.y)
reg_loss = torch.tensor(0.0, device=device)
if (kwargs['weight_decay'] > 0.0):
    if (not hasattr(model, 'phm_dim')):
        reg_loss += ((kwargs['lr'] * kwargs['weight_decay']) * quaternion_weight_regularization(model, device=device, p=kwargs['p']))
    else:
        reg_loss += ((kwargs['lr'] * kwargs['weight_decay']) * phm_weight_regularization(model, device=device, p=kwargs['p']))
if (kwargs['weight_decay2'] > 0.0):
    reg_loss += ((kwargs['lr'] * kwargs['weight_decay2']) * multiplication_rule_regularization(model, p=1))
loss += reg_loss.squeeze()
loss.backward()
if (kwargs['grad_clipping'] > 0.0):
    torch.nn.utils.clip_grad_norm_(model.parameters(), max_norm=kwargs['grad_clipping'], norm_type=2)
optimizer.step()
total_loss += (loss.item() * data.num_graphs)
y_true_list.append(data.y)
y_pred_list.append(logits)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import torch
torch.backends.cudnn.deterministic = True
torch.backends.cudnn.benchmark = False
torch.manual_seed(long)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.array(shape, intent.in_.cache, obj)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
self[name] = toklist[0]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
return bpe.is_beginning_of_word(tok)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
citations[subject] += 1
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
AP = self.pytorch_getter.get('api_parser', class_name=class_name, params=api_parser_kwargs)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
is_service_func = ('HookService' in lit.__qualname__)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(symbol, idx) = symbol_and_id.split(':')
idx = int(idx)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
with zf.open(arcname) as bf:
    wf = wrapper(bf)
    extensions = json.load(wf)
    cache = self._get_dylib_cache()
    prefix = cache.prefix_to_dir(pathname)
    cache_base = os.path.join(cache.base, prefix)
    if (not os.path.isdir(cache_base)):
        os.makedirs(cache_base)
    for (name, relpath) in extensions.items():
        dest = os.path.join(cache_base, convert_path(relpath))
        if (not os.path.exists(dest)):
            extract = True
        else:
            file_time = os.stat(dest).st_mtime
            file_time = datetime.datetime.fromtimestamp(file_time)
            info = zf.getinfo(relpath)
            wheel_time = datetime.datetime(*info.date_time)
            extract = (wheel_time > file_time)
        if extract:
            zf.extract(relpath, cache_base)
        result.append((name, dest))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
select2 = int(select2)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
text_a = line[3]
text_b = line[4]
label = line[5]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
FileNotFoundError
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(dump_folder)
",0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with open(f, 'r', encoding='utf-8') as fd:
    self.add_from_file(fd)
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return fn(timeout)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
lvis_dt = LVISResults(lvis_gt, result_files[metric])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
sw = (oi / ui)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1
"
resolved_corpus_file = cached_path(corpus_file, cache_dir=cache_dir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
j = word.index(first, i)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
return typ.from_str(s)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
return tcn.shared_constructor(val)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
lri.lr_after = self.Prodnames[lri.prod[(i + 1)]]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return d.iteritems()
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
img = Image.open(buf).convert('RGB')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
embeddings = api_workflow_client.embeddings_api.get_embeddings_by_dataset_id(dataset_id=dataset_id)
embeddings = sorted(embeddings, key=(lambda x: x.created_at), reverse=True)
embedding = next((embedding for embedding in embeddings if embedding.name.startswith(name)))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_vocab_file = cached_path(vocab_file, cache_dir=cache_dir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return arr.index(0)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
with open(os.path.join(idir.path, image), 'r+b') as f:
    with Image.open(f) as img:
        img = resize_image(img, size)
        img.save(os.path.join(((output_dir + '/') + idir.name), image), img.format)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import kwarray
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with open(str(db_info_path), 'rb') as f:
    infos = pickle.load(f)
    [self.db_infos[cur_class].extend(infos[cur_class]) for cur_class in class_names]
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
sentence_offset: Optional[int] = text.index(plain_sentences[0])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
(pid, status) = os.waitpid((- 1), os.WNOHANG)
",0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.model.train()
if (log_inputs > 0):
    self.log_first_inputs(inputs)
    log_inputs -= 1
inputs = self.add_torch_input(inputs)
outputs = self.model(inputs['contexts_tensor'])
loss = self.calculate_loss_and_accuracy(outputs, labels=inputs['contexts_tensor'])
if cfg.fp16:
    with amp.scale_loss(loss, optimizer) as scaled_loss:
        scaled_loss.backward()
else:
    loss.backward()
tr_loss += loss.item()
epoch_step += 1
if ((((epoch_step + 1) % cfg.gradient_accumulation_steps) == 0) or ((epoch_step + 1) == set_stats['num_training_steps_per_epoch'])):
    torch.nn.utils.clip_grad_norm_(self.model.parameters(), 1.0)
    optimizer.step()
    scheduler.step()
    optimizer.zero_grad()
    global_step += 1
    logs = {}
    if ((cfg.report_interval > 0) and ((global_step % cfg.report_interval) == 0)):
        loss_scalar = ((tr_loss - logging_loss) / cfg.report_interval)
        logging_loss = tr_loss
        logs['loss'] = loss_scalar
        logging.info('Global step: {}, epoch step: {}, interval loss: {:.4f}'.format(global_step, epoch_step, loss_scalar))
        if (cfg.evaluate_during_training and (loss_scalar < 10)):
            results = self.validate()
            for (k, v) in results.items():
                eval_key = 'eval_{}'.format(k)
                logs[eval_key] = v
        if self.tb_writer:
            for (k, v) in logs.items():
                self.tb_writer.add_scalar(k, v, global_step)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
v = numpy.array([float(f) for f in fields[1:]])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
import torch
import tensorflow as tf
from tensorflow.python.keras import backend as K
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
np.testing.assert_allclose(torch_output[i].cpu().detach().numpy(), out, rtol=0.001, atol=0.0002)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with open(cached_train_features_file, 'rb') as reader:
    train_features = pickle.load(reader)
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return self[cls]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with torch.no_grad():
    sor_x = self.batch_sor(x)
flag = True
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import sentencepiece as spm
self.sp = spm.SentencePieceProcessor()
self.sp.Load(vocab)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex.parallel import DistributedDataParallel as DDP
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
cpu_sum = float(x.float().sum())
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import cityscapesscripts.helpers.labels as CSLabels
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if ('pythainlp' not in sys.modules):
    from pythainlp.tokenize import word_tokenize as th_word_tokenize
else:
    th_word_tokenize = sys.modules['pythainlp'].word_tokenize
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import numpy as np
import tensorflow as tf
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex import amp
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import tensorflow as tf
import torch
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
batch = next(self._train_dataloader_iter)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
spec = module.__spec__
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
mnist_datasets = joblib.load(dataset_file)
logger.info('Dataset has been loaded from cache.')
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with h5py.File(f, 'r') as h5:
    try:
        tmp = json.loads(h5['meta'][()])
        e_sum += tmp['e_sum']
        e2_sum += tmp['e_square_sum']
        n_mu += tmp['len']
    except KeyError:
        continue
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (p_i.shape == arr_i.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
tarinfo.gname = grp.getgrgid(tarinfo.gid)[0]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
open(cfg_file, 'r')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(cmd, data) = remote.recv()
if (cmd == 'step'):
    (observation, reward, done, info) = env.step(data)
    if done:
        info['terminal_observation'] = observation
        observation = env.reset()
    remote.send((observation, reward, done, info))
elif (cmd == 'seed'):
    remote.send(env.seed(data))
elif (cmd == 'reset'):
    observation = env.reset()
    remote.send(observation)
elif (cmd == 'render'):
    remote.send(env.render(*data[0], **data[1]))
elif (cmd == 'close'):
    remote.close()
    break
elif (cmd == 'get_spaces'):
    remote.send((env.observation_space, env.action_space))
elif (cmd == 'env_method'):
    method = getattr(env, data[0])
    remote.send(method(*data[1], **data[2]))
elif (cmd == 'get_attr'):
    remote.send(getattr(env, data))
elif (cmd == 'set_attr'):
    remote.send(setattr(env, data[0], data[1]))
else:
    raise NotImplementedError
",0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(_, line) = next(audio_data)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return dialect._type_memos[self][coltype]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
while True:
    ss = self.source.readline()
    if (ss == ''):
        raise IOError
    ss = ss.strip().split()
    ss = [(self.source_dict[w] if (w in self.source_dict) else 1) for w in ss]
    if (self.n_words_source > 0):
        ss = [(w if (w < self.n_words_source) else 1) for w in ss]
    tt = self.target.readline()
    if (tt == ''):
        raise IOError
    tt = tt.strip().split()
    tt = [(self.target_dict[w] if (w in self.target_dict) else 1) for w in tt]
    if (self.n_words_target > 0):
        tt = [(w if (w < self.n_words_target) else 1) for w in tt]
    if ((len(ss) > self.maxlen) and (len(tt) > self.maxlen)):
        continue
    if (numpy.random.random() > self.shuffle_prob):
        continue
    source.append(ss)
    target.append(tt)
    if ((len(source) >= self.batch_size) or (len(target) >= self.batch_size)):
        break
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with open(executable) as fp:
    return (fp.read(2) == '#!')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.r = pd.read_csv('{}/Results.csv'.format(self.resultDir))
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (self.tpu and (self.data_parallel_world_size > 1)):
    import torch_xla.core.xla_model as xm
    gradients = xm._fetch_gradients(self.optimizer.optimizer)
    xm.all_reduce('sum', gradients, scale=(1.0 / self.data_parallel_world_size))
with torch.autograd.profiler.record_function('multiply-grads'):
    if (not self.args.use_bmuf):
        self.optimizer.multiply_grads((self.data_parallel_world_size / sample_size))
    elif (sample_size > 0):
        num = (self.data_parallel_world_size if self._sync_stats() else 1)
        self.optimizer.multiply_grads((num / sample_size))
with torch.autograd.profiler.record_function('clip-grads'):
    grad_norm = self.clip_grad_norm(self.args.clip_norm)
if (not self.tpu):
    if ((not self.args.use_bmuf) and (self.args.distributed_wrapper != 'SlowMo')):
        self._check_grad_norms(grad_norm)
    if (not torch.isfinite(grad_norm).all()):
        raise FloatingPointError('gradients are Nan/Inf')
with torch.autograd.profiler.record_function('optimizer'):
    self.optimizer.step()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
n = n[k]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
return int(val)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
has_key = self._metadata._has_key
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if self.tpu_name:
    tpu = tf.distribute.cluster_resolver.TPUClusterResolver(self.tpu_name)
else:
    tpu = tf.distribute.cluster_resolver.TPUClusterResolver()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
p = subprocess.run(['nvidia-smi', '-L'], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex.parallel import DistributedDataParallel as DDP
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
image_ndc = skimage.transform.resize(np_image, (NDC_SIZE, NDC_SIZE), preserve_range=True)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
val = float(val)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
mode = Split[mode]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
raise ValueError('for unit testing')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
return next(self.tgt_loader_iter)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
gdb.execute(self._command, to_string=True)
while (not self.is_relevant_function(gdb.selected_frame())):
    gdb.execute(self._command, to_string=True)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
act = {'id': 'safeLocalHuman', 'label_candidates': None, 'episode_done': False, 'text': str(turn_each)}
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
bb = workspace.FetchBlob(name)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
result.append(self[chr].chr)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
abundances[element] -= abundances['Fe']
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
number = word_to_num(word)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
X = np.ones((NB, sample_dims), dtype=np.float32)
action = ('Fitting' if transformer.batch_support else 'Collecting')
for gi in trange(0, N, NB, desc=f'{action} batches (NB={NB})', ascii=True):
    for mb in range(0, NB, B):
        z = torch.from_numpy(latents[(gi + mb):((gi + mb) + B)]).to(device)
        if samples_are_latents:
            batch = z.reshape((B, (- 1)))
        else:
            with torch.no_grad():
                model.partial_forward(z, layer_key)
            batch = inst.retained_features()[layer_key].reshape((B, (- 1)))
        space_left = min(B, (NB - mb))
        X[mb:(mb + space_left)] = batch.cpu().numpy()[:space_left]
    if transformer.batch_support:
        if (not transformer.fit_partial(X.reshape((- 1), sample_dims))):
            break
    else:
        samples[gi:(gi + NB), :] = X.copy()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
pointer = getattr(pointer, l[0])
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (list(symbolic_weight.shape) == list(array.shape))
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
batch = next(data_iter)
print_log('New user {}'.format(i))
if args.cuda:
    batch = {k: v.cuda(torch.cuda.current_device()) for (k, v) in batch.items()}
(ref_marks, ref_timestamps, context_lengths, padding_mask) = (batch['ref_marks'], batch['ref_times'], batch['context_lengths'], batch['padding_mask'])
(ref_marks_backwards, ref_timestamps_backwards) = (batch['ref_marks_backwards'], batch['ref_times_backwards'])
(tgt_marks, tgt_timestamps) = (batch['tgt_marks'], batch['tgt_times'])
pp_id = batch['pp_id']
tgt_timestamps = tgt_timestamps[..., :padding_mask.cumsum((- 1)).max().item()]
tgt_marks = tgt_marks[..., :padding_mask.cumsum((- 1)).max().item()]
T = batch['T']
user_samples = {'original_times': tgt_timestamps.squeeze().tolist(), 'original_marks': tgt_marks.squeeze().tolist(), 'original_T': T.squeeze().tolist(), 'samples': {}}
for pct in T_pcts:
    print_log('New pct {}'.format(pct))
    user_samples['samples'][pct] = []
    if (pct == 0.0):
        new_tgt_timestamps = (tgt_timestamps[..., :1] * 10000)
        new_tgt_marks = tgt_marks[..., :1]
        left_window = 0.0
    else:
        new_tgt_timestamps = tgt_timestamps[..., :(math.floor((pct * tgt_timestamps.shape[(- 1)])) + 1)]
        new_tgt_marks = tgt_marks[..., :(math.floor((pct * tgt_timestamps.shape[(- 1)])) + 1)]
        left_window = new_tgt_timestamps[(..., (- 1))].squeeze().item()
    for j in range(samples_per_time):
        print('New sample {}'.format(j))
        samples = None
        m = 1.0
        while (samples is None):
            if (m >= 10.0):
                break
            samples = model.sample_points(ref_marks=ref_marks, ref_timestamps=ref_timestamps, ref_marks_bwd=ref_marks_backwards, ref_timestamps_bwd=ref_timestamps_backwards, tgt_marks=new_tgt_marks, tgt_timestamps=new_tgt_timestamps, context_lengths=context_lengths, dominating_rate=(args.dominating_rate * m), T=T, left_window=left_window, top_k=args.top_k, top_p=args.top_p)
            m *= 1.5
        if (samples is None):
            print('No good sample found. Skipping')
            continue
        (sampled_times, sampled_marks) = samples
        held_out_marks = set(tgt_marks[..., math.floor((pct * tgt_timestamps.shape[(- 1)])):].squeeze().tolist())
        print('Pct: {} | Left Window: {} |Num Original: {} | Num Conditioned: {} | Num Sampled Alone: {} | Unique Marks on Held Out: {} | Unique Marks Sampled: {} | Common Marks: {}'.format(pct, left_window, tgt_timestamps.squeeze().shape[0], math.floor((pct * tgt_timestamps.shape[(- 1)])), len(sampled_times), len(held_out_marks), len(set(sampled_marks)), len(held_out_marks.intersection(set(sampled_marks)))))
        assert ((len(sampled_times) == 0) or (left_window <= min(sampled_times)))
        user_samples['samples'][pct].append((sampled_times, sampled_marks))
all_samples.append(user_samples)
i += 1
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
while (n_filled < self.bptt):
    if ((streams[i] is None) or (len(streams[i]) <= 1)):
        streams[i] = next(sent_stream)
    n_new = min((len(streams[i]) - 1), (self.bptt - n_filled))
    data[(n_retain + n_filled):((n_retain + n_filled) + n_new), i] = streams[i][:n_new]
    target[n_filled:(n_filled + n_new), i] = streams[i][1:(n_new + 1)]
    streams[i] = streams[i][n_new:]
    n_filled += n_new
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(image, label, image_id) = self._prepare_sample(file)
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
while (n_filled < self.bptt):
    if ((streams[i] is None) or (len(streams[i]) <= 1)):
        streams[i] = next(sent_stream)
    n_new = min((len(streams[i]) - 1), (self.bptt - n_filled))
    data[(n_retain + n_filled):((n_retain + n_filled) + n_new), i] = streams[i][:n_new]
    target[n_filled:(n_filled + n_new), i] = streams[i][1:(n_new + 1)]
    streams[i] = streams[i][n_new:]
    n_filled += n_new
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (len(prefix_ids) == max_seq_length)
assert (len(prefix_mask) == max_seq_length)
assert (len(segment_ids) == max_seq_length)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.post(hyp, covfunc, X, y)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
resolved_vocab_files = {}
for (file_id, file_path) in vocab_files.items():
    if (file_path is None):
        resolved_vocab_files[file_id] = None
    else:
        resolved_vocab_files[file_id] = cached_path(file_path, cache_dir=cache_dir, force_download=force_download, proxies=proxies, resume_download=resume_download, local_files_only=local_files_only)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
remaining_predicted_spans.remove(gold_span)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
value = next(it)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
s = s[0]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
mdl = importlib.import_module(('.' + module_name), 'fastmri.transforms')
classobj = getattr(mdl, class_name)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
data1 = ds.CocoDataset(DATA_DIR, annotation_file=ANNOTATION_FILE, task='Detection')
data1 = data1.map(operations=exception_func, input_columns=['category_id'], num_parallel_workers=1)
for _ in data1.create_dict_iterator(num_epochs=1, output_numpy=True):
    pass
assert False
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
crit = self.state.criteria[name]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
posDropoutLayer = self.dropout_positions.index(idx)
input = self.dropout_layers[posDropoutLayer](input)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
iter(size)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
if (key in self.levels[0]):
    indexer = self._get_level_indexer(key, level=level)
    new_index = maybe_mi_droplevels(indexer, [0], drop_level)
    return (indexer, new_index)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
records = self._shuffled_data.iloc[list(attacks.keys())].copy()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
layer.compute(None)
assert False
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
instance = next(dataset)
instance.fields[self._dataset_field_name] = MetadataField(key)
(yield instance)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return float(val)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
with open(path, 'rb') as f:
    return Image.open(f).convert('RGB')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
doc = v.__doc__.split(' ')
if (doc[1] == ':'):
    self.log.warning('%s:%d: Possible grammar rule %r defined without p_ prefix', v.__code__.co_filename, v.__code__.co_firstlineno, n)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return str(r.content, encoding, errors='replace')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
old = getattr(roi_heads, attr)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
j = word.index(first, i)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
model = archs[cfg.default_opts['model']](**cfg.MODEL)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import torch
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(((args.outf + '/') + args.exp_name))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (DP_type == 'adp'):
    y = ((np.arange(self.number_of_buckets) - (self.number_of_buckets // 2)) * self.log_factor)
    y = y.reshape((1, len(y)))
    eps_vec = eps_vec.reshape((len(eps_vec), 1))
    G = np.maximum(0, (1 - np.exp((eps_vec - y))))
    G = np.append(G, np.ones(((self.number_of_buckets + 1), 1)), axis=1)
elif (DP_type == 'pdp'):
    G = np.ones(((self.number_of_buckets + 1), (self.number_of_buckets + 1)))
    G[np.tril_indices((self.number_of_buckets + 1), (- 1))] = 0
else:
    raise NotImplementedError(""DP_type '{}' not implemented."".format(DP_type))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from .convert_transfo_xl_original_tf_checkpoint_to_pytorch import convert_transfo_xl_checkpoint_to_pytorch
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import ftfy
from spacy.lang.en import English
_nlp = English()
self.nlp = _nlp.Defaults.create_tokenizer(_nlp)
self.fix_text = ftfy.fix_text
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (list(symbolic_weight.shape) == list(array.shape))
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (current_state_batch.shape[1] == next_state_batch.shape[1] == self.emb_pos.shape[1] == self.emb_neg.shape[1])
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
optimizer = Toptim.Adam(self.net.parameters(), lr=Config.GNN_INIT_LR, weight_decay=Config.GNN_WEIGHT_DECAY)
scheduler = Toptim.lr_scheduler.ReduceLROnPlateau(optimizer, mode='min', factor=Config.GNN_LR_REDUCE_FACTOR, patience=Config.GNN_LR_SCHEDULE_PATIENCE, verbose=True)
for epoch_idx in range(Config.GNN_N_EPOCHS):
    print('    Epoch', epoch_idx)
    time_start = time.time()
    (epoch_train_loss, optimizer) = self._run_net_one_epoch(tr_iter, batch_size=1, ep_size=Config.GNN_TR_EPOCH_SIZE, optimizer=optimizer, is_training=True)
    (epoch_val_loss, _) = self._run_net_one_epoch(val_iter, batch_size=1, ep_size=Config.GNN_VAL_EPOCH_SIZE, optimizer=None, is_training=False)
    epoch_time = (time.time() - time_start)
    train_losses.append(epoch_train_loss)
    val_losses.append(epoch_val_loss)
    print('        t:', epoch_time, ', lr:', optimizer.param_groups[0]['lr'], ', tr_loss:', epoch_train_loss, ', val_loss:', epoch_val_loss)
    if (((epoch_idx % Config.GNN_N_EPOCHS_CHECKPOINT_FREQ) == 0) and (epoch_idx > 0)):
        os.makedirs(Config.GNN_CHECKPOINT_DIR, exist_ok=True)
        ckpt_path = os.path.join(Config.GNN_CHECKPOINT_DIR, (('epoch_' + str(epoch_idx)) + '.pkl'))
        torch.save(self.net.state_dict(), ckpt_path)
        print('Checkpoint saved to:', ckpt_path)
        plot_path = os.path.join(Config.GNN_CHECKPOINT_DIR, 'losses.png')
        plt.figure(figsize=(12, 6))
        plt.plot(train_losses, label='train_loss')
        plt.plot(val_losses, label='val_loss')
        train_losses_m20 = Util.rolling_mean(train_losses, window_len=20)
        val_losses_m20 = Util.rolling_mean(val_losses, window_len=20)
        plt.plot(train_losses_m20, label='train_loss mean20')
        plt.plot(val_losses_m20, label='val_loss mean20')
        plt.legend()
        plt.savefig(plot_path)
        plt.clf()
    scheduler.step(epoch_val_loss)
    if (optimizer.param_groups[0]['lr'] <= Config.GNN_MIN_LR):
        print('\n!! LR EQUAL TO MIN LR SET.')
        break
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
docs = wikipedia.search(np)
if (self.k_wiki_results is not None):
    predicted_pages.extend(docs[:self.k_wiki_results])
else:
    predicted_pages.extend(docs)
",0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex.parallel import DistributedDataParallel
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
pointer = getattr(pointer, scope_names[0])
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return self.instance2index[instance]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
torch.Tensor([1.0]).to(device)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
int(string)
return True
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
int(s)
return True
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
self._ds.download(arg, prefix='    ')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
q.put([reward_sum, agent_in.replay_buffer.__getstate__()])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(log_dir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
flag_idx = arg.index(flag_name)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
wrap = obj.__array_wrap__
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import sentencepiece as spm
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return self[k]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
batch = next(self._iterator)
(inputs, labels) = self.inputs_labels_from_batch(batch)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(ckpt)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
syn_auroc = metrics.roc_auc_score(syn_y_test, syn_y_pred_proba)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
global fused_adam_cuda
import importlib
fused_adam_cuda = importlib.import_module('fused_adam_cuda')
return FusedAdamV1
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
ctype = cls._ctype
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
value = int(unparsed_args[(i + 1)])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
os.remove(cls.path_token)
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
t = test_info.get_elapsed_time()
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from .modeling_tf_pytorch_utils import load_tf2_checkpoint_in_pytorch_model
model = load_tf2_checkpoint_in_pytorch_model(model, resolved_archive_file, allow_missing_keys=True)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import pyarrow.plasma as plasma
self._plasma = plasma
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
_line_length = int(val)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
from flax.metrics.tensorboard import SummaryWriter
summary_writer = SummaryWriter(log_dir=Path(training_args.output_dir))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
l = len(query)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
copy_layers(teacher.model.encoder.layers, student.model.encoder.layers, e_layers_to_copy)
copy_layers(teacher.model.decoder.layers, student.model.decoder.layers, d_layers_to_copy)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import nltk
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
autogen_indices.append(int(s[prefix_len]))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
signal.SIGPIPE
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return '{:.2f}'.format(math.pow(2, loss))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.mkdir(os.path.join(data_dir, 'procressed_WikiCT'))
",0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(teacher_e, teacher_d) = (teacher.config.encoder_layers, teacher.config.decoder_layers)
if (e is None):
    e = teacher_e
if (d is None):
    d = teacher_d
init_kwargs.update({'encoder_layers': e, 'decoder_layers': d})
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(status, payload) = self.connection.recv()
",0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
tokens = fn(instring, tokensStart, retTokens)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
nn.utils.remove_weight_norm(module)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
msg = self.format(record)
tqdm.tqdm.write(msg)
self.flush()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0
"
datetime.strptime(possible_log_date, _LOG_DATE_FORMAT)
return True
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
task_positive_label = train_files[0]['pos_label']
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(firstaxis, parity, repetition, frame) = _AXES2TUPLE[axes]
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
momentum = self.optimizer.param_groups[0]['momentum']
dtheta = [(dtheta_i + (momentum * self.optimizer.state[v]['momentum_buffer'])) for (dtheta_i, v) in zip(dtheta, self.model.parameters())]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
AUROCs.append(roc_auc_score(gt_np[:, i], pred_np[:, i]))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
alpha = kwargs['alpha']
beta = kwargs['beta']
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
f_iter = iter(field)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
import re
import tensorflow as tf
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.__end
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
lm_head.set_output_embeddings(value)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
accu = ((tp + tn) / (((tp + tn) + fp) + fn))
precision = (tp / (tp + fp))
recall = (tp / (tp + fn))
f_score = (((2 * precision) * recall) / (precision + recall))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1
"
canvas.manager.full_screen_toggle()
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
classname = self.__class__.__name__
nice = self.__nice__()
return f'<{classname}({nice})>'
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex.optimizers import FP16_Optimizer
from apex.optimizers import FusedAdam
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(firstaxis, parity, repetition, frame) = _AXES2TUPLE[axes.lower()]
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return safe_round((base ** loss), round)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return function(value)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
os.makedirs(directory)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with open('test_diff.xyz', 'a') as file:
    n = r.shape[0]
    for (i, ri) in enumerate(r):
        r_out = ri.reshape((- 1), 3)
        e_out = (None if (not model['use_E']) else (np.squeeze(E[b_range][i]) - e_pred[i]))
        f_out = (f[i] - f_pred[i]).reshape((- 1), 3)
        ext_xyz_str = (io.generate_xyz_str(r_out, model['z'], e=e_out, f=f_out) + '\n')
        file.write(ext_xyz_str)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import torch
torch.manual_seed(seed)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
target_2d = next(self.train_2d_iter)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
while True:
    while (len(pos_samples) < buffer):
        pos_sample = next(pos_sample_generator)
        label = pos_sample[3]
        assert (label == 1), ""positive sample's label must be 1""
        pos_samples.append(pos_sample)
        pos_sample_num += 1
    (neg_samples, miss_num) = self.random_pair_neg_samples(pos_samples)
    num_total_miss += miss_num
    samples = (pos_samples + neg_samples)
    pos_samples = []
    np.random.shuffle(samples)
    for sample in samples:
        (yield sample)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
gdb_value = gdb.parse_and_eval(func_cname)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from .convert_bert_original_tf_checkpoint_to_pytorch import convert_tf_checkpoint_to_pytorch
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
task.load_dataset(subset, combine=False, epoch=1, task_cfg=saved_cfg.task)
dataset = task.dataset(subset)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from tokenizers import ByteLevelBPETokenizer
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.remove(cls.path_token)
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from mmdet.version import __version__
sha = __version__.split('+')[(- 1)]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import sentencepiece as spm
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_archive_file = cached_path(archive_file)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
acc = ((100 * correct) / total)
self.acc_list.append(acc)
return acc
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1
"
resolved_archive_file = cached_path(archive_file, cache_dir=cache_dir, force_download=force_download, proxies=proxies, resume_download=resume_download)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return (self.E @ self.eta_gamma)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (list(pt_weight.shape) == list(array.shape))
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(os.path.dirname(new_save_dir))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex import amp
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
iterator = iter(first_field)
first_field_iterator = True
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
import yaml
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.viewer.imshow(img)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
tarinfo.uname = pwd.getpwuid(tarinfo.uid)[0]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_vocab_files = {}
for (file_id, file_path) in vocab_files.items():
    if (file_path is None):
        resolved_vocab_files[file_id] = None
    else:
        resolved_vocab_files[file_id] = cached_path(file_path, cache_dir=cache_dir, force_download=force_download, proxies=proxies)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
src_dict = getattr(task, 'source_dictionary', None)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return self.data[item]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
src_dict = getattr(task, 'source_dictionary', None)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from mmcv.ops import get_compiler_version, get_compiling_cuda_version
env_info['MMCV Compiler'] = get_compiler_version()
env_info['MMCV CUDA Compiler'] = get_compiling_cuda_version()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with open(save_file, 'r') as f:
    last_saved = f.read()
    last_saved = last_saved.strip()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return int(s)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
assert (pointer.shape == array.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_archive_file = cached_path(archive_file, cache_dir=cache_dir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
workspace.RunOperatorOnce(op)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
ver = float(winreg.EnumValue(bkey, i)[0])
if (ver not in vc_vers):
    vc_vers.append(ver)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
if (not os.path.exists(outputfile_path)):
    os.makedirs(outputfile_path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_vocab_file = cached_path(vocab_file, cache_dir=cache_dir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return self.labelToIdx[key]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.rgx = self.opts['rgx']
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.model.load_state_dict(state_dict)
return
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
hash(key)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
assert (pointer.shape == array.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import lmdb
if (self.store_path.exists() and self.store_path.is_dir()):
    try:
        self.env = lmdb.open(str(self.store_path), readonly=True, max_readers=2048, max_spare_txns=4)
        if self.env:
            with self.env.begin() as txn:
                cursor = txn.cursor()
                for (key, value) in cursor:
                    vector = pickle.loads(value)
                    self.k = vector.shape[0]
                    break
                cursor.close()
            return
    except lmdb.Error as err:
        logger.exception(f'Fail to open lmdb database {str(self.store_path)}: {str(err)}')
if hasattr(embedding, 'precomputed_word_embeddings'):
    pwe = embedding.precomputed_word_embeddings
    self.k = pwe.vector_size
    self.store_path.mkdir(parents=True, exist_ok=True)
    self.env = lmdb.open(str(self.store_path), map_size=DEFAULT_MAP_SIZE)
    if verbose:
        logger.info('load vectors to store')
    txn = self.env.begin(write=True)
    for word in tqdm(pwe.vocab.keys()):
        vector = pwe.get_vector(word)
        if (len(word.encode(encoding='UTF-8')) < self.env.max_key_size()):
            txn.put(word.encode(encoding='UTF-8'), pickle.dumps(vector))
    txn.commit()
    return
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
tokens = fn(instring, tokensStart, retTokens)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return getattr(checker.config, option.replace('-', '_'))
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
module_identifier = file.split('.')[0]
module_identifier = getattr(transformers, module_identifier)
suite = doctest.DocTestSuite(module_identifier)
result = unittest.TextTestRunner().run(suite)
self.assertIs(len(result.failures), 0)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with open(manifest_in, 'r') as f:
    for line in f:
        if line.startswith('include '):
            for include in line.split()[1:]:
                simple_includes.add(include)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from kaldi.feat.mel import MelBanksOptions
from kaldi.feat.fbank import FbankOptions, Fbank
from kaldi.feat.window import FrameExtractionOptions
from kaldi.matrix import Vector
mel_opts = MelBanksOptions()
mel_opts.num_bins = n_bins
frame_opts = FrameExtractionOptions()
frame_opts.samp_freq = sample_rate
opts = FbankOptions()
opts.mel_opts = mel_opts
opts.frame_opts = frame_opts
fbank = Fbank(opts=opts)
features = fbank.compute(Vector(waveform), 1.0).numpy()
return features
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
j = word.index(first, i)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
field = message_descriptor.fields_by_name[field_name]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
ret[key] = paper[key]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from test_forward import _get_detector_cfg
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return accimage.Image(path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.unlink(temp_file)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import re
import numpy as np
import tensorflow as tf
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
task.load_dataset(split_k, combine=False)
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
out = subprocess.check_output(['cmake', '--version'])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
nn.utils.remove_weight_norm(module)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
from tempfile import mkstemp
(script_fd, script_name) = mkstemp('.py')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import tensorflow as tf
import torch
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
pred_class_logits = self.classifier(bn_feat)
fore_pred_class_legits = self.classifier_occ(bn_foreground_feat)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
return self.namescope.get('attached_model', scope_identifier)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return self.known_modules[fullname]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import gitdb
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
spawncontext.join()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import fastBPE
self.bpe = fastBPE.fastBPE(codes)
self.bpe_symbol = '@@ '
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (not g.consistent())
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex.parallel import DistributedDataParallel as DDP
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
dx = ((- dx) / self.bbox.width)
dy = ((- dy) / self.bbox.height)
(dx, dy) = format_deltas(key, dx, dy)
if (self.get_aspect() != 'auto'):
    dx = dy = (0.5 * (dx + dy))
alpha = np.power(10.0, (dx, dy))
start = np.array([p.x, p.y])
oldpoints = p.lim.transformed(p.trans)
newpoints = (start + (alpha * (oldpoints - start)))
result = mtransforms.Bbox(newpoints).transformed(p.trans_inverse)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import Mykytea
self.ja_word_tokenizer = Mykytea.Mykytea(('-model %s/local/share/kytea/model.bin' % os.path.expanduser('~')))
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.remove(cls.path_token)
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return self[name]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import spacy
from spacy.lang.en import English
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
f.write(_get_script_mod(model)._c.dump_to_str(True, False, False))
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (FLAGS.log_path != ''):
    save_yaml(FLAGS.log_path, r)
else:
    print(yaml.dump(r))
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
info['cost'] = self._cost(action)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_archive_file = cached_path(archive_file)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(yield)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
code = member.__code__
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
dataset = load_dataset(*args, **kwargs)
",0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import apex
apex.amp.register_half_function(torch, 'einsum')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(features, dataset, examples) = (features_and_dataset['features'], features_and_dataset['dataset'], features_and_dataset['examples'])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(dirpath)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
write(local_struct_pack(format, value))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0
"
if (archive_format == 'tgz'):
    with tarfile.open(mar_path, 'w:gz') as z:
        ModelExportUtils.archive_dir(model_path, z, archive_format, model_name)
        tar_manifest = tarfile.TarInfo(name=os.path.join(model_name, MAR_INF, MANIFEST_FILE_NAME))
        tar_manifest.size = len(manifest.encode('utf-8'))
        z.addfile(tarinfo=tar_manifest, fileobj=BytesIO(manifest.encode()))
        z.close()
elif (archive_format == 'no-archive'):
    if (model_path != mar_path):
        ModelExportUtils.archive_dir(model_path, mar_path, archive_format, model_name)
    manifest_path = os.path.join(mar_path, MAR_INF)
    ModelExportUtils.make_dir(manifest_path)
    with open(os.path.join(manifest_path, MANIFEST_FILE_NAME), 'w') as f:
        f.write(manifest)
else:
    with zipfile.ZipFile(mar_path, 'w', zipfile.ZIP_DEFLATED) as z:
        ModelExportUtils.archive_dir(model_path, z, archive_format, model_name)
        z.writestr(os.path.join(MAR_INF, MANIFEST_FILE_NAME), manifest)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import sentencepiece as spm
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import torch.__config__
return torch.__config__.show()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
a = self.array(shape, intent.in_.inout, obj)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
from fairseq.modules.lightconv_layer import LightconvLayer
return LightconvLayer(input_size, kernel_size=kernel_size, padding_l=padding_l, num_heads=num_heads, weight_dropout=weight_dropout, weight_softmax=weight_softmax, bias=bias)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (pointer.shape == array.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
_ = self.unnecessary_tags.index(child.tag)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
assert (pointer.shape == array.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
end_idx = S.index(data.STOP_DECODING)
S = S[:end_idx]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
import amp_C
MultiTensorApply.available = True
self.chunk_size = chunk_size
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import instaboostfast as instaboost
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
out = _minimal_ext_cmd(['git', 'rev-parse', 'HEAD'])
sha = out.strip().decode('ascii')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from visdom import Visdom
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
n0 = np.random.choice(np.arange((self.dim + 1)), 1, p=(np.append(rates, diff) / Istar))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
if isinstance(fname, os_PathLike):
    fname = os_fspath(fname)
if isinstance(fname, str):
    fid = np.lib._datasource.open(fname, 'rt', encoding=encoding)
    fid_ctx = contextlib.closing(fid)
else:
    fid = fname
    fid_ctx = contextlib_nullcontext(fid)
fhd = iter(fid)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
entityName = entitiesTrie.longest_prefix(''.join(charStack[:(- 1)]))
entityLength = len(entityName)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import sentencepiece as spm
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_archive_file = cached_path(archive_file, cache_dir=cache_dir, force_download=force_download, proxies=proxies)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
dir = unicode(dir)
has_high_char = False
for c in dir:
    if (ord(c) > 255):
        has_high_char = True
        break
if has_high_char:
    try:
        import win32api
        dir = win32api.GetShortPathName(dir)
    except ImportError:
        pass
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0
"
img = Image.open(path)
for orientation in ExifTags.TAGS.keys():
    if (ExifTags.TAGS[orientation] == 'Orientation'):
        break
exif = dict(img._getexif().items())
if (exif[orientation] == 3):
    img = img.rotate(180, expand=True)
elif (exif[orientation] == 6):
    img = img.rotate(270, expand=True)
elif (exif[orientation] == 8):
    img = img.rotate(90, expand=True)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
node_value = int(node, 10)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
nice = self.__nice__()
classname = self.__class__.__name__
return f'<{classname}({nice}) at {hex(id(self))}>'
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from subword_nmt import apply_bpe
bpe_parser = apply_bpe.create_parser()
bpe_args = bpe_parser.parse_args(['--codes', codes, '--separator', cfg.bpe_separator])
self.bpe = apply_bpe.BPE(bpe_args.codes, bpe_args.merges, bpe_args.separator, None, bpe_args.glossaries)
self.bpe_symbol = (bpe_args.separator + ' ')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return_type_matcher.register(name, self.ThisClassReturn)
return_type_matcher.register(name, self.ThisClassRefReturn)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
return accimage.Image(path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import tensorflow as tf
from keras2onnx import convert_keras, save_model, __version__ as k2ov
print('Using framework TensorFlow: {}, keras2onnx: {}'.format(tf.version.VERSION, k2ov))
(input_names, output_names, dynamic_axes, tokens) = infer_shapes(nlp, 'tf')
nlp.model.predict(tokens.data)
onnx_model = convert_keras(nlp.model, nlp.model.name, target_opset=opset)
save_model(onnx_model, output)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from spacy.lang.en import English
spacy_nlp._nlp = English()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(self.next_input, self.next_target) = next(self.loader)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import re
import tensorflow as tf
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
global_step = int(args.model_name_or_path.split('-')[(- 1)].split('/')[0])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
year = int(year_string)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
float(s)
return True
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
if (not package):
    module = import_module(name)
else:
    module = import_module(('.' + name), package=package)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
value = int(unparsed_args[(i + 1)])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
from apex import amp
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from transformers import load_tf2_checkpoint_in_pytorch_model
model = load_tf2_checkpoint_in_pytorch_model(model, resolved_archive_file, allow_missing_keys=True)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
arg.tag.test_value = gof.Op._get_test_value(actual_arg)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
queue.put(next(dl))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from .convert_transfo_xl_checkpoint_to_pytorch import convert_transfo_xl_checkpoint_to_pytorch
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import sentencepiece as spm
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.bin_vals.append(((n1 / d1), (n2 / d2)))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1
"
assert (pointer.shape == array.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
iter(size)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
gpu_rank = distributed.multi_init(device_id, args.world_size, args.gpu_ranks)
print(('gpu_rank %d' % gpu_rank))
if (gpu_rank != args.gpu_ranks[device_id]):
    raise AssertionError('An error occurred in                   Distributed initialization')
train_single(args, device_id)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
header = self._read_header()
magic = header['MAGIC'][0]
if (magic != MAGIC_EXPECT):
    raise DataSetException(f'invalid magic number: {magic:x} != {MAGIC_EXPECT:x}')
return True
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
global fused_adam_cuda
import importlib
fused_adam_cuda = importlib.import_module('fused_adam_cuda')
return FusedAdamV1
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
for file_name in os.listdir(os.path.join(task_directory_path, 'html')):
    self.task_files_to_copy.append(os.path.join(task_directory_path, 'html', file_name))
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.optimize = int(self.optimize)
if (not (0 <= self.optimize <= 2)):
    raise ValueError
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
os.mkdir(targetpath, 448)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
number = float(text)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
setattr(self, key, value)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
loc = self.get_loc(key)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
net_func = NETWORK_TYPES[arch_key]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
src_dict = getattr(task, 'source_dictionary', None)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import instaboostfast as instaboost
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.symlink(source_configs_dir, destination)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(cmd_args, _) = get_common_cmd_args()
output_basedir = cmd_args.output_basedir
model_name = cmd_args.model_name
if (model_name == 'resnet20'):
    cfg2funcparams = cfg2funcparams_nas_resnet20
    get_space = get_space_nas_resnet20
else:
    raise ValueError(f'model name {model_name} is wrong')
logger = logging.getLogger(f'TPE-NAS-{model_name}')
logger.setLevel(logging.DEBUG)
expid = get_experiment_id(6)
output_dir = os.path.join(output_basedir, 'TPE-NAS', model_name, expid)
os.makedirs(output_dir, exist_ok=True)
log_path = os.path.join(output_dir, f'TPE-NAS-{model_name}.log')
setup_logger(logger, log_path)
logger.info(f'Experiment {expid} starts...')
logger.info('Experiment Configuration:')
logger.info(vars(cmd_args))

def obj_func(cfg):
    logger.info('Starting BO iteration')
    params = cfg2funcparams(cfg)
    obj_info = nas_train_test(cmd_args, params, logger, model_name=model_name)
    logger.info('Finishing BO iteration')
    logger.info(params)
    logger.info(obj_info)
    all_info = {'params': params, 'obj_info': obj_info}
    fn_path = os.path.join(output_dir, 'tpe_iter_hists.txt')
    with open(fn_path, 'a') as f:
        json.dump(all_info, f)
        f.write('\n')
    return {'loss': obj_info['value'], 'status': STATUS_OK}
space = get_space()
trials = Trials()
best = fmin(obj_func, space=space, algo=tpe.suggest, max_evals=100, trials=trials, show_progressbar=False)
print(best)
logger.info('Finish TPE optimization')
logger.info('Best is: ')
logger.info(best)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
value = self._loads(line)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
src_dict = getattr(task, 'source_dictionary', None)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
_ = (key for key in keys)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
assert (model.tokens_embed.weight.shape == init_params[1].shape)
assert (model.positions_embed.weight.shape == init_params[0].shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(save_folder)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
source_tweet_dir = context_tweets_dataset_dir_dict[source_tweet_id]
source_tweet_data_dir = os.path.join(source_tweet_dir, 'source-tweets')
if (not os.path.isdir(source_tweet_data_dir)):
    source_tweet_data_dir = os.path.join(source_tweet_dir, 'source-tweet')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert hasattr(model, kl)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return v.owner.inputs[0].data.__getitem__(cdata)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (tarinfo.issym() and hasattr(os, 'lchown')):
    os.lchown(targetpath, u, g)
elif (sys.platform != 'os2emx'):
    os.chown(targetpath, u, g)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from ._speedups import make_encoder
return make_encoder
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return object.__getattribute__(self, key)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (p_i.shape == arr_i.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
tau = tau.tau
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from transformers.convert_gpt2_original_tf_checkpoint_to_pytorch import convert_gpt2_checkpoint_to_pytorch
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex import amp
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from transformers.convert_xlnet_original_tf_checkpoint_to_pytorch import convert_xlnet_checkpoint_to_pytorch
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
shutil.copy2(file_path, task_directory_path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.symlink(source_configs_dir, destination)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
sys.path[0:0] = [config.compiledir]
import cuda_ndarray.cuda_ndarray
del sys.path[0]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
last_epoch = max([int(f.stem.split('epoch_')[(- 1)]) for f in saved_models_folder.iterdir()])
self.audio_encoder.load_state_dict(torch.load(str(Path(self.save_model_loc, self.experiment_name, f'audio_encoder_epoch_{last_epoch}.pt'))))
self.mo_encoder.load_state_dict(torch.load(str(Path(self.save_model_loc, self.experiment_name, f'mo_encoder_epoch_{last_epoch}.pt'))))
print(f'Model checkpoints from epoch {last_epoch} loaded...')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
import re
import tensorflow as tf
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
time_since_min_time = datetime.datetime.strptime(time_str, fmt)
min_time = datetime.datetime.strptime('', '')
return float((time_since_min_time - min_time).total_seconds())
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
from transformers import load_tf2_checkpoint_in_pytorch_model
model = load_tf2_checkpoint_in_pytorch_model(model, resolved_archive_file, allow_missing_keys=True)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if ('-' in field):
    (s1, s2) = field.split('-', maxsplit=1)
    if (s1.strip() == ''):
        s1 = None
    else:
        s1 = int(s1)
        if (s1 == 0):
            raise ValueError('1-based string')
    if (s2.strip() == ''):
        s2 = None
    else:
        s2 = int(s2)
else:
    s1 = int(field)
    s2 = (s1 + 1)
    if (s1 == 0):
        raise ValueError('must be 1 or more value')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
ret = {self.name: (self.total / self.count)}
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1
"
import ftfy
from spacy.lang.en import English
_nlp = English()
self.nlp = _nlp.Defaults.create_tokenizer(_nlp)
self.fix_text = ftfy.fix_text
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
iter_time = storage.history('time').global_avg()
eta_seconds = (storage.history('time').median(1000) * (self._max_iter - iteration))
storage.put_scalar('eta_seconds', eta_seconds, smoothing_hint=False)
eta_string = str(datetime.timedelta(seconds=int(eta_seconds)))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import re
import numpy as np
import tensorflow as tf
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
L = torch.cholesky(Asq)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
version = tuple(map(int, version_txt.split('.')))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
np.testing.assert_allclose(x, y, rtol=self.rtol, atol=self.atol, equal_nan=False, verbose=True)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from pandas import Series, DataFrame
types.append((Series, DataFrame))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return self._token_to_index[namespace][self._oov_token]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
raise AssertionError('FPU mode changed from {0:#x} to {1:#x} during the test'.format(old_mode, new_mode))
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
file_contents = file_or_filename.read()
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return super().get_metadata(name)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0
"
img = self._transform(img)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
print(((('Downloading ' + url) + ' to ') + fpath))
urllib.request.urlretrieve(url, fpath, reporthook=gen_bar_updater())
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
copystat(src, dst)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
j = word.index(first, i)
new_word.extend(word[i:j])
i = j
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
import accimage
return accimage.Image(path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from detectron2 import _C
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
print(((('Downloading ' + url) + ' to ') + fpath))
urllib.request.urlretrieve(url, fpath, reporthook=gen_bar_updater())
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from pytorch_transformers import BertTokenizer
from pytorch_transformers.tokenization_utils import clean_up_tokenization
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (cls.construct_from_string(dtype) is not None):
    return True
else:
    return False
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0
"
nice = self.__nice__()
classname = self.__class__.__name__
return f'<{classname}({nice}) at {hex(id(self))}>'
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with open(save_file, 'r') as f:
    last_saved = f.read()
    last_saved = last_saved.strip()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from gym.wrappers import FilterObservation, FlattenObservation
env = FlattenObservation(FilterObservation(env, keys))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from fairseq.data.data_utils_fast import batch_by_size_fast
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from .convert_bert_original_tf_checkpoint_to_pytorch import convert_tf_checkpoint_to_pytorch
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
op = next(generator)
while True:
    if isinstance(op, stash):
        handle_stash(op.name, op.tensor)
        op = next(generator)
        continue
    if isinstance(op, pop):
        tensor = handle_pop(op.name)
        op = generator.send(tensor)
        continue
    raise TypeError(('%r is not a command from @skippable' % op))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
u = getattr(self.module, (self.name + '_u'))
v = getattr(self.module, (self.name + '_v'))
w = getattr(self.module, (self.name + '_w'))
return True
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
output = net(weights)
print('output : ', output.asnumpy())
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
nice = self.__nice__()
classname = self.__class__.__name__
return f'<{classname}({nice}) at {hex(id(self))}>'
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
bb_yaxis = self.yaxis.get_tightbbox(renderer, for_layout_only=for_layout_only)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
self.tokenizer_fun = getattr(self, (self.tokenizer + '_tokenize'))
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
decoder = getattr(core, (decoder_name + '_decoder'))
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import numexpr as ne
visualized_image = ne.evaluate('img * (1 - alpha / 255.0) + rgb * (alpha / 255.0)')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
ray.init(address=args.ray_address)
",0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
utt.assert_allclose(tested, expected, rtol=0.01)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (p_i.shape == arr_i.shape), f'Pointer shape {p_i.shape} and array shape {arr_i.shape} mismatched'
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
oof = pickle.load(open(fn, 'rb'))
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.check_index(indices)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
description = klass.description
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
evaluator = cls.build_evaluator(cfg, dataset_name)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from ..models.t5.convert_t5_original_tf_checkpoint_to_pytorch import convert_tf_checkpoint_to_pytorch
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import unidic_lite
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
svd_fun = tl.SVD_FUNS[svd]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
data = ht.ones((5, 3), dtype=ht.float64)
out = ht.zeros_like(data)
self.assertTrue(data.larray.is_contiguous())
self.assertTrue(out.larray.is_contiguous())
req = data.comm.Iscan(data, out)
req.Wait()
self.assertTrue(data.larray.is_contiguous())
self.assertTrue(out.larray.is_contiguous())
self.assertTrue((out.larray == (data.comm.rank + 1)).all())
data = ht.ones((5, 3), dtype=ht.float64).T
out = ht.zeros_like(data)
self.assertFalse(data.larray.is_contiguous())
self.assertTrue(out.larray.is_contiguous())
req = data.comm.Iscan(data, out)
req.Wait()
self.assertTrue(data.larray.is_contiguous())
self.assertTrue(out.larray.is_contiguous())
self.assertTrue((out.larray == (data.comm.rank + 1)).all())
data = ht.ones((5, 3), dtype=ht.float64)
out = ht.zeros((3, 5), dtype=ht.float64).T
self.assertTrue(data.larray.is_contiguous())
self.assertFalse(out.larray.is_contiguous())
req = data.comm.Iscan(data, out)
req.Wait()
self.assertTrue(data.larray.is_contiguous())
self.assertTrue(out.larray.is_contiguous())
self.assertTrue((out.larray == (data.comm.rank + 1)).all())
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_vocab_file = cached_path(vocab_file, cache_dir=cache_dir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
res = getattr(ffi._backend, funcname)(*args)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
data = base64.urlsafe_b64decode(token)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
lowered_submod = self._lower_model_to_backend(submod, submod_inputs)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
message.FromJsonString(value)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
sig = inspect.signature(self.__init__)
classname = type(self).__name__
argstr = []
for (name, param) in sig.parameters.items():
    assert ((param.kind != param.VAR_POSITIONAL) and (param.kind != param.VAR_KEYWORD)), ""The default __repr__ doesn't support *args or **kwargs""
    assert hasattr(self, name), 'Attribute {} not found! Default __repr__ only works if attributes match the constructor.'.format(name)
    attr = getattr(self, name)
    default = param.default
    if (default is attr):
        continue
    attr_str = pprint.pformat(attr)
    if ('\n' in attr_str):
        attr_str = '...'
    argstr.append('{}={}'.format(name, attr_str))
return '{}({})'.format(classname, ', '.join(argstr))
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
found = (col in self.columns)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
checkpoint_suffix = args.model_name_or_path.split('-')[(- 1)].split('/')[0]
global_step = int(checkpoint_suffix)
epochs_trained = (global_step // (len(train_dataloader) // args.gradient_accumulation_steps))
steps_trained_in_current_epoch = (global_step % (len(train_dataloader) // args.gradient_accumulation_steps))
logger.info('  Continuing training from checkpoint, will skip to saved global_step')
logger.info('  Continuing training from epoch %d', epochs_trained)
logger.info('  Continuing training from global step %d', global_step)
logger.info('  Will skip the first %d steps in the first epoch', steps_trained_in_current_epoch)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
return dialect._type_memos[self]['impl']
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
hit = sorted_hits[j][0]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(real_path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
_resp = _get_simple(_start, _tmp_end)
_res.append(_resp)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
(_, (X, Y, A)) = self.iter_train_clients[client_idx].__next__()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
for file_name in os.listdir(os.path.join(task_directory_path, 'html')):
    self.task_files_to_copy.append(os.path.join(task_directory_path, 'html', file_name))
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(x, y) = next(self.data_iterator)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
classname = self.__class__.__name__
nice = self.__nice__()
return '<{0}({1})>'.format(classname, nice)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return (w.__x, w.__y)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return spaces.Box(shape=self.shape, low=0, high=1, dtype=np.float32)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
response = requests.head(url, allow_redirects=True, proxies=proxies, timeout=etag_timeout)
if (response.status_code == 200):
    etag = response.headers.get('ETag')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
x = f.incremental_forward(x)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
file_name = DatasetCatalog.get('coco_2017_train')[0]['file_name']
if (not PathManager.exists(file_name)):
    raise FileNotFoundError()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
java_version = subprocess.check_output(['java', '-version'], stderr=subprocess.STDOUT)
return ('version' in java_version.decode())
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from qiskit import Aer
backend = Aer.get_backend('qasm_simulator')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
fragments = Chem.GetMolFrags(fragments_mol, asMols=True, sanitizeFrags=True)
if (len(fragments) == 2):
    return fragments
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
output = [self.data[loc] for loc in indexer]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
model.read_model(conf.LGBMODEL_FILE)
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
new_value = int(value)
assert (new_value == value)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0
"
return inspect.getargspec(fn)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
game_module = importlib.import_module(('games.' + game_name))
self.Game = game_module.Game
self.config = game_module.MuZeroConfig()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from sphinx.ext import apidoc
apidoc.main(argv)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(dmin, dmax) = self.viewlim_to_dt()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
data[key] = np.array(list(map(float, value.split(' '))))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
for attr in args.attr.split('.'):
    if attr.isdigit():
        attr = int(attr)
    indict = indict[attr]
print(indict)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
date = datetime.datetime.strptime(text, in_pattern).date()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
assert (p_i.shape == arr_i.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex import amp
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex import amp
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
for e in range(self.nepochs):
    clock0 = time.time()
    self.train_epoch(task_t, xtrain, ytrain)
    clock1 = time.time()
    train_loss = self.eval_validation(task_t, xtrain, ytrain)
    clock2 = time.time()
    print('| Epoch {:3d}, time={:5.1f}ms/{:5.1f}ms | Train: loss={:.3f} |'.format((e + 1), (((1000 * self.sbatch) * (clock1 - clock0)) / xtrain.size(0)), (((1000 * self.sbatch) * (clock2 - clock1)) / xtrain.size(0)), train_loss), end='')
    valid_loss = self.eval_validation(task_v, xvalid, yvalid)
    print(' Valid: loss={:.3f} |'.format(valid_loss), end='')
    if (valid_loss < best_loss):
        best_loss = valid_loss
        best_model = utils.get_model(self.model)
        patience = self.lr_patience
        print(' *', end='')
    else:
        patience -= 1
        if (patience <= 0):
            lr /= self.lr_factor
            print(' lr={:.1e}'.format(lr), end='')
            if (lr < self.lr_min):
                print()
                break
            patience = self.lr_patience
            self.optimizer = self._get_optimizer(lr)
    print()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return self._dictionary[key]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with open(pickle_file, 'rb') as f:
    pickle_data = pickle.load(f)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0
"
contour_measures.append(scalar_products.min())
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
nditer([np.zeros((2, 1, 1)), np.zeros((2,))], [], [['writeonly', 'no_broadcast'], ['readonly']])
raise AssertionError('Should have raised a broadcast error')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
self.images.append(np.block([dataset[image_set]['SHG'], dataset[image_set]['BF']]).astype(np.float32))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
last_line = encoded_lines.pop()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
x_index = int(self.xaxis[(- 1)])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
db.register('u', Opt(), 'b')
self.fail()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
from apex.optimizers import FusedAdam
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import apex
apex.amp.register_half_function(torch, 'einsum')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
batch = next(task_dl)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from detectron2 import _C
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import psutil
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self._custom_adapter = SSHHTTPAdapter(base_url, timeout, pool_connections=num_pools, max_pool_size=max_pool_size, shell_out=use_ssh_client)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from netrc import netrc, NetrcParseError
netrc_path = None
for f in NETRC_FILES:
    try:
        loc = os.path.expanduser('~/{}'.format(f))
    except KeyError:
        return
    if os.path.exists(loc):
        netrc_path = loc
        break
if (netrc_path is None):
    return
ri = urlparse(url)
splitstr = b':'
if isinstance(url, str):
    splitstr = splitstr.decode('ascii')
host = ri.netloc.split(splitstr)[0]
try:
    _netrc = netrc(netrc_path).authenticators(host)
    if _netrc:
        login_i = (0 if _netrc[0] else 1)
        return (_netrc[login_i], _netrc[2])
except (NetrcParseError, IOError):
    if raise_errors:
        raise
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
repo_dpath = dirname(dirname(__file__))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
p2 = ((count_b - count_ab) / (N - count_a))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1
"
from .modeling_tf_pytorch_utils import load_tf2_checkpoint_in_pytorch_model
model = load_tf2_checkpoint_in_pytorch_model(model, resolved_archive_file, allow_missing_keys=True)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
ids.append(word2id[word])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import Mykytea
self.ja_word_tokenizer = Mykytea.Mykytea(('-model %s/local/share/kytea/model.bin' % os.path.expanduser('~')))
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
out = _minimal_ext_cmd(['git', 'rev-parse', 'HEAD'])
sha = out.strip().decode('ascii')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (pointer.shape == ip.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (hasattr(val, 'fgraph') and (val.type == ret.type)):
    return val
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
src_dict = getattr(task, 'source_dictionary', None)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import unicodedata
unicodedata.numeric(s)
return True
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0
"
from fairscale.nn.data_parallel import FullyShardedDataParallel as FSDP
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
dist.init_process_group(backend=backend, init_method=init_method, world_size=1, rank=0, timeout=timedelta(seconds=1))
default_store = c10d._get_default_store()
tik = time.time()
with self.assertRaisesRegex(RuntimeError, 'Timeout'):
    default_store.get('nonexistent key')
tok = time.time()
dist.destroy_process_group()
c2p.append(float((tok - tik)))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
write_output(line)
dist = env.get_distribution(name)
if (dist is not None):
    with indent_log():
        if (dist.version == latest):
            write_output('INSTALLED: %s (latest)', dist.version)
        else:
            write_output('INSTALLED: %s', dist.version)
            if parse_version(latest).pre:
                write_output('LATEST:    %s (pre-release; install with ""pip install --pre"")', latest)
            else:
                write_output('LATEST:    %s', latest)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0
"
setattr(self, key, value)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return bool(eval(x))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
(ls_x, ls_y) = visible['left_shoulder']
(rs_x, rs_y) = visible['right_shoulder']
(mid_shoulder_x, mid_shoulder_y) = (((ls_x + rs_x) / 2), ((ls_y + rs_y) / 2))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self._features.remove(feature)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
assert (p_i.shape == arr_i.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import torch.__config__
return torch.__config__.show()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import idna
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
nice = self.__nice__()
classname = self.__class__.__name__
return f'<{classname}({nice}) at {hex(id(self))}>'
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
nvml.nvmlInit()
devices = (list(range(nvml.nvmlDeviceGetCount())) if (gpus_to_trace is None) else gpus_to_trace)
nvml.nvmlShutdown()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert_allclose((norm(a) - 10000.0), 0.5, atol=0.01)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
last_checkpoint_time = timer()
while (step < flags.total_steps):
    start_step = step
    start_time = timer()
    time.sleep(5)
    if ((timer() - last_checkpoint_time) > (10 * 60)):
        checkpoint()
        last_checkpoint_time = timer()
    sps = ((step - start_step) / (timer() - start_time))
    if stats.get('episode_returns', None):
        mean_return = ('Return per episode: %.1f. ' % stats['mean_episode_return'])
    else:
        mean_return = ''
    total_loss = stats.get('total_loss', float('inf'))
    logging.info('Steps %i @ %.1f SPS. Loss %f. %sStats:\n%s', step, sps, total_loss, mean_return, pprint.pformat(stats))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
n = conv(string)
return True
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
os.kill(int(child.pid), signal.SIGKILL)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
left_position_embeddings = self.x_position_embeddings(bbox[:, :, 0])
upper_position_embeddings = self.y_position_embeddings(bbox[:, :, 1])
right_position_embeddings = self.x_position_embeddings(bbox[:, :, 2])
lower_position_embeddings = self.y_position_embeddings(bbox[:, :, 3])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
del reg[cid]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_archive_file = cached_path(archive_file, cache_dir=cache_dir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
__import__(modulename, globals(), locals(), level=0)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return list(map(x_type, x))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
model_pointer = getattr(model_pointer, sub_layer)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (model.tokens_embed.weight.shape == init_params[1].shape)
assert (model.positions_embed.weight.shape == init_params[0].shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.unlink(path_without_step)
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.symlink(src, dst)
",0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from transformers.convert_bert_original_tf_checkpoint_to_pytorch import convert_tf_checkpoint_to_pytorch
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
name = bound_application.outputs[i]
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
loss = loss_fn(pos_scores, neg_scores, y_label)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
tau = tau.tau
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex.optimizers import FP16_Optimizer
from apex.optimizers import FusedAdam
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
output_label.append(tokenizer.vocab[token])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
batch_outputs[key] = torch.tensor(value)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
AliasCandRecordTrie(load_dir=save_folder)
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
for _ in range(self.chunk_size):
    chunk.append(next(self.itr))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
lazy_import._load_module(module)
return True
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import numpy as np
import tensorflow as tf
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if isinstance(model, ElectraForMaskedLM):
    name = name.replace('electra/embeddings/', 'generator/embeddings/')
if (discriminator_or_generator == 'generator'):
    name = name.replace('electra/', 'discriminator/')
    name = name.replace('generator/', 'electra/')
name = name.replace('dense_1', 'dense_prediction')
name = name.replace('generator_predictions/output_bias', 'generator_lm_head/bias')
name = name.split('/')
if any(((n in ['global_step', 'temperature']) for n in name)):
    logger.info('Skipping {}'.format(original_name))
    continue
pointer = model
for m_name in name:
    if re.fullmatch('[A-Za-z]+_\\d+', m_name):
        scope_names = re.split('_(\\d+)', m_name)
    else:
        scope_names = [m_name]
    if ((scope_names[0] == 'kernel') or (scope_names[0] == 'gamma')):
        pointer = getattr(pointer, 'weight')
    elif ((scope_names[0] == 'output_bias') or (scope_names[0] == 'beta')):
        pointer = getattr(pointer, 'bias')
    elif (scope_names[0] == 'output_weights'):
        pointer = getattr(pointer, 'weight')
    elif (scope_names[0] == 'squad'):
        pointer = getattr(pointer, 'classifier')
    else:
        pointer = getattr(pointer, scope_names[0])
    if (len(scope_names) >= 2):
        num = int(scope_names[1])
        pointer = pointer[num]
if m_name.endswith('_embeddings'):
    pointer = getattr(pointer, 'weight')
elif (m_name == 'kernel'):
    array = np.transpose(array)
try:
    assert (pointer.shape == array.shape), f'Pointer shape {pointer.shape} and array shape {array.shape} mismatched'
except AssertionError as e:
    e.args += (pointer.shape, array.shape)
    raise
print('Initialize PyTorch weight {}'.format(name), original_name)
pointer.data = torch.from_numpy(array)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
byteflow = txn.get(keys[idx])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return str(obj)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0
"
from spacy.lang.en import English
spacy_nlp._nlp = English()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.sent_tok = nltk.data.load(st_path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from ..models.albert.convert_albert_original_tf_checkpoint_to_pytorch import convert_tf_checkpoint_to_pytorch
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
require_version_core(req)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
return accimage.Image(path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
evaluator = cls.build_evaluator(cfg, dataset_name)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.remove((fname + ext))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from fairseq.data.token_block_utils_fast import _get_slice_indices_fast, _get_block_to_dataset_index_fast
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
sh_f_iter = iter(sh_field)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
import revtok
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
smile = Chem.MolToSmiles(mol)
if ((smile is not None) and (smile not in smile_set)):
    smile_set.add(smile)
    new_population.append(mol)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
os.makedirs(save_path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
method = getattr(self, ('_generate_cpy_%s_%s' % (kind, step_name)))
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(a, b, c) = data
if ((a is stub) and (b == '__mul__') and isinstance(c, numbers.Number)):
    return (c, 0.0)
if ((a is stub) and (b == '__add__') and isinstance(c, numbers.Number)):
    return (1.0, c)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
import sentencepiece as spm
self.sp = spm.SentencePieceProcessor()
self.sp.Load(vocab)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from os.path import join as pjoin, dirname
from torch.utils.cpp_extension import load as load_extension
root_dir = pjoin(dirname(__file__), 'src')
_prroi_pooling = load_extension('_prroi_pooling', [pjoin(root_dir, 'prroi_pooling_gpu.c'), pjoin(root_dir, 'prroi_pooling_gpu_impl.cu')], verbose=True)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(_, _, _) = size
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
with self.sess.as_default(), self.sess.graph.as_default():
    while True:
        msgs = {}
        if initial_rollout:
            msg = self.queue.get()
            msgs[msg.op] = msg
            while (not self.queue.empty()):
                msg = self.queue.get()
                msgs[msg.op] = msg
        else:
            while (not self.queue.empty()):
                msg = self.queue.get_nowait()
                msgs[msg.op] = msg
        if (Op.STOP in msgs):
            self.queue.task_done()
            break
        if (Op.UPDATE in msgs):
            (env, policy) = msgs[Op.UPDATE].args
            self.queue.task_done()
        if (Op.DEMO in msgs):
            (param_values, max_length) = msgs[Op.DEMO].args
            policy.set_param_values(param_values)
            initial_rollout = False
            self.rollout(env, policy, max_path_length=max_length, animated=True, speedup=5)
            self.queue.task_done()
        elif max_length:
            self.rollout(env, policy, max_path_length=max_length, animated=True, speedup=5)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return d[name].cell_contents
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
os.mkdir(model_dir)
print('Directory ', model_dir, ' Created')
",0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return [self.protocol_parser[x] for x in filenames]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
classname = self.__class__.__name__
nice = self.__nice__()
return '<{0}({1})>'.format(classname, nice)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return self.clone().scale_(other)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
headerfile = io.open(filename, 'r', 'utf8', 'replace')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from subword_nmt import apply_bpe
bpe_parser = apply_bpe.create_parser()
bpe_args = bpe_parser.parse_args(['--codes', codes, '--separator', args.bpe_separator])
self.bpe = apply_bpe.BPE(bpe_args.codes, bpe_args.merges, bpe_args.separator, None, bpe_args.glossaries)
self.bpe_symbol = (bpe_args.separator + ' ')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
response = requests.head(url, allow_redirects=True, proxies=proxies, timeout=etag_timeout)
if (response.status_code == 200):
    etag = response.headers.get('ETag')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (model.tokens_embed.weight.shape == init_params[1].shape)
assert (model.positions_embed.weight.shape == init_params[0].shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
indices = next(self.sample_iter)
batch = self.collate_fn([self.federated_dataset[self.worker][i] for i in indices])
return batch
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import pydot
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return self.data.num_examples()
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
batch_size = batch.size
(targets, outputs) = self.autoencoder(batch)
loss_data = self.loss_function(outputs, targets.data)
if (self.auto_encoder_type == 'Variational'):
    m = self.autoencoder.variational_layer.mean
    std = self.autoencoder.variational_layer.std
    m = m.mul(m)
    one = torch.ones(m.size())
    if m.is_cuda:
        one = one.cuda()
    var_loss = ((((m + std) - std.log()) - one) * 0.5).sum()
    report_mse += loss_data.item()
    report_kl += var_loss.item()
    report_mu += m.sum().item()
    report_sig += std.sum().item()
    report_el += m.numel()
    loss_data = (loss_data + var_loss)
loss_data.backward()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
colors = [random_color(rgb=True, maximum=1) for k in category_ids]
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
args.outnet_l2
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
gpu_rank = utils.distributed.multi_init(opt, device_id)
if (gpu_rank != opt.gpu_ranks[device_id]):
    raise AssertionError('An error occurred in         Distributed initialization')
single_main(opt, device_id)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
ret = func(*args[limit[0]:])
foundArity[0] = True
return ret
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
trainer.train_step(raw_batch)
trainer.iter()
torch.distributed.barrier()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_model_card_file = cached_path(model_card_file, cache_dir=cache_dir, force_download=True, proxies=proxies, resume_download=False)
if (resolved_model_card_file == model_card_file):
    logger.info('loading model card file {}'.format(model_card_file))
else:
    logger.info('loading model card file {} from cache at {}'.format(model_card_file, resolved_model_card_file))
modelcard = cls.from_json_file(resolved_model_card_file)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
classname = self.__class__.__name__
nice = self.__nice__()
return f'<{classname}({nice})>'
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
iter_time = storage.history('time').global_avg()
eta_seconds = (storage.history('time').median(1000) * (self._max_iter - iteration))
storage.put_scalar('eta_seconds', eta_seconds, smoothing_hint=False)
eta_string = str(datetime.timedelta(seconds=int(eta_seconds)))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
df_tot = df_tot.append(df, ignore_index=True)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(x, y) = fetch_iamondb_file(strokes_n, ascii_n)
y_set.extend(y)
x_set.extend(x)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
(audio, _) = load_audio(source_path, start=intfr_start, dur=self.seq_duration)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from fairseq import libnat
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
model_class = config.architectures[0]
transformers_module = __import__('transformers', fromlist=[model_class])
model_cls = getattr(transformers_module, model_class)
model = model_cls(config)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
phones = ' '.join(splits[2:])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
y = ep.astensor(x)
if (not isinstance(y, type(self._dummy))):
    raise ValueError
return y
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
checkpoint_suffix = args.model_name_or_path.split('-')[(- 1)].split('/')[0]
global_step = int(checkpoint_suffix)
epochs_trained = (global_step // (len(train_dataloader) // args.gradient_accumulation_steps))
steps_trained_in_current_epoch = (global_step % (len(train_dataloader) // args.gradient_accumulation_steps))
logger.info('  Continuing training from checkpoint, will skip to saved global_step')
logger.info('  Continuing training from epoch %d', epochs_trained)
logger.info('  Continuing training from global step %d', global_step)
logger.info('  Will skip the first %d steps in the first epoch', steps_trained_in_current_epoch)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
src_dict = getattr(task, 'source_dictionary', None)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_config_file = cached_path(config_file, cache_dir=cache_dir, force_download=force_download, proxies=proxies, resume_download=resume_download, local_files_only=local_files_only)
if (resolved_config_file is None):
    raise EnvironmentError
config_dict = cls._dict_from_json_file(resolved_config_file)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(X, y)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.ws = WebsocketServer(port, host='127.0.0.1')
self.port = port
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
linthresh = self.axis.get_transform().linthresh
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
recall_stats = box_label_recall(anno['hois'], human_boxes.tolist(), object_boxes.tolist(), object_labels, exp_const.iou_thresh, hoi_list)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (pointer.shape == array.shape), f'Pointer shape {pointer.shape} and array shape {array.shape} mismatched'
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (tuple(pointer.shape) == array.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
lvls.append(next(bfs_generator))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
model.load_weights(resolved_archive_file, by_name=True)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
actual = dist.entropy()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
for attr in args.attr.split('.'):
    if attr.isdigit():
        attr = int(attr)
    indict = indict[attr]
print(indict)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
next(module.parameters())
return True
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
h = self.activation_function((F.linear(theta, torch.t(self.Wx)) + F.linear(x, torch.t((self.Ms[0] * self.Ws[0])), self.bs[0])))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (model.tokens_embed.weight.shape == init_params[1].shape)
assert (model.positions_embed.weight.shape == init_params[0].shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if ('pythainlp' not in sys.modules):
    from pythainlp.tokenize import word_tokenize as th_word_tokenize
else:
    th_word_tokenize = sys.modules['pythainlp'].word_tokenize
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_archive_file = cached_path(archive_file, cache_dir=cache_dir, force_download=force_download, resume_download=resume_download, proxies=proxies)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
action_batch = self.test_net(batch).max(1)[1]
action_list += list(action_batch.cpu().numpy())
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
(firstaxis, parity, repetition, frame) = _AXES2TUPLE[axes.lower()]
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if torchscript:
    print('Tracing model with sequence size', sequence.shape)
    inference = torch.jit.trace(model, sequence)
    inference(sequence)
else:
    inference = model
    inference(sequence)
if (not no_memory):
    trace = start_memory_tracing('transformers')
    inference(sequence)
    summary = stop_memory_tracing(trace)
    if verbose:
        print_summary_statistics(summary)
    dictionary[model_name]['memory'][batch_size][slice_size] = str(summary.total)
else:
    dictionary[model_name]['memory'][batch_size][slice_size] = 'N/A'
if (not no_speed):
    print('Going through model with sequence of shape', sequence.shape)
    runtimes = timeit.repeat((lambda : inference(sequence)), repeat=average_over, number=3)
    average_time = ((sum(runtimes) / float(len(runtimes))) / 3.0)
    dictionary[model_name]['results'][batch_size][slice_size] = average_time
else:
    dictionary[model_name]['results'][batch_size][slice_size] = 'N/A'
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
mnist_datasets = joblib.load(dataset_file)
logger.info('Dataset has been loaded from cache.')
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return self._pkg_info
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
batch = next(lazy_batches)
if ((not self._skip_smaller_batches) or (len(batch) == self._batch_size)):
    (yield Batch(batch))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
dataloader = self.downstream.model.get_dataloader(train_split, epoch=epoch)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
n_items = (((len(private_train_loader) - 1) * args.batch_size) + len(private_train_loader[(- 1)][1]))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
var_file_handle = open(var_file, 'r')
for line in var_file_handle:
    parts = line.split('=')
    field_name = parts[0].strip()
    field_value = parts[1].strip()
    if (field_name in ['model_left_context', 'left_context']):
        variables['model_left_context'] = int(field_value)
    elif (field_name in ['model_right_context', 'right_context']):
        variables['model_right_context'] = int(field_value)
    elif (field_name == 'num_hidden_layers'):
        if (int(field_value) > 1):
            raise Exception('You have num_hidden_layers={0} (real meaning: your config files are intended to do discriminative pretraining).  Since Kaldi 5.2, this is no longer supported --> use newer config-creation scripts, i.e. xconfig_to_configs.py.'.format(field_value))
    else:
        variables[field_name] = field_value
return variables
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
import psutil
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
for i in range(0, len(images), batch_size):
    predictions.extend(detector.get_detections_for_batch(np.array(images[i:(i + batch_size)])))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.out_idx2symbol += [mask_list[i] for i in range(self.copy_nums)]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
act = deepcopy(agents[0].act())
print('test', act)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
src_dict = getattr(task, 'source_dictionary', None)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
tick = time.time()
run_epoch(experiment, net, optimizer, dataloader, control_loss, use_tqdm=use_tqdm)
tock = time.time()
print(('Finished epoch %d in %f seconds.' % (postfix, (tock - tick))))
experiment.log_epoch_end(postfix)
",0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.file_name = int(file_name)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
weight = params[('%s.conv.weight' % old_layername)]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
loader(state)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with open(vocab_path, 'r', encoding=encoding) as f:
    labels = csv.reader(f, delimiter=',')
    next(labels)
    for row in labels:
        unit2id[row[1]] = row[0]
        id2unit[int(row[0])] = row[1]
return (unit2id, id2unit)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex.parallel import DistributedDataParallel as DDP
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
repo_dpath = dirname(dirname(__file__))
repo_dpath = join(repo_dpath, '..')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from fairseq.data.token_block_utils_fast import _get_slice_indices_fast, _get_block_to_dataset_index_fast
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
function = getattr(self, sub_expression[0])
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(save_path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if self.tpu_name:
    tpu = tf.distribute.cluster_resolver.TPUClusterResolver(self.tpu_name)
else:
    tpu = tf.distribute.cluster_resolver.TPUClusterResolver()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
num = int(out)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
data_ss = next(selfsupIterator)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
crc = (binascii.crc32(bytearray(shingle, encoding='utf-8')) & 4294967295)
shinglesInDoc.add(crc)
count += 1
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
lr = '{:.6f}'.format(storage.history('lr').latest())
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
pointer = getattr(pointer, scope_names[0])
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (attr not in ambiguous_methods)
hook_args = hook_method_args_functions[attr_id]
(new_self, new_args) = hook_args((method_self, args_))
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
bits = int(self.rawmode[2:])
if (bits not in [8, 16, 32]):
    self.tile = [('bit', ((0, 0) + self.size), offs, (bits, 8, 3, 0, (- 1)))]
    return
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
(dropout_schedule_index, initial_data_fraction, initial_dropout) = next(((i, tup[0], tup[1]) for (i, tup) in enumerate(dropout_schedule) if (tup[0] <= data_fraction)))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return [v.to(unit).magnitude for v in value]
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(_loss, sample_size, logging_output) = self.task.valid_step(sample, self.model, self.criterion)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import numpy as np
import tensorflow as tf
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (model_pointer.shape == array.shape), f'Pointer shape {model_pointer.shape} and array shape {array.shape} mismatched'
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (pointer.shape == array.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return torch.cat([(self.W[None, :, :] - centroids_c[:, :, None]).norm(p=2, dim=1) for centroids_c in self.centroids.chunk(nb_centroids_chunks, dim=0)], dim=0)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
np.reshape(v[field], schema_content[field]['shape'])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
return '{:.2f}'.format(math.pow(2, loss))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import psutil
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return self._matrix[self._w2idx[y]]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
arr.remove('[')
arr.remove(']')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
data.append(('torchvision', ((str(torchvision.__version__) + ' @') + os.path.dirname(torchvision.__file__))))
if has_cuda:
    try:
        torchvision_C = importlib.util.find_spec('torchvision._C').origin
        msg = detect_compute_compatibility(CUDA_HOME, torchvision_C)
        data.append(('torchvision arch flags', msg))
    except ImportError:
        data.append(('torchvision._C', 'failed to find'))
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return str(obj)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0
"
from apex import amp
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
decoder.setimage(self.im, extents)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
name_len = max((len(name) for name in axis.names))
name_arr = np.zeros(size, dtype='S{}'.format(name_len))
for name in axis.names:
    if name:
        name_arr[axis.convert_key_item(name)] = name
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.peeked = next(self.it)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import pyfftw
__has_pyfftw = True
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
bypass = proxy_bypass(parsed.hostname)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
dist = (hvd.size() != hvd.local_size())
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
w = tokenizer.convert_tokens_to_ids(token)
if (w != None):
    output_label.append(w)
else:
    print('Have no this tokens in ids')
    exit()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return self.ctx_encoder.bert_model.get_input_embeddings()
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(yield next(iters[idx]))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import allennlp.commands.elmo
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
sst_labels = h_dataset.sst_labels
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
obj = pickle.load(open(path, 'rb'))
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import re
import numpy as np
import tensorflow as tf
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
shutil.rmtree(WORKING_REPO_DIR)
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
sys.path.insert(0, os.path.join(os.path.dirname(__file__), 'transformers', 'src'))
from transformers import GPT2Config, GPT2LMHeadModel
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
cpu_sum = float(x.float().sum())
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
for i in range(n_parts):
    (sample_points, sample_values, exceed, bbox_ratio) = sample_points_from_vox3d(parts_voxel[i], dim_voxel, batch_size)
    parts_points.append(sample_points)
    parts_values.append(sample_values)
    bbox_ratios += bbox_ratio
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
st = os.stat(addr)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
colors = [random_color(rgb=True, maximum=1) for k in category_ids]
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return torch.cat([(self.W[None, :, :] - centroids_c[:, :, None]).norm(p=2, dim=1) for centroids_c in self.centroids.chunk(nb_centroids_chunks, dim=0)], dim=0)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with open(save_file, 'r') as last_checkpoint:
    f = last_checkpoint.read().strip()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
num_targets = int(variables['num_targets'])
if (common_lib.get_feat_dim_from_scp(args.targets_scp) != num_targets):
    raise Exception('Mismatch between num-targets provided to script vs configs')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
del self.plotly_fig['layout'][key]
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import sentencepiece as spm
self.sp = spm.SentencePieceProcessor()
self.sp.Load(sentencepiece_model)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
GradNetWrtX(Net())(x, y)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
import torch
from torch import nn
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (pointer.shape == array.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
for epoch in range(self.niter):
    s_g_max = ((((smax_g - (1 / smax_g)) * epoch) / self.niter) + (1 / smax_g))
    print('s_g_max: ', s_g_max)
    self.write_log_epoch_start(t, epoch, smax_g, lamb_G)
    r = np.arange(data_train_x.shape[0])
    r = torch.LongTensor(r)
    for i in range(0, len(r), self.batchSize):
        if ((i + self.batchSize) <= len(r)):
            b = r[i:(i + self.batchSize)]
        else:
            b = r[i:]
        self.netD.zero_grad()
        self.netD.train()
        s_g = ((((s_g_max - (1 / s_g_max)) * i) / len(r)) + (1 / s_g_max))
        (img, label) = (data_train_x[b], data_train_y[b])
        aux_img = img
        aux_label = label
        if (t > 0):
            for t_past in range(t):
                aux_img = torch.cat((aux_img, data[t_past]['train']['x'][b].detach()))
                aux_label = torch.cat((aux_label, data[t_past]['train']['y'][b]))
        idx = np.random.permutation(aux_img.shape[0])
        aux_img = aux_img[idx]
        aux_label = aux_label[idx]
        aux_batch_size = aux_img.size(0)
        loss_G_aux = []
        for bb in range(0, aux_batch_size, len(b)):
            img_b = aux_img[bb:(bb + len(b))]
            bb_label = aux_label[bb:(bb + len(b))]
            self.input_.data.resize_(img_b.size()).copy_(img_b.detach())
            self.c_label.data.resize_(img_b.size(0)).copy_(bb_label)
            (_, c_output) = self.netD(self.input_)
            c_errD_real = self.c_criterion(c_output, self.c_label)
            loss_G_aux.append(c_errD_real)
            c_errD_real.backward()
            self.optimizerD.step()
            self.netD.zero_grad()
        self.netD.zero_grad()
        batch_size = img.size(0)
        self.input_.resize_(img.size()).copy_(img)
        (s_output, _) = self.netD(self.input_)
        D_x = s_output.mean()
        s_errD_real = (- D_x)
        s_errD_real.backward()
        n_fake = batch_size
        self.c_label.data.resize_(batch_size).copy_(label)
        (noise, radom_label) = self.generate_noise(t, n_fake, self.c_label.data.cpu().numpy())
        (fake, masks_G) = self.netG(noise, t, self.c_label, s_g)
        (s_output_fake, _) = self.netD(fake.detach())
        D_x_fake = s_output_fake.mean()
        errD_fake = D_x_fake
        errD_fake.backward()
        gradient_penalty = self.calc_gradient_penalty(self.netD, self.input_, fake, batch_size)
        gradient_penalty.backward()
        errD = ((errD_fake - s_errD_real) + gradient_penalty)
        self.optimizerD.step()
        self.netG.zero_grad()
        (noise, radom_label) = self.generate_noise(t, n_fake, self.c_label.data.cpu().numpy())
        (fake, masks_G) = self.netG(noise, t, self.c_label, s_g)
        (s_output, c_output) = self.netD(fake)
        (source_l, mask_reg_l, _) = self.criterion(s_output, masks_G, lamb_G)
        c_errG = self.c_criterion(c_output, self.c_label)
        c = (int(math.floor((i / self.batchSize))) + (int((math.floor((data_train_x.shape[0] / self.batchSize)) + 1)) * epoch))
        errG = ((- source_l) + mask_reg_l)
        if use_aux_G:
            errG += c_errG
        errG.backward()
        if (t > 0):
            for (n, p) in self.netG.named_parameters():
                if ((n in self.mask_back_G) and (p.grad is not None)):
                    p.grad.data *= self.mask_back_G[n]
        for (n, p) in self.netG.named_parameters():
            if ('ec.' in n):
                num = (torch.cosh(torch.clamp((s_g * p.data), (- thres_cosh), thres_cosh)) + 1)
                den = (torch.cosh(p.data) + 1)
                if (p.grad is not None):
                    p.grad.data *= (((s_g_max / s_g) * num) / den)
        torch.nn.utils.clip_grad_norm_(self.netG.parameters(), clipgrad)
        self.optimizerG.step()
        self.netG.zero_grad()
        print(('|[%d/%d][%d/%d] Loss_D: %.2f Loss_G: %.2f D(x): %.2f D(G(z)):  %.2f / %.2f' % (epoch, self.niter, (i / self.batchSize), (data_train_x.shape[0] / self.batchSize), errD.data.item(), errG.data.item(), s_errD_real, errD_fake, source_l)))
    self.write_log_epoch_end(t, epoch, s_g)
    if ((epoch % 2) == 0):
        self.netG.eval()
        (loss_valid, valid_acc, _) = self.valid(data, t, epoch, self.netD, 'valid')
        (loss, test_accs, _) = self.valid(data, t, epoch, self.netD, 'test')
        test_acc_task.append(test_accs)
        print(('-' * 100))
        if ((epoch % 10) == 0):
            norm = False
            if (self.dataset == 'svhn'):
                norm = True
            vutils.save_image(aux_img, ('%s/real_samples_task%d_epoch_%d.png' % (self.outf, t, epoch)), normalize=norm)
            lables_noise = torch.FloatTensor(list(chain(*(([x] * 40) for x in range(torch.min(self.unique_classes[t]), (torch.max(self.unique_classes[t]) + 1))))))
            self.c_label.data.resize_(lables_noise.shape[0]).copy_(lables_noise)
            (noise, radom_label) = self.generate_noise(t, lables_noise.shape[0], self.c_label.data.cpu().numpy())
            (fake, _) = self.netG(noise, t, self.c_label, s_g)
            vutils.save_image(fake.data, ('%s/fake_samples__task_%d_epoch_%03d.png' % (self.outf, t, epoch)), normalize=norm)
            if (t > 0):
                for u in range((t + 1)):
                    lables_noise = torch.FloatTensor(list(chain(*(([x] * 20) for x in range(torch.min(self.unique_classes[u]), (torch.max(self.unique_classes[u]) + 1))))))
                    self.c_label.data.resize_(lables_noise.shape[0]).copy_(lables_noise)
                    (noise, _) = self.generate_noise(u, lables_noise.shape[0], self.c_label.data.cpu().numpy())
                    (fake, _) = self.netG(noise, u, self.c_label, smax_g)
                    vutils.save_image(fake.data, ('%s/fake_samples_from_%d_task_%d_epoch_%03d.png' % (self.outf, u, t, epoch)), normalize=norm)
        self.netG.train()
    self.global_step += 1
(loss_valid, valid_acc, _) = self.valid(data, t, epoch, self.netD, 'valid')
(loss, test_accs, conf_matrixes_task) = self.valid(data, t, epoch, self.netD, 'test')
test_acc_task.append(test_accs)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
((a, b, c), d, e) = data
if ((a is stub) and (b == '__mul__') and isinstance(c, numbers.Number) and (d == '__add__') and isinstance(e, numbers.Number)):
    return (c, e)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
hg_subprocess = Popen(hg_command_tuple, stdout=PIPE, stderr=PIPE)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex import amp
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.top_beam_finished = self.top_beam_finished.bool()
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
cls = self._registered[name]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import re
import numpy as np
import tensorflow as tf
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
basename = self._memmaped_arrays.get(a)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
hook = backend.get_requires_for_build_sdist
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
loss = self.compute_loss(batch)
self.metrics['loss'] += loss.item()
self.backward(loss)
self.update_params()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
np.testing.assert_allclose(x, y, rtol=self.rtol, atol=self.atol, equal_nan=True, verbose=True)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with open(coq_file, 'r', newline='') as f:
    source_code = f.read()
unicode_offsets = ParserUtils.get_unicode_offsets(source_code)
ast_sexp_str: str = BashUtils.run(f'sercomp {serapi_options} --mode=sexp -- {coq_file}', expected_return_code=0).stdout
tok_sexp_str: str = BashUtils.run(f'sertok {serapi_options} -- {coq_file}', expected_return_code=0).stdout
ast_sexp_list: List[SexpNode] = SexpParser.parse_list(ast_sexp_str)
tok_sexp_list: List[SexpNode] = SexpParser.parse_list(tok_sexp_str)
coq_document = CoqParser.parse_document(source_code, ast_sexp_list, tok_sexp_list, unicode_offsets=unicode_offsets)
coq_document.file_name = coq_file
coq_document.project_name = project_path.name
coq_documents[coq_file] = coq_document
ast_sexp_lists[coq_file] = ast_sexp_list
tok_sexp_lists[coq_file] = tok_sexp_list
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return accimage.Image(path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
wheel_names = os.listdir(root)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
for _ in range(self.chunk_size):
    chunk.append(next(self.itr))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
mask_without_bos_eos = (word_inputs > 0).long()
embedded_inputs = self._word_embedding(word_inputs)
(type_representation, mask) = add_sentence_boundary_token_ids(embedded_inputs, mask_without_bos_eos, self._bos_embedding, self._eos_embedding)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import cityscapesscripts.evaluation.evalInstanceLevelSemanticLabeling as CSEval
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
model.load_state_dict(torch.load((((args.dataset + '-') + str(args.layers)) + '.pkl')), strict=True)
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(firstaxis, parity, repetition, frame) = _AXES2TUPLE[axes.lower()]
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import sentencepiece as spm
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (pointer.shape == array.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import torch.utils.cpp_extension
torch.utils.cpp_extension.verify_ninja_availability()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
dlat_e01 = Gs_clone.components.mapping.get_output_for(lat_e01, None, is_validation=True)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
lines = [int(num) for line in qtables.splitlines() for num in line.split('#', 1)[0].split()]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
assert (isinstance(s, str) or isinstance(s, list))
if isinstance(s, list):
    s = ' '.join(s)
s = s.replace('ENDCOM', 'NEW_LINE')
s = s.replace('▁', 'SPACETOKEN')
lines = s.split('NEW_LINE')
tabs = ''
for (i, line) in enumerate(lines):
    line = line.strip()
    if line.startswith('INDENT '):
        tabs += '    '
        line = line.replace('INDENT ', tabs)
    elif line.startswith('DEDENT'):
        number_dedent = line.count('DEDENT')
        tabs = tabs[(4 * number_dedent):]
        line = line.replace('DEDENT', '')
        line = line.strip()
        line = (tabs + line)
    elif (line == 'DEDENT'):
        line = ''
    else:
        line = (tabs + line)
    lines[i] = line
untok_s = '\n'.join(lines)
try:
    for (toktype, tok, _, _, line) in tokenize.tokenize(BytesIO(untok_s.encode('utf-8')).readline):
        if ((toktype == tokenize.STRING) or (toktype == tokenize.COMMENT)):
            tok_ = tok.replace('STRNEWLINE', '\n').replace('TABSYMBOL', '\t').replace(' ', '').replace('SPACETOKEN', ' ')
            untok_s = untok_s.replace(tok, tok_)
except KeyboardInterrupt:
    raise
except:
    pass
untok_s = untok_s.replace('. ', '.').replace(' .', '.').replace('import.', 'import .').replace('from.', 'from .')
untok_s = untok_s.replace('> >', '>>').replace('< <', '<<')
return untok_s
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
final_dict[prop_key]['true_val_with_node_ids'].update(res_dict[prop_key]['true_val_with_node_ids'])
final_dict[prop_key]['pred_val_with_node_ids'].update(res_dict[prop_key]['pred_val_with_node_ids'])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return datetime.strptime(t[0], fmt)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
return cls._prefix_from_ip_int(ip_int)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
from fairseq.modules.dynamicconv_layer import DynamicconvLayer
return DynamicconvLayer(input_size, kernel_size=kernel_size, padding_l=padding_l, num_heads=num_heads, weight_dropout=weight_dropout, weight_softmax=weight_softmax, bias=bias)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
cm = plt.get_cmap(cmap)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
torch.testing.assert_allclose(a, b, rtol=rtol, atol=atol)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
exc_value = exc_type((((str(exc_value) + detailed_err_msg) + '\n') + '\n'.join(hints)))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
me = os.path.realpath(os.path.abspath(__file__))
me_dir = os.path.normcase(os.path.splitext(me)[0])
vsr_dir = os.path.normcase(os.path.splitext(versioneer_py)[0])
if (me_dir != vsr_dir):
    print(('Warning: build in %s is using versioneer.py from %s' % (os.path.dirname(me), versioneer_py)))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from sacremoses import MosesPunctNormalizer
self.punc_normalizer = MosesPunctNormalizer(self.source_lang).normalize
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
target_assoc = self._cls_unwrap_target_assoc_proxy(target_class, self.value_attr)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from jiant.modules.cove.cove import MTLSTM as cove_lstm
cove_layer = cove_lstm(n_vocab=n_token_vocab, vectors=embeddings.weight.data)
for param in cove_layer.parameters():
    param.requires_grad = bool(args.cove_fine_tune)
d_emb += 600
log.info('\tUsing CoVe embeddings!')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from fairseq import libnat_cuda
return (libnat_cuda, True)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
((rule, sizes),) = generator.choices(sized_rules, cum_weights=cum_weights)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (pointer.shape == array.shape), f'Pointer shape {pointer.shape} and array shape {array.shape} mismatched'
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
currentlevel = currentlevel[(- 1)]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(module, edges, node_features) = self[self.counter]
module(*self.dryrun_args)
break
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
repo_dpath = dirname(dirname(__file__))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
while (remaining_sequences > 0):
    next_batch = next(dataloader_iterator)
    batch_tuple = next_batch.to_tuple()
    (observations, _, _, _) = batch_tuple
    observations = observations.cpu().numpy()
    current_sequences = observations.shape[0]
    if (current_sequences > remaining_sequences):
        required_observations = observations[:remaining_sequences]
        excess_observation = observations[remaining_sequences:]
        excess_sequence_buffer.append(excess_observation)
        buffer.append(required_observations)
        remaining_sequences = 0
    else:
        buffer.append(observations)
        remaining_sequences -= current_sequences
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import cv2
data.append(('cv2', cv2.__version__))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import cityscapesscripts.evaluation.evalPixelLevelSemanticLabeling as CSEval
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return torch.cat([(self.W[None, :, :] - centroids_c[:, :, None]).norm(p=2, dim=1) for centroids_c in self.centroids.chunk(nb_centroids_chunks, dim=0)], dim=0)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
idx = next(self.iter)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
ckpt_path = self.get_latest_from_index(self.ckpt_dir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
del self.teacher.model.encoder
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from transformers.convert_transfo_xl_original_tf_checkpoint_to_pytorch import convert_transfo_xl_checkpoint_to_pytorch
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return self._python_apply_general(curried, self._obj_with_exclusions)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
tensorized_scalar = torch.tensor(scalars).cuda()
output_tensors = [tensorized_scalar.clone() for _ in range(torch.distributed.get_world_size())]
torch.distributed.all_gather(output_tensors, tensorized_scalar)
concat = torch.cat(output_tensors, dim=0)
if (num_total_examples is not None):
    concat = concat[:num_total_examples]
return concat
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from transformers.convert_gpt2_original_tf_checkpoint_to_pytorch import convert_gpt2_checkpoint_to_pytorch
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from torch.utils.tensorboard import SummaryWriter
print('> setting tensorboard ...')
_GLOBAL_TENSORBOARD_WRITER = SummaryWriter(log_dir=args.tensorboard_dir, max_queue=args.tensorboard_queue_size)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if callable(obj):
    annotations = app.env.temp_data.setdefault('annotations', {})
    annotation = annotations.setdefault(name, OrderedDict())
    sig = inspect.signature(obj)
    for param in sig.parameters.values():
        if (param.annotation is not param.empty):
            annotation[param.name] = typing.stringify(param.annotation)
    if (sig.return_annotation is not sig.empty):
        annotation['return'] = typing.stringify(sig.return_annotation)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
orig_modules[name] = sys.modules[name]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
delete_folder(pool_subfolder, allow_non_empty=True)
resource_tracker.unregister(pool_subfolder, 'folder')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
gpu_rank = onmt.utils.distributed.multi_init(opt, device_id)
if (gpu_rank != opt.gpu_ranks[device_id]):
    raise AssertionError('An error occurred in                   Distributed initialization')
single_main(opt, device_id, batch_queue, semaphore)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import pg8000
pytest.skip('pg8000 is installed')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex import amp
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if es.keep_best(valid_loss[0]):
    self.best_model = {'model': self.model, 'epoch': self.current_epoch, 'train_loss': epoch_loss[0], 'valid_loss': valid_loss[0]}
    print(' *- New best model at epoch ', self.current_epoch)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
nice = self.__nice__()
classname = self.__class__.__name__
return '<{0}({1}) at {2}>'.format(classname, nice, hex(id(self)))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex.optimizers import FP16_Optimizer
from apex.optimizers import FusedAdam
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
print(((('Downloading ' + url) + ' to ') + fpath))
urllib.request.urlretrieve(url, fpath, reporthook=gen_bar_updater(tqdm(unit='B', unit_scale=True)))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
token_classification_task_clazz = getattr(module, model_args.task_type)
token_classification_task: TokenClassificationTask = token_classification_task_clazz()
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
shutil.rmtree(temp_name)
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
pointer = getattr(pointer, scope_names[0])
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.sent_tok = nltk.data.load(st_path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import torch
self.use_cuda = ((not opt.get('no_cuda', False)) and torch.cuda.is_available())
self.torch = torch
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (pointer.shape == array.shape), f'Pointer shape {pointer.shape} and array shape {array.shape} mismatched'
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
file_list.remove(x)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
nn.utils.remove_weight_norm(module)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
return json.loads(self.study.best_trial.system_attrs[_LGBM_PARAMS_KEY])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
text_a = line[q1_index]
text_b = line[q2_index]
label = (None if test_mode else line[5])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
repo_dpath = dirname(dirname(__file__))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import psutil
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
cls_name = ((cls.__module__ + '.') + cls.__qualname__)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
setattr(self, key, value)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return val.imag
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
parsed = parse_datetime(value, fuzzy=fuzzy)
if (parsed is None):
    return numpy.nan
else:
    return parsed.timestamp()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0
"
self.__end
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self._analyse_timeline(aicpu_data_parser, optime_parser, source_path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import cityscapesscripts.helpers.labels as CSLabels
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
disp = IPython.display.display(IPython.display.Image(im_data))
if filename:
    size = ((a.shape[1] // 2), (a.shape[0] // 2))
    im = PIL.Image.fromarray(a)
    im.thumbnail(size, PIL.Image.ANTIALIAS)
    im.save('{}.{}'.format(filename, format))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (pointer.shape == array.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import re
import numpy as np
import tensorflow as tf
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
v = int(v)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
logger.debug('Removing entry: %s', entry)
lines.remove((entry + endline).encode('utf-8'))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
from .convert_tf_checkpoint_to_pytorch import convert_tf_checkpoint_to_pytorch
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return bool(eval(x))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
pretrained_dict = checkpoint['state_dict']
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
outchans[cl].remove(lc)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
tf.get_default_graph().get_tensor_by_name(tensor_name)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
oldval = getattr(self, key)
assert (oldval == val), ""Attribute '{}' in the metadata of '{}' cannot be set to a different value!\n{} != {}"".format(key, self.name, oldval, val)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resp = requests.post(address, json=self.cc.settings)
assert (resp.status_code == 200), resp.text
self._logger.info('Successfully started experiment on {}'.format(address))
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
state_dict = torch.load(pretrain_path, map_location=torch.device('cpu'))
logger.info(f'Loading pretrained model from {pretrain_path}')
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if ('pythainlp' not in sys.modules):
    from pythainlp.tokenize import word_tokenize as th_word_tokenize
else:
    th_word_tokenize = sys.modules['pythainlp'].word_tokenize
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
top_left = torch.flip(torch.linalg.cholesky(torch.flip(schur_complement, ((- 2), (- 1)))), ((- 2), (- 1)))
break
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import matplotlib.image as im
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from tokenizers import ByteLevelBPETokenizer
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
max_idx = (((r - x) ** 2) + ((c - y) ** 2)).argmax()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
return name.encode('ascii')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0
"
return self.TYPE_MAP_XML[typ]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
for _ in range(params.n_epochs):
    ctr = 0
    was_last = {d: True for d in datasets.keys()}
    while True:
        dataset = np.random.choice(list(datasets.keys()), p=list(datasets.values()))
        if was_last[dataset]:
            d2epochs[dataset] += 1
            logger.info(('Training on buffer %d for dataset %s' % (d2epochs[dataset], dataset)))
            logger.info('Sampled datasets {}'.format(d2epochs))
        epoch = d2epochs[dataset]
        (loss, is_last) = one_batch(train_iterator, dataset, model, optimizer)
        was_last[dataset] = is_last
        losses.append((loss * params.n_grad_accumulation_steps))
        examples_processed += params.batch_size
        total_examples_processed += params.batch_size
        if ((ctr % params.n_grad_accumulation_steps) == 0):
            torch.nn.utils.clip_grad_norm_(model.parameters(), 1.0)
            optimizer.step()
            optimizer.zero_grad()
        ctr += 1
        if (((total_examples_processed % params.print_freq) == 0) and (total_examples_processed > 0)):
            cur_loss = np.mean(losses)
            time_elapsed = (time.time() - start_time)
            ms_per_example = ((time_elapsed / float(examples_processed)) * 1000.0)
            cur_lr = (optimizer.optimizer.cur_lr if params.fp16 else optimizer.cur_lr)
            logger.info(('-' * 80))
            logger.info('Buffer # {:3d} | {:5d} examples processed | ms/sequence {:5.2f} | lr {:5.8f} | data {} | loss {:5.2f} | ppl {:8.2f}'.format(epoch, total_examples_processed, ms_per_example, cur_lr, '+'.join(datasets.keys()), cur_loss, np.exp(cur_loss)))
            logger.info(('-' * 80))
            examples_processed = 0
            start_time = time.time()
            losses = []
        if (((total_examples_processed % params.eval_freq) == 0) and (total_examples_processed > 0)):
            dev_ce = 0
            for (d, w) in datasets.items():
                logger.info(('Computing Valid set PPL on %s...' % d))
                dev_losses = validation(dev_iterator, d, model)
                tmp_dev_ce = np.nanmean(dev_losses)
                logger.info('{:5.3f}'.format(np.exp(tmp_dev_ce)))
                dev_ce += (w * tmp_dev_ce)
            not_improved += 1
            patience -= 1
            if (dev_ce < best_dev_ce):
                best_dev_ce = dev_ce
                not_improved = 0
                patience = params.patience
                logger.info(('Saving best model at %.5f PPL ...' % np.exp(best_dev_ce)))
                save_best_model(model, optimizer, best_dev_ce)
            logger.info(('-' * 80))
            logger.info('Buffer # {:3d} | {:5d} examples processed | data {} | Valid CE {:5.3f} | Valid PPL {:5.3f} | Improved {:3d} steps ago | patience {:3d}'.format(epoch, total_examples_processed, datasets, dev_ce, np.exp(dev_ce), not_improved, patience))
            logger.info(('-' * 80))
            logger.info('Saving current model ...')
            save_curr_model(model, optimizer, datasets, patience)
            model.train()
            if (patience < 0):
                return (patience, datasets)
return (patience, datasets)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.logger.info(""Loading checkpoint '{}'"".format(filename))
checkpoint = torch.load(filename, map_location='cuda:{}'.format(self.config.gpu_device))
self.current_epoch = checkpoint['epoch']
self.current_iteration = checkpoint['iteration']
try:
    self.rateReachGoal = checkpoint['rateReachGoal']
except:
    pass
self.model.load_state_dict(checkpoint['state_dict'])
self.optimizer.load_state_dict(checkpoint['optimizer'])
self.scheduler.load_state_dict(checkpoint['scheduler_state_dict'])
self.logger.info(""Checkpoint loaded successfully from '{}' at (epoch {}) at (iteration {})\n"".format(self.config.checkpoint_dir, checkpoint['epoch'], checkpoint['iteration']))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
repo_dpath = dirname(dirname(dirname(__file__)))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
experiments = joblib.load(exp_file)
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_archive_file = cached_path(archive_file, cache_dir=cache_dir, force_download=force_download, proxies=proxies, resume_download=resume_download, local_files_only=local_files_only)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
ratio1_left = torch.div(left_token_len1, (left_token_len1 + right_token_len1)).to(self.args.device)
ratio2_left = torch.div(left_token_len2, (left_token_len2 + right_token_len2)).to(self.args.device)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(os.path.dirname(file_path))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex.optimizers import FP16_Optimizer
from apex.optimizers import FusedAdam
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import sentencepiece as spm
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
zi = zipimporter(path)
pyx_data = zi.get_data(pyx_module_name)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
model.load_state_dict(model_for_loading)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
load_tf_weights(model, resolved_archive_file)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
logging.debug('Try to load dataset as bidimensional')
(train_ds, val_ds, test_ds) = bidimensional_dataset.load_dataset(dataset_folder)
(mean, std) = _load_mean_std_from_file(dataset_folder, inmem, workers, kwargs['runner_class'])
mean = np.divide((mean - train_ds.min_coords), np.subtract(train_ds.max_coords, train_ds.min_coords))
std = np.divide((std - train_ds.min_coords), np.subtract(train_ds.max_coords, train_ds.min_coords))
logging.debug('Setting up dataset transforms')
transform = transforms.Compose([transforms.ToTensor(), transforms.Normalize(mean=mean, std=std)])
train_ds.transform = transform
val_ds.transform = transform
test_ds.transform = transform
(train_loader, val_loader, test_loader) = _dataloaders_from_datasets(batch_size, train_ds, val_ds, test_ds, workers)
logging.info('Dataset loaded as bidimensional data')
_verify_dataset_integrity(dataset_folder, disable_dataset_integrity, enable_deep_dataset_integrity)
return (train_loader, val_loader, test_loader, len(train_ds.classes))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
sub_new = pattern.findall(sub)[0]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
next_item = next(sequence)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(_loss, sample_size, logging_output) = self.task.valid_step(sample, self.model, self.criterion)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
bypass = proxy_bypass(parsed.hostname)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
m.binarize()
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
r = rout['f2pyenhancements'].get(blockname)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from pandas import Series, DataFrame
types.append((Series, DataFrame))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return bpe.is_beginning_of_word(tok)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
from keras.models import load_model as load_model_keras
ret = get_model_meta_real(filename, load_model_keras)
from keras.models import Sequential
from keras.layers import Dense, Dropout, Activation, Flatten, Lambda
from keras.layers import Conv2D, MaxPooling2D
from keras.layers import LeakyReLU
from keras import regularizers
from keras import backend as K
print('Model imported using keras')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0
"
output = subprocess.check_output((self.compiler_f77 + find_lib_arg))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
int(s)
return True
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
colors = [random_color(rgb=True, maximum=1) for k in category_ids]
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_archive_file = cached_path(archive_file, cache_dir=None)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
c = child.out_channels
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from PIL import Image as ImagePIL
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs('results')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return ensure_str(self._metadata[name])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0
"
self.x_scaling_means = np.load((filename + '_x_means.npy'))
self.x_scaling_stds = np.load((filename + '_x_stds.npy'))
logger.debug('  Found input scaling information: means %s, stds %s', self.x_scaling_means, self.x_scaling_stds)
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return next(self.parameters()).device
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.removedirs(head)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
act = deepcopy(agents[0].act())
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.__lock._at_fork_reinit()
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
ret = func(*args[limit[0]:])
foundArity[0] = True
return ret
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
os.makedirs(log_dir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
dates.append(datetime(year, MONTH_NUMBERS[month], DAY_NUMBERS[day]))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
is_bidirectional = self._module.bidirectional
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with torch.autograd.profiler.record_function('reduce-grads'):
    self.optimizer.all_reduce_grads(self.model)
    if utils.has_parameters(self.criterion):
        self.optimizer.all_reduce_grads(self.criterion)
with torch.autograd.profiler.record_function('multiply-grads'):
    if (not self.cfg.optimization.use_bmuf):
        self.optimizer.multiply_grads((self.data_parallel_world_size / sample_size))
    elif (sample_size > 0):
        num = (self.data_parallel_world_size if self._sync_stats() else 1)
        self.optimizer.multiply_grads((num / sample_size))
with torch.autograd.profiler.record_function('clip-grads'):
    grad_norm = self.clip_grad_norm(self.cfg.optimization.clip_norm)
if (not self.tpu):
    if ((not self.cfg.optimization.use_bmuf) and (self.cfg.distributed_training.distributed_wrapper != 'SlowMo')):
        self._check_grad_norms(grad_norm)
    if (not torch.isfinite(grad_norm).all()):
        raise FloatingPointError('gradients are Nan/Inf')
with torch.autograd.profiler.record_function('optimizer'):
    self.task.optimizer_step(self.optimizer, model=self.model, update_num=self.get_num_updates())
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import pycuda
return True
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(('%s/start_scale=%d' % (dir2save, start_scale)))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from transformers.convert_gpt2_original_tf_checkpoint_to_pytorch import convert_gpt2_checkpoint_to_pytorch
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import cityscapesscripts.helpers.labels as CSLabels
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
idx = next(self.iter)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex import amp
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(d)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (pointer.shape == ip.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
line = next(self.random_file).strip()
if (line == ''):
    self.current_random_doc = (self.current_random_doc + 1)
    line = next(self.random_file).strip()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
component_names = set(stats_per_dir[dir]['cp_per_iter_per_component'])
plot_component_names = plot_component_names.intersection(component_names)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
for (_, _) in enumerate(data3):
    pass
assert False
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return importlib.import_module(name)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (model.tokens_embed.weight.shape == init_params[1].shape)
assert (model.positions_embed.weight.shape == init_params[0].shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from tensorboardX import SummaryWriter
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(self.next_input, self.next_target, _, _) = next(self.loader)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
pointer = getattr(pointer, l[0])
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return [self.protocol_parser[x] for x in filenames]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return arg.type().scalarType()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(result, tz_parsed) = tslib.array_to_datetime(data, errors=errors, utc=utc, dayfirst=dayfirst, yearfirst=yearfirst, require_iso8601=require_iso8601)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
pointer = getattr(pointer, scope_names[0])
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
masker = self.zeros_mask_dict[name]
if (is_forward or (not masker.mask_on_forward_only)):
    masker.mask_tensor(param)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
text_b = int(example.text_b)
tokens_b = text_b
if (len(tokens_a) > (max_seq_length - 2)):
    tokens_a = tokens_a[:(max_seq_length - 2)]
for (i, w) in enumerate(example.text_a.split()):
    if (i == text_b):
        text_b = (tokenizer.tokenize(w) if (i == 0) else tokenizer.tokenize((' ' + w)))
        break
    w_tok = (tokenizer.tokenize(w) if (i == 0) else tokenizer.tokenize((' ' + w)))
    if w_tok:
        tokens_b += (len(w_tok) - 1)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
module = importlib.import_module(submodule)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return accimage.Image(path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from test_forward import _get_detector_cfg
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return list(map(x_type, x))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
return len(body)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
assert (pointer.shape == array.shape), f'Pointer shape {pointer.shape} and array shape {array.shape} mismatched'
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
fn = float(fn)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
return arg.type().scalarType()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
del self.cache[key]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from habitat.datasets.vln.r2r_vln_dataset import VLNDatasetV1
has_r2r_vln = True
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_archive_file = cached_path(archive_file, cache_dir=cache_dir)
resolved_config_file = cached_path(config_file, cache_dir=cache_dir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
loc_t = self.get_transform().transform(tick.get_loc())
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex import amp
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
tokenizer = cls(*init_inputs, **init_kwargs)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (not valid_contextj(label, pos)):
    raise InvalidCodepointContext('Joiner {0} not allowed at position {1} in {2}'.format(_unot(cp_value), (pos + 1), repr(label)))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
import psutil
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (x_ == 0):
    return 0
return round(x_, (- math.floor(((math.log10(abs(x_)) - sigfigs) + 1))))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
value = int(raw_value)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
action = C.gesture_action_mapping[pose]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import re
import numpy as np
import tensorflow as tf
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.input_shape = self.x_orig.shape[1:]
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return mod.code
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import sentencepiece as spm
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(root, prob) = _back_track(track_by_layer, vocab, model, i, DEBUG)
if (root.depth() == max_depth):
    res.append(_back_track(track_by_layer, vocab, model, i, DEBUG))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if ('jieba' not in sys.modules):
    import jieba
else:
    jieba = sys.modules['jieba']
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
for (_idx, pr_idx) in enumerate(rec_thrs_insert_idx):
    pr_at_recall[_idx] = pr[pr_idx]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.parsing_model = DroidletSemanticParsingModel(opts.nsp_models_dir, opts.nsp_data_dir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with Image.open(img_path.as_posix()) as img:
    (width, height) = img.size
    exif_orientation = get_exif_orientation(img)
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_config_file = cached_path(config_file, cache_dir=cache_dir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return accimage.Image(path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return mod.code
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex import amp
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
prior_mean = [(float(t) / prior_mean_sum) for t in prior_mean]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1
"
import sentencepiece as spm
self.sp = spm.SentencePieceProcessor()
self.sp.Load(vocab)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
out = _minimal_ext_cmd(['git', 'rev-parse', 'HEAD'])
sha = out.strip().decode('ascii')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
args[j] = (eval(a) if isinstance(a, str) else a)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
attr = object.__getattr__(name)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
shutil.rmtree(os.path.join(_here, 'docs', '_build'))
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
indegree_map[child] -= 1
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
i = word.index(new_pair, i)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
shutil.rmtree(str(path_pred))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return (torch.cuda.is_available() and tensor.is_pinned())
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if self.args.trace_memory_line_by_line:
    trace = start_memory_tracing('transformers')
if self.args.is_tpu:
    raise NotImplementedError('Memory Benchmarking is currently not implemented for TPU. Please disable memory benchmarking with `--no_memory` or `args.no_memory=True`')
elif self.args.is_gpu:
    if (not is_py3nvml_available()):
        logger.warning(""py3nvml not installed, we won't log GPU memory usage. Install py3nvml (pip install py3nvml) to log information about GPU."")
        memory = 'N/A'
    else:
        logger.info('Measuring total GPU usage on GPU device. Make sure to not have additional processes running on the same GPU.')
        nvml.nvmlInit()
        func()
        handle = nvml.nvmlDeviceGetHandleByIndex(self.args.device_idx)
        meminfo = nvml.nvmlDeviceGetMemoryInfo(handle)
        max_bytes_in_use = meminfo.used
        memory = Memory(max_bytes_in_use)
        nvml.nvmlShutdown()
else:
    memory_bytes = measure_peak_memory_cpu(func)
    memory = (Memory(memory_bytes) if isinstance(memory_bytes, int) else memory_bytes)
if self.args.trace_memory_line_by_line:
    summary = stop_memory_tracing(trace)
else:
    summary = None
return (memory, summary)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
info = next((v for v in _concrete_typeinfo.values() if (v.type is obj)))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(root)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with tqdm.tqdm(unit='B', unit_scale=True, miniters=1, desc=filename) as t:
    (fpath, _) = urllib.request.urlretrieve(url, fpath, reporthook=hook(t))
statinfo = os.stat(fpath)
size = statinfo.st_size
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(q1, q2) = (0.3 * (1 - (2 * np.random.random(2))))
p1 = (0.2 * (1 - (2 * np.random.random())))
p2 = self.expr_2_lam(energy, q1, q2, p1)
result = True
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
image = PIL.Image.open(pathname)
image.load()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (pointer.shape == array.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
line_string = line.decode('utf-8')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0
"
(left, right) = split_path_inout(path, insideB)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
(_loss, sample_size, logging_output) = self.task.valid_step(sample, self.model, self.criterion)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.agent_host.parse(sys.argv)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.message = requests_exception.message
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
pointer = getattr(pointer, l[0])
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
tf_cuda_available = tf.test.is_gpu_available()
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
freeze_params(self.model.model.shared)
for d in [self.model.model.encoder, self.model.model.decoder]:
    freeze_params(d.embed_positions)
    freeze_params(d.embed_tokens)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import sentencepiece as spm
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
float(text)
return True
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
json.dumps(json)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
data.num_classes = (max(labels) + 1)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
out = _minimal_ext_cmd(['git', 'rev-parse', 'HEAD'])
sha = out.strip().decode('ascii')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(yield)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if self.args.trace_memory_line_by_line:
    trace = start_memory_tracing('transformers')
if self.args.is_tpu:
    raise NotImplementedError('Memory Benchmarking is currently not implemented for TPU. Please disable memory benchmarking with `--no-memory` or `args.memory=False`')
elif self.args.is_gpu:
    if (not is_py3nvml_available()):
        logger.warning(""py3nvml not installed, we won't log GPU memory usage. Install py3nvml (pip install py3nvml) to log information about GPU."")
        memory = 'N/A'
    else:
        logger.info('Measuring total GPU usage on GPU device. Make sure to not have additional processes running on the same GPU.')
        nvml.nvmlInit()
        func()
        handle = nvml.nvmlDeviceGetHandleByIndex(self.args.device_idx)
        meminfo = nvml.nvmlDeviceGetMemoryInfo(handle)
        max_bytes_in_use = meminfo.used
        memory = Memory(max_bytes_in_use)
        nvml.nvmlShutdown()
else:
    memory_bytes = measure_peak_memory_cpu(func)
    memory = (Memory(memory_bytes) if isinstance(memory_bytes, int) else memory_bytes)
if self.args.trace_memory_line_by_line:
    summary = stop_memory_tracing(trace)
else:
    summary = None
return (memory, summary)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(('%s/start_scale=%d' % (dir2save, start_scale)))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
text_a = line[q1_index]
text_b = line[q2_index]
label = line[5]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
scheme_path = scheme_paths[scheme_key]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.exprs = list(exprs)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
import zipfile
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
time.sleep(0.5)
sd.play(audio_data[start_ms:end_ms], blocking=True)
sd.stop()
user_input = input()
audio_count = int(user_input)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
return l.index(index)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
return list(map(type, x))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
del it[1]
del it[1:2]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
return list(map(type, x))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
response = raw_input(query)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return int(x)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
repo_dpath = dirname(dirname(__file__))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
pan_format = np.array(Image.open(os.path.join(segmentations_folder, annotation['file_name'])), dtype=np.uint32)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
word_list = voc[0][1].base_field.vocab.itos
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
axes_class = ax._axes_class
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if isinstance(tensor, (tuple, list)):
    return type(tensor)((distributed_concat(t, num_total_examples) for t in tensor))
output_tensors = [tensor.clone() for _ in range(dist.get_world_size())]
dist.all_gather(output_tensors, tensor)
output_tensors = [(t if (len(t.shape) > 0) else t[None]) for t in output_tensors]
concat = torch.cat(output_tensors, dim=0)
if (num_total_examples is not None):
    concat = concat[:num_total_examples]
return concat
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex.parallel import DistributedDataParallel as DDP
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
item = tree_data[start_at]
if (item and (item[2] == name) and (S_ISDIR(item[1]) == is_dir)):
    tree_data[start_at] = None
    return item
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
p.start()
searched = False
new_graph = None
new_father_id = None
if (not self.training_queue):
    searched = True
    while (new_father_id is None):
        remaining_time = (timeout - (time.time() - start_time))
        (new_graph, new_father_id) = self.bo.optimize_acq(self.search_tree.adj_list.keys(), self.descriptors, remaining_time)
    new_model_id = self.model_count
    self.model_count += 1
    self.training_queue.append((new_graph, new_father_id, new_model_id))
    self.descriptors.append(new_graph.extract_descriptor())
remaining_time = (timeout - (time.time() - start_time))
if (remaining_time <= 0):
    raise TimeoutError
(metric_value, loss, graph) = q.get(timeout=remaining_time)
if (self.verbose and searched):
    verbose_print(new_father_id, new_graph)
self.add_model(metric_value, loss, graph, model_id)
self.search_tree.add_child(father_id, model_id)
self.bo.fit(self.x_queue, self.y_queue)
self.x_queue = []
self.y_queue = []
pickle_to_file(self, os.path.join(self.path, 'searcher'))
self.export_json(os.path.join(self.path, 'history.json'))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0
"
assert (p_i.shape == arr_i.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
result = getgrnam(name)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
class_names = MetadataCatalog.get(names[0]).thing_classes
check_metadata_consistency('thing_classes', names)
print_instances_class_histogram(dataset_dicts, class_names)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
int(string)
return True
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
self.top_beam_finished = self.top_beam_finished.bool()
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
for item in maybe_tensor:
    extract_tensors(item, tensor_list)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
self._dataset_size = len(self._source)
_ = self._source[0]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
start_method = multiprocessing.get_start_method()
multiprocessing.set_start_method('spawn', force=True)
pool = multiprocessing.Pool(len(gpus))
results = pool.map(func, settings, chunksize=1)
multiprocessing.set_start_method(start_method, force=True)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.sent_tok = nltk.data.load(st_path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
regex = '(?i)\\b((?:https?://|www\\d{0,3}[.]|[a-z0-9.\\-]+[.][a-z]{2,4}/)(?:[^\\s()<>]+|\\(([^\\s()<>]+|(\\([^\\s()<>]+\\)))*\\))+(?:\\(([^\\s()<>]+|(\\([^\\s()<>]+\\)))*\\)|[^\\s`!()\\[\\]{};:\'\\"".,<>?«»“”‘’]))'
url = re.findall(regex, string)
return [x[0] for x in url]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (is_bool_dtype(values) or is_bool_dtype(dtype)):
    return (np.asarray(values).astype('uint64'), np.dtype('bool'))
elif (is_signed_integer_dtype(values) or is_signed_integer_dtype(dtype)):
    return (ensure_int64(values), np.dtype('int64'))
elif (is_unsigned_integer_dtype(values) or is_unsigned_integer_dtype(dtype)):
    return (ensure_uint64(values), np.dtype('uint64'))
elif (is_float_dtype(values) or is_float_dtype(dtype)):
    return (ensure_float64(values), np.dtype('float64'))
elif (is_complex_dtype(values) or is_complex_dtype(dtype)):
    with catch_warnings():
        simplefilter('ignore', np.ComplexWarning)
        values = ensure_float64(values)
    return (values, np.dtype('float64'))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0
"
from parlai.core.torch_agent import TorchAgent
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
scores = [x['score'] for x in sinfo]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
output_label.append(tokenizer.vocab[token])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import psutil
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if os.path.exists(file):
    os.remove(file)
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import imp
(stream, path, descr) = imp.find_module('site', [item])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
batch = next(dataloader_iter)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
batch_size = source_tokens['bert'].shape[0]
num_seq = source_tokens['bert'].shape[1]
max_len = source_tokens['bert'].shape[2]
source_tokens['bert'] = source_tokens['bert'].reshape((batch_size * num_seq), (- 1))
if self.training:
    return self._source_embedder(source_tokens).reshape(batch_size, num_seq, max_len, (- 1))
else:
    bert_embeddings = []
    for i in range(0, source_tokens['bert'].shape[0], (10 * batch_size)):
        if (((i + 10) * batch_size) <= source_tokens['bert'].shape[0]):
            bert_embeddings.append(self._source_embedder({'bert': source_tokens['bert'][(batch_size * i):(batch_size * (i + 10)), :]}))
        else:
            bert_embeddings.append(self._source_embedder({'bert': source_tokens['bert'][(batch_size * i):, :]}))
    return torch.cat(bert_embeddings, 0).reshape(batch_size, num_seq, max_len, (- 1))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
transpose = a.transpose
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
s = socket.socket()
s.connect((host, port))
break
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
local_part.value.encode('ascii')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0
"
from py2exe.distutils_buildexe import py2exe as _py2exe
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
nn.utils.clip_grad_norm_(model.parameters(), 1.0)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
prog = os.path.basename(sys.argv[0])
if (prog in ('__main__.py', '-c')):
    return ('%s -m pip' % sys.executable)
else:
    return prog
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
assert (pointer.shape == array.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
optimizer_class = utils.check_or_get_class(optimizer_type, optimizer_modules, Optimizer)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
equations = pysr(derivatives, dynamics, annealing=True, niterations=args.niterations, binary_operators=ops, unary_operators=[], batching=True, populations=20, npop=4000, variable_names=feature_names)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return bpe.is_beginning_of_word(tok)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
r_xz = batch_data['r_xz'].to(self.device, self.dtype, non_blocking=True)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
version = getattr(self, 'version', None)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
meth = getattr(visitor, visit_attr)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
c_index = metrics.c_index(y_true_T, y_true_E, y_pred_risk)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
keys = [f for f in listdir(expPath) if (not isfile(join(expPath, f)))]
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with utils.maybe_no_grad(eval):
    (loss, sample_size, logging_output_) = self.criterion(self.model, sample)
    logging_output.update(logging_output_)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
history = self.train_loop(**merge_dict(self.config, trn_data=trn_data, dev_data=dev_data, epochs=epochs, num_examples=num_examples, train_steps_per_epoch=train_steps_per_epoch, dev_steps=dev_steps, callbacks=callbacks, logger=logger, model=model, optimizer=optimizer, loss=loss, metrics=metrics, overwrite=True))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return self.nodes[index]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
e = self.controller.step(action='TeleportFull', x=pose['x'], y=pose['y'], z=pose['z'], rotation=rotation, horizon=horizon, agentId=agent_id, **self._extra_teleport_kwargs)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
row = g.next()
if (row[index] == tomatch):
    rows.append(row)
else:
    return (pd.DataFrame(rows, columns=header), row)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return self._re_word_tokenizer
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import apex
apex.amp.register_half_function(torch, 'einsum')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
f_iter = iter(f)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
return [self.protocol_parser[x] for x in filenames]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return getattr(sys.modules[mod_str], class_str)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
int(s)
return True
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
import pyarrow.plasma as plasma
self._plasma = plasma
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
regime[int(k)] = rr[k]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
from apex.parallel import DistributedDataParallel as DDP
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import unidic_lite
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert_warns(RuntimeWarning, np.divide, 1, np.zeros(1))
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import sentencepiece as spm
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return next(self.loader)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(save_dir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import ftfy
import spacy
self.nlp = spacy.load('en', disable=['parser', 'tagger', 'ner', 'textcat'])
self.fix_text = ftfy.fix_text
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (not package):
    module = import_module(name)
else:
    module = import_module(('.' + name), package=package)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with open(petdni_filename, 'rb') as f:
    petdni_data = pkl.load(f)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if isinstance(expected, tuple):
    self.assertLen(actual, len(expected))
    for (expected_item, actual_item) in zip(expected, actual):
        self.assertIndexExpressionEqual(expected_item, actual_item)
elif isinstance(expected, (list, np.ndarray)):
    np.testing.assert_array_equal(expected, actual)
else:
    self.assertEqual(expected, actual)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
uttid = readString(f)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
if isinstance(idx[0], list):
    return [self.label_enc.inverse_transform(filter_idxs(_idx)).tolist() for _idx in idx]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
p = s_p[rand]
o = s_g[rand]
print(('Original:' + o))
try:
    print(('Predicted:' + p))
except UnicodeEncodeError:
    print('Predicted: '.format(p))
print('-------------------------------------------')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
v_ = _to_array_with_correct_type(v)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
return torch.load(args.resume)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex import amp
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return self.get_all_ckpts()[(- 1)]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from espnet2.bin.asr_inference import Speech2Text
from espnet_model_zoo.downloader import ModelDownloader
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
model.config.use_cache = False
input_features = inputs['input_features']
attention_mask = inputs['attention_mask']
decoder_input_ids = inputs['decoder_input_ids']
decoder_attention_mask = inputs['decoder_attention_mask']
traced_model = torch.jit.trace(model, (input_features, attention_mask, decoder_input_ids, decoder_attention_mask))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_archive_file = cached_path(archive_file, cache_dir=cache_dir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
try:
    from six.moves.urllib.error import HTTPError, URLError
    from six.moves.urllib.request import urlretrieve
    urlretrieve(url, full_path, reporthook=download_progress_hook)
except HTTPError as exception:
    raise Exception(error_msg.format(url, exception.code, exception.msg))
except URLError as exception:
    raise Exception(error_msg.format(url, exception.errno, exception.reason))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from .convert_xlnet_checkpoint_to_pytorch import convert_xlnet_checkpoint_to_pytorch
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
data = next(self.iter_loader)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
checkpoint = torch.load(fpath, map_location=map_location)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0
"
torch_type = x.type()
return (torch_type.endswith('FloatTensor') or torch_type.endswith('HalfTensor') or torch_type.endswith('DoubleTensor'))
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import apex.fp16_utils
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import re
import numpy as np
import tensorflow as tf
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with Timer('solve_simrd') as timer_solve:
    callback(rt)
    assert ((rt.clock - 1) >= base_compute)
    assert np.isclose((rt.clock - 1), (rt.telemetry.summary['model_compute'] + rt.telemetry.summary['remat_compute']))
    feasible = True
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with FileLockedTinyDB(abs_logdir) as db:
    query = db.query()
    item = db.get((query.queued == True))
    if (item is not None):
        item['queued'] = False
        db.write_back([item])
    del db
    time.sleep(0.2)
_success = True
if (item is None):
    print(f'@ manager.subprocess : no job left.')
    exit()
else:
    args = item['arg']
    process_id = (eval(multiprocessing.current_process().name.split('-')[(- 1)]) - 1)
    device = devices[(process_id % len(devices))]
    print(f'@ manager.subprocess : initializing process with PID = {os.getpid()}, process id: {process_id}, allocated device: {device}, args= {args}')
    if ('cuda' in device):
        device_id = device.split(':')[(- 1)]
        if (os.name == 'nt'):
            command = f'set CUDA_VISIBLE_DEVICES={device_id} & python {opt.script} {args}'
        else:
            command = f'CUDA_VISIBLE_DEVICES={device_id} python {opt.script} {args}'
    else:
        command = f'python {opt.script} {args}'
    try:
        os.system(command)
    except:
        print(f'Command `{command}` failed.')
    print(f'''@ manager.subprocess [id={process_id}, pid={_pid}] : experiment completed. Arguments = 
{args}

''')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex.normalization import FusedLayerNorm
return FusedLayerNorm(normalized_shape, eps, elementwise_affine)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
dets = np.row_stack((dets, det_accu))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
mode = int(arg, 2)
return mode
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
cocoDt = cocoGt.loadRes(result_files[res_type])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(t_xyz, b_xyz) = self.homography_func(t, b)
(t_uv, b_uv) = (self._project_points(t_xyz), self._project_points(b_xyz))
t_uv = t_uv[:, torch.argsort(t_uv[0, :, 0]), :]
b_uv = b_uv[:, torch.argsort(b_uv[0, :, 0]), :]
aligned_corners = torch.cat([t_uv, b_uv], dim=1).squeeze(0)
aligned.append(aligned_corners)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
change_energies = env.pose_difference_energy(ips, cps)
change_energy = change_energies.sum()
changeds = (change_energies > 0.0)
metrics['change_energy'] = change_energy
metrics['num_changed'] = changeds.sum()
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
na = len(axes_a)
axes_a = list(axes_a)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
(l, V) = numpy.linalg.eig(M33)
i = numpy.where((abs((numpy.real(l) - factor)) < 1e-08))[0][0]
direction = numpy.real(V[:, i]).squeeze()
direction /= vector_norm(direction)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import instaboostfast as instaboost
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
text_a = line[1]
text_b = line[2]
label = line[3]
examples.append(InputExample(guid=guid, text_a=text_a, text_b=text_b, label=label))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
while True:
    time.sleep(10)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(text, idxs) = opinion['Target']
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
index = self._next_index()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
rc = subprocess.check_call([s, '--version'], stdout=sink, stderr=sink)
if (rc == 0):
    self.gpg = s
    break
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
modcode = ''
for m in itertools.chain(modnames, optional_modnames):
    try:
        with warnings.catch_warnings():
            try:
                from gi import PyGIDeprecationWarning, PyGIWarning
                warnings.simplefilter('ignore', PyGIDeprecationWarning)
                warnings.simplefilter('ignore', PyGIWarning)
            except Exception:
                pass
            __import__(m)
            modcode += _gi_build_stub(sys.modules[m])
    except ImportError:
        if (m not in optional_modnames):
            raise
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
decoder = getattr(core, (decoder_name + '_decoder'))
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
metric_value = self.metric(y_true, y_pred)
if plot:
    metric_value_dict = {self.metric.__name__: metric_value}
    residuals = (y_pred - y_true)
    for some_metric in all_metrics:
        if (some_metric.metric.__name__ == self.metric.__name__):
            continue
        calculate_metric = True
        if (is_training_set and no_concordance_index):
            if (some_metric.metric.__name__ == 'concordance_index'):
                continue
        elif (some_metric.metric.__name__ in {'concordance_index', 'r2_score'}):
            calculate_metric = (sum((y_true[0] != y_true)) >= 1)
        if calculate_metric:
            some_metric_value = some_metric.compute_singletask_metric(original_y_true, original_y_pred, w, plot=False)
        else:
            some_metric_value = np.nan
        metric_value_dict[some_metric.metric.__name__] = some_metric_value
    plt.plot(y_pred, y_true, 'b.')
    y_vector = np.append(y_true, y_pred)
    min_value = np.amin(y_vector)
    max_value = np.amax(y_vector)
    plt.plot([(min_value - 1), (max_value + 1)], [(min_value - 1), (max_value + 1)], 'k')
    plt.xlabel('Predicted value')
    plt.ylabel('True value')
    i = 0
    for some_metric in all_metrics:
        if (some_metric.metric.__name__ in metric_value_dict):
            plt.text((min_value - 1), ((max_value + 0.4) + (0.7 * i)), ('%s=%f, ' % (some_metric.metric.__name__, metric_value_dict[some_metric.metric.__name__])))
            i += 1
    plot_time = strftime('%Y_%m_%d_%H_%M_%S', gmtime())
    if is_training_set:
        task_name = (task_name + '_trainset')
    else:
        np.save('plots/y_pred', y_pred)
        np.save('plots/y_true', y_true)
        np.save('plots/residuals', residuals)
    if (model_name is not None):
        task_name = ((model_name + '_') + task_name)
    image_name = ((('plots/' + task_name) + plot_time) + '.png')
    plt.savefig(image_name)
    plt.close()
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
with open(conf_path) as config_file:
    agent.config = json.load(config_file)['agent']
agent.reset()
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
model.correct_sent_indexing(model, sent)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
ret = func(*args[limit[0]:])
foundArity[0] = True
return ret
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
return self.known_modules[fullname]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
tokenizer = MecabTokenizer(mecab_dic='unidic_lite')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import numpy as np
import tensorflow as tf
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
checkpoint_suffix = args.model_name_or_path.split('-')[(- 1)].split('/')[0]
global_step = int(checkpoint_suffix)
epochs_trained = (global_step // (len(train_dataloader) // args.gradient_accumulation_steps))
steps_trained_in_current_epoch = (global_step % (len(train_dataloader) // args.gradient_accumulation_steps))
logger.info('  Continuing training from checkpoint, will skip to saved global_step')
logger.info('  Continuing training from epoch %d', epochs_trained)
logger.info('  Continuing training from global step %d', global_step)
logger.info('  Will skip the first %d steps in the first epoch', steps_trained_in_current_epoch)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
blob_name = blob.name
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
sent_emb.append(self.vocab[w])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
patients[number]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from test_forward import _get_detector_cfg
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
batch = next(iterator)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
logger.handlers[1].stream.close()
logger.removeHandler(logger.handlers[1])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
del params[arg_name]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
torch.testing.assert_allclose(ref_loss, shard_loss)
assert objects_are_equal(ref_state_dict, shard_state_dict, raise_exception=True)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
grad_norm = grad_norm.item()
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from fairseq.data.token_block_utils_fast import _get_slice_indices_fast, _get_block_to_dataset_index_fast
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (optimizer is not None):
    optimizer.load_state_dict(state_dict['optimizer'])
if (lr_scheduler is not None):
    lr_scheduler.load_state_dict(state_dict['lr_scheduler'])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
global_step = int(args.model_name_or_path.split('-')[(- 1)].split('/')[0])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
from cvxpy.error import DQCPError
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
data = memoryview(binascii.a2b_base64(key_body))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
u = getattr(self.module, (self.name + '_u'))
v = getattr(self.module, (self.name + '_v'))
w = getattr(self.module, (self.name + '_bar'))
return True
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
mask_color = [(x / 255) for x in self.metadata.stuff_colors[category_idx]]
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
temp.add(word)
(yield (word, float(rt)))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
if (self.tpu and (self.data_parallel_world_size > 1)):
    import torch_xla.core.xla_model as xm
    gradients = xm._fetch_gradients(self.optimizer.optimizer)
    xm.all_reduce('sum', gradients, scale=(1.0 / self.data_parallel_world_size))
with torch.autograd.profiler.record_function('multiply-grads'):
    if (not self.args.use_bmuf):
        self.optimizer[0].multiply_grads((self.data_parallel_world_size / sample_size))
    elif (sample_size > 0):
        num = (self.data_parallel_world_size if self._sync_stats() else 1)
        self.optimizer.multiply_grads((num / sample_size))
with torch.autograd.profiler.record_function('clip-grads'):
    grad_norm = self.clip_grad_norm(self.args.clip_norm)
if ((not self.args.use_bmuf) and (self.args.distributed_wrapper != 'SlowMo') and (not self.tpu)):
    self._check_grad_norms(grad_norm)
with torch.autograd.profiler.record_function('optimizer'):
    self.optimizer[0].step()
    self.zero_grad()
    self.optimizer[2].backward2(l4, retain_graph=True, scaler=za)
    del l4
    self.optimizer[2].multiply_grads((self.data_parallel_world_size / sample_size))
    grad_norm = self.clip_grad_norm(self.args.clip_norm)
    self.optimizer[2].step()
    for p in self.model.disc2.parameters():
        p.data.clamp_((- 0.1), 0.1)
    self.zero_grad()
    self.optimizer[1].backward2(l3, scaler=za)
    del l3
    self.optimizer[1].multiply_grads((self.data_parallel_world_size / sample_size))
    grad_norm = self.clip_grad_norm(self.args.clip_norm)
    self.optimizer[1].step()
    for p in self.model.disc1.parameters():
        p.data.clamp_((- 0.1), 0.1)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from torchvision import _C as C
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return (mo.group(1), mo.group(2), mo.group(3))
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
loaded_model = torch.jit.load('traced_model.pt')
os.remove('traced_model.pt')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
assert_header_parsing(httplib_response.msg)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
model = model_func(weights=weights, **kwargs)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
assigned = stmt.getitem(index_node, context)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
cython_mintaps = numpy.asarray(self.mintaps, dtype='int32')
cython_tap_array_len = numpy.asarray([len(x) for x in self.tap_array], dtype='int32')
if (len(self.tap_array) == 0):
    d1 = 0
else:
    d1 = numpy.max(cython_tap_array_len)
d0 = len(self.tap_array)
cython_tap_array = numpy.zeros((d0, d1), dtype='int32')
for _d0 in xrange(d0):
    for _d1 in xrange(cython_tap_array_len[_d0]):
        cython_tap_array[(_d0, _d1)] = self.tap_array[_d0][_d1]
cython_mit_mot_out_nslices = numpy.asarray([len(x) for x in self.mit_mot_out_slices], dtype='int32')
if (len(self.mit_mot_out_slices) == 0):
    d1 = 0
else:
    d1 = numpy.max(cython_mit_mot_out_nslices)
d0 = len(self.mit_mot_out_slices)
cython_mit_mot_out_slices = numpy.zeros((d0, d1), dtype='int32')
for _d0 in xrange(d0):
    for _d1 in xrange(cython_mit_mot_out_nslices[_d0]):
        cython_mit_mot_out_slices[(_d0, _d1)] = self.mit_mot_out_slices[_d0][_d1]
cython_vector_seqs = numpy.asarray(self.vector_seqs, dtype='int32')
cython_vector_outs = numpy.asarray(self.vector_outs, dtype='int32')
cython_mitmots_preallocated = numpy.asarray(self.mitmots_preallocated, dtype='int32')
cython_inps_is_tensor = numpy.asarray(self.inps_is_tensor, dtype='int32')
cython_outs_is_tensor = numpy.asarray(self.outs_is_tensor, dtype='int32')
if hasattr(self, 'destroy_map'):
    cython_destroy_map = [(x in self.destroy_map) for x in xrange(len(node.outputs))]
else:
    cython_destroy_map = [0 for x in xrange(len(node.outputs))]
cython_destroy_map = numpy.asarray(cython_destroy_map, dtype='int32')
from . import scan_perform_ext
p = (lambda node, args, outs: scan_perform_ext.perform(self.n_shared_outs, self.n_mit_mot_outs, self.n_seqs, self.n_mit_mot, self.n_mit_sot, self.n_sit_sot, self.n_nit_sot, args[0], self.as_while, cython_mintaps, cython_tap_array, cython_tap_array_len, cython_vector_seqs, cython_vector_outs, cython_mit_mot_out_slices, cython_mit_mot_out_nslices, cython_mitmots_preallocated, cython_inps_is_tensor, cython_outs_is_tensor, self.fn.fn, self.fn, cython_destroy_map, args, outs, self, node))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
nn.utils.remove_weight_norm(module)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
assert (pointer.shape == array.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.populate_requirement_set(requirement_set, args, options, finder, session, self.name, wheel_cache)
preparer = RequirementPreparer(build_dir=directory.path, src_dir=options.src_dir, download_dir=None, wheel_download_dir=None, progress_bar=options.progress_bar, build_isolation=options.build_isolation)
resolver = Resolver(preparer=preparer, finder=finder, session=session, wheel_cache=wheel_cache, use_user_site=options.use_user_site, upgrade_strategy=upgrade_strategy, force_reinstall=options.force_reinstall, ignore_dependencies=options.ignore_dependencies, ignore_requires_python=options.ignore_requires_python, ignore_installed=options.ignore_installed, isolated=options.isolated_mode)
resolver.resolve(requirement_set)
if (wheel and options.cache_dir):
    wb = WheelBuilder(finder, preparer, wheel_cache, build_options=[], global_options=[])
    wb.build(requirement_set.requirements.values(), session=session, autobuilding=True)
to_install = resolver.get_installation_order(requirement_set)
should_warn_about_conflicts = ((not options.ignore_dependencies) and options.warn_about_conflicts)
if should_warn_about_conflicts:
    self._warn_about_conflicts(to_install)
warn_script_location = options.warn_script_location
if options.target_dir:
    warn_script_location = False
installed = install_given_reqs(to_install, install_options, global_options, root=options.root_path, home=target_temp_dir.path, prefix=options.prefix_path, pycompile=options.compile, warn_script_location=warn_script_location, use_user_site=options.use_user_site)
possible_lib_locations = get_lib_location_guesses(user=options.use_user_site, home=target_temp_dir.path, root=options.root_path, prefix=options.prefix_path, isolated=options.isolated_mode)
reqs = sorted(installed, key=operator.attrgetter('name'))
items = []
for req in reqs:
    item = req.name
    try:
        installed_version = get_installed_version(req.name, possible_lib_locations)
        if installed_version:
            item += ('-' + installed_version)
    except Exception:
        pass
    items.append(item)
installed = ' '.join(items)
if installed:
    logger.info('Successfully installed %s', installed)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
print('\nTerminated because of:', failure_word)
os.killpg(os.getpgid(process.pid), signal.SIGTERM)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
read = open(path).readlines()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0
"
return self.idxToLabel[idx]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
start = time.perf_counter()
retval = next(iterator)
t = (time.perf_counter() - start)
self.register({name: t}, not_increment_count=True)
(yield retval)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
s.bind(('127.0.0.1', port))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
delattr(obj.__class__, self.name)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
v = eval(initexpr, {}, params)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0
"
data_time = storage.history('data_time').avg(20)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from fairseq.modules.lightconv_layer import LightconvLayer
return LightconvLayer(input_size, kernel_size=kernel_size, padding_l=padding_l, num_heads=num_heads, weight_dropout=weight_dropout, weight_softmax=weight_softmax, bias=bias)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
offset = nti(buf[pos:(pos + 12)])
numbytes = nti(buf[(pos + 12):(pos + 24)])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
tp_name = t.field('tp_name').string()
tp_flags = int(t.field('tp_flags'))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from fairscale.nn import Pipe
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import sudachipy
import sudachidict_core
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return core.createProfile(colorSpace, colorTemp)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0
"
writer = code.globalstate['numeric_typedefs']
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return self[key]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(src_idx, tgt_idx) = align.split('-')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
(correct_title, correct_passage) = [normalize_answer(a) for a in labels[0].split(TOKEN_KNOWLEDGE)]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
self.agent.save(fn)
self._save_train_stats(suffix)
teacher_agent = self.return_teacher_agent()
if teacher_agent:
    teacher_fn = (fn + '.teacher')
    teacher_agent.save(teacher_fn)
break
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
response = requests.head(url, allow_redirects=True, proxies=proxies, timeout=etag_timeout)
if (response.status_code != 200):
    etag = None
else:
    etag = response.headers.get('ETag')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
for _m in value:
    _strict_call(_m)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
return datetime.strptime(t[0], fmt)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
return values.astype(dtype, casting='safe', copy=copy)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
d = diag(c)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
data = next(dl_itr)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
lines = [int(num) for line in qtables.splitlines() for num in line.split('#', 1)[0].split()]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
img = Image.open(framename).convert('RGB')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
compile(text, filename, 'exec')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0
"
from .convert_gpt2_checkpoint_to_pytorch import convert_gpt2_checkpoint_to_pytorch
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
try:
    response_act = w.acts[(- 1)]
    prediction = response_act['text']
except KeyError:
    continue
if opt['gold_response']:
    prediction = w.acts[0]['eval_labels'][0]
    response_act = {'text': prediction}
word_statistics['context_list'].append(w.acts[0]['text'])
word_statistics['pure_pred_list'].append(prediction)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if isinstance(value, Variable):
    raise TypeError('Shared variable constructor needs numeric values and not symbolic variables.')
for ctor in reversed(shared.constructors):
    try:
        var = ctor(value, name=name, strict=strict, allow_downcast=allow_downcast, **kwargs)
        utils.add_tag_trace(var)
        return var
    except TypeError:
        continue
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (positions > end):
    raise TypeError
self.positions = tuple(range(positions, (end + 1)))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
subprocess.call(['g++', '-std=c++11', '-O2', ('-DL=%d' % args.input_width), ('-DNCONF=%d' % args.n_train), 'src/wolff.cpp'])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return object.__getattribute__(self, key)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(j, bpe_tok) = next(bpe_toks)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(w, V) = numpy.linalg.eig(M33)
i = numpy.where((abs((numpy.real(w) - factor)) < 1e-08))[0][0]
direction = numpy.real(V[:, i]).squeeze()
direction /= vector_norm(direction)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return accimage.Image(path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return super().find_class(module, name)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
testResult = bake._check_source_code(config, options)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0
"
import re
import numpy as np
import tensorflow as tf
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from detectron2 import _C
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
result = self._font[texname]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
cocoDt = cocoGt.loadRes(result_files[metric])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
input_iter = iter(inputs)
return inputs
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
from apex.parallel import DistributedDataParallel as DDP
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
random_crop_and_resize_op = c_vision.RandomResizedCrop((256, 512), (1, 1), (1, 0.5))
data = data.map(operations=decode_op, input_columns=['image'])
data = data.map(operations=random_crop_and_resize_op, input_columns=['image'])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
train_lm_dataloder = processor.get_dataloader('train', configs.train_batch_size)
dev_lm_dataloader = processor.get_dataloader('dev', configs.train_batch_size)
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import sentencepiece as spm
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with open((all_params['grads_ping_file'] + str(k)), 'r') as f:
    pass
with open((all_params['sent_grads_file'] + str(k)), 'rb') as f:
    all_msg[str(k)] = pickle.load(f)
if (not all_params['debug']):
    os.remove((all_params['grads_ping_file'] + str(k)))
    os.remove((all_params['sent_grads_file'] + str(k)))
found_grads.append(k)
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
kwargs['basic_align'] = cfg.DATASET.BASIC_ALIGN
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (pointer.shape == array.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import builtins
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with open(path, 'r') as f:
    return json.load(f)
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return int(val)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
(left, right) = split_path_inout(path, insideB)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
o = func(server_model, *args, **kwargs)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return colnamemaps[table][name]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
ws.RunNetOnce(predict_net)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex.parallel import DistributedDataParallel as DDP
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return dtype_to_str[type(key)]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with wave.open(fullpath) as f:
    n_channels = f.getnchannels()
    width = f.getsampwidth()
    rate = f.getframerate()
    snippet = AudioSnippet(f.readframes(16000))
for (i, e) in enumerate(snippet.generate_contrastive()):
    gen_name = os.path.join(directory, 'gen-{}-{}'.format(i, filename))
    e.save(gen_name)
print('Generated from {}'.format(filename))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import apex
apex.amp.register_half_function(torch, 'einsum')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.cap = cv2.VideoCapture(int(input_video))
self.webcam = True
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
new_data = to_datetime(new_data, errors='raise', unit=date_unit)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0
"
resolved_vocab_file = cached_path(vocab_file, cache_dir=cache_dir)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return '{:.2f}'.format(math.pow(2, loss))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
loss = model(random_input).sum()
loss.backward()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return CudaRepository._avaliable_devices.pop()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(os.path.expanduser(os.path.normpath(path)))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with PathManager.open(subset_path, 'r') as f:
    subset = f.read().split('\n')
    subset_ids = [class2idx[name] for name in subset if (class2idx.get(name) is not None)]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import instaboostfast as instaboost
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return int(arg)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
return _np.fromfile(stream, self.dtype(byte_order), 1)[0]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
value = os.environ[key]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex import amp
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import palaas
from fairseq.fb_tbmf_wrapper import fb_tbmf_wrapper
bar = fb_tbmf_wrapper(bar, args, args.log_interval)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return super().__getattr__(name)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
pre = self.concept[pre]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
w = np.random.randint(0, ((W - target_wh) + 1))
h = np.random.randint(0, ((H - target_wh) + 1))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
if (int(os.environ.get('KDE_SESSION_VERSION', '3')) >= 4):
    return 'KDE4'
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
(l, w, c) = img.shape
for i in range(c):
    img[:, :, i] = np.reshape(fmat[0:, i], (l, w))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
return int(v)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0
"
line += next(lines)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
ctype = f2cmap[var['kindselector']['kind']]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return bpe.is_beginning_of_word(tok)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
j = word.index(first, i)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
sample[k] = ds.collater([s[k] for s in samples])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return bpe.is_beginning_of_word(tok)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
dist_angle_set[index, :4, :total_len, :total_len] = np.array(info['dist_angle_mat'])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
tensor_size = node_cpp.type().sizes()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from fairseq.modules.dynamicconv_layer import DynamicconvLayer
return DynamicconvLayer(input_size, kernel_size=kernel_size, padding_l=padding_l, num_heads=num_heads, weight_dropout=weight_dropout, weight_softmax=weight_softmax, bias=bias)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
iter(size)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
assert (pointer.shape == array.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
t = cls._backend.__dict__[cls.__name__]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
args.lstm_delay = ParseLstmDelayString(args.lstm_delay.strip())
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
checkpoint_suffix = args.model_name_or_path.split('-')[(- 1)].split('/')[0]
global_step = int(checkpoint_suffix)
epochs_trained = (global_step // (len(train_dataloader) // args.gradient_accumulation_steps))
steps_trained_in_current_epoch = (global_step % (len(train_dataloader) // args.gradient_accumulation_steps))
logger.info('  Continuing training from checkpoint, will skip to saved global_step')
logger.info('  Continuing training from epoch %d', epochs_trained)
logger.info('  Continuing training from global step %d', global_step)
logger.info('  Will skip the first %d steps in the first epoch', steps_trained_in_current_epoch)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
import tensorflow as tf
import torch
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if ((not self.maker.mode.check_c_code) or debug):
    raise utils.MethodNotDefined()
if (not isinstance(node.op, gof.op.Op)):
    raise utils.MethodNotDefined()
thunk = node.op.make_c_thunk(node, storage_map, compute_map, no_recycling)
thunks_c.append(thunk)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
model.measure.set_v_c_reg_mapping(state_dict['v_c_reg_mapping'])
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import numexpr as ne
visualized_image = ne.evaluate('img * (1 - alpha / 255.0) + rgb * (alpha / 255.0)')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return self._spec.children[element_name]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
text = line.strip()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
free_energy = db_entry['free_energy']
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return self.generator(z, self.generator.module.shared(y))
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
for _ in tqdm(tasks.result(), total=n_scenes):
    pass
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
evaluator = cls.build_evaluator(cfg, dataset_name)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.pool.put(conn, block=False)
return
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (self.args.is_tpu or self.args.torchscript):
    logger.info('Do inference on TPU or torchscript. Running model 5 times to stabilize compilation')
    timeit.repeat(func, repeat=1, number=5)
runtimes = timeit.repeat(func, repeat=self.args.repeat, number=10)
if (self.args.is_tpu and self.args.torch_xla_tpu_print_metrics):
    import torch_xla.debug.metrics as met
    self.print_fn(met.metrics_report())
return (min(runtimes) / 10.0)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex.parallel import DistributedDataParallel as DDP
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(a, b, c) = data
if ((a is stub) and (b == '__mul__') and isinstance(c, numbers.Number)):
    return (c, 0.0)
if ((a is stub) and (b == '__add__') and isinstance(c, numbers.Number)):
    return (1.0, c)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
v = getattr(resolved, attr)
name = self.env.add_tmp(v)
return self.term_type(name, self.env)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if (filename is None):
    raise IOError('bad filename')
with open(filename, 'r') as f:
    self.cache = pickle.load(f)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (list(symbolic_weight.shape) == list(array.shape))
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
inputs = self.val_iter.next()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import re
import tensorflow as tf
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex import amp
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"

def param_filter(p):
    'Identify hyper parameters of an estimator.'
    return ((p.name != 'self') and (p.kind != p.VAR_KEYWORD) and (p.kind != p.VAR_POSITIONAL))
init_params = [p for p in signature(init).parameters.values() if param_filter(p)]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0
"
return (isinstance(module.weight, torch.nn.Parameter) and isinstance(module.weight.data, torch.Tensor))
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
model.load_state_dict(weights)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
default[section][keys]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
spacy_model = spacy.load(spacy_model_name, disable=disable)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with open(temp_file_path, 'w'):
    pass
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with open(json_filename, 'r') as fp:
    experiment_data = json.load(fp)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
fn = self.inplace_func([], (x >= y))
v = fn()
self.assertTrue(numpy.all((v == (l >= r))), (v, (l >= r)))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
return legend_handler_map[handle_type]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
batch = next(pseudo_iterator)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import sentencepiece as spm
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
args['momentum'] = float(name[3:])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
entityName = entitiesTrie.longest_prefix(''.join(charStack[:(- 1)]))
entityLength = len(entityName)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import yaml
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
process = subprocess.Popen(binary, stdin=subprocess.PIPE, stdout=subprocess.PIPE)
(response, error) = process.communicate(bytes(message, encoding='utf-8'))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
repo_dpath = dirname(dirname(__file__))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from mmdet.version import __version__
sha = __version__.split('+')[(- 1)]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from fairseq.modules.lightconv_layer import LightconvLayer
return LightconvLayer(input_size, kernel_size=kernel_size, padding_l=padding_l, num_heads=num_heads, weight_dropout=weight_dropout, weight_softmax=weight_softmax, bias=bias)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
n = label_names[i].item()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0
"
if (hasattr(module, 'reset_parameters') and module.is_resetted):
    continue
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
for _ in range(replabel_idx_to_value[token]):
    result.append(prev_token)
prev_token = (- 1)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex.parallel import DistributedDataParallel as DDP
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
pkey = all_keys[id(p)]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from transformers import load_tf2_checkpoint_in_pytorch_model
model = load_tf2_checkpoint_in_pytorch_model(model, resolved_archive_file, allow_missing_keys=True)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
for epoch in range(opt.num_epochs):
    last_epoch = ((step // num_iter_per_epoch) + 1)
    if (epoch < last_epoch):
        continue
    if (epoch in [120, 130]):
        optimizer.param_groups[0]['lr'] = (optimizer.param_groups[0]['lr'] / 10)
    epoch_loss = []
    for (iter, data) in enumerate(training_generator):
        try:
            imgs = data['img']
            annot = data['annot']
            if (params.num_gpus == 1):
                imgs = imgs.cuda()
                for key in annot:
                    annot[key] = annot[key].cuda()
            (union_act_cls_loss, union_sub_reg_loss, union_obj_reg_loss, union_diff_reg_loss, inst_act_cls_loss, inst_obj_cls_loss, inst_obj_reg_loss) = model(imgs, annot['instance'], annot['interaction'])
            union_act_cls_loss = union_act_cls_loss.mean()
            union_sub_reg_loss = union_sub_reg_loss.mean()
            union_obj_reg_loss = union_obj_reg_loss.mean()
            union_diff_reg_loss = union_diff_reg_loss.mean()
            inst_act_cls_loss = inst_act_cls_loss.mean()
            inst_obj_cls_loss = inst_obj_cls_loss.mean()
            inst_obj_reg_loss = inst_obj_reg_loss.mean()
            union_loss = (((union_act_cls_loss + union_sub_reg_loss) + union_obj_reg_loss) + union_diff_reg_loss)
            instance_loss = ((inst_act_cls_loss + inst_obj_cls_loss) + inst_obj_reg_loss)
            loss = (union_loss + inst_act_cls_loss)
            if ((loss == 0) or (not torch.isfinite(loss))):
                continue
            batch_loss = (loss / opt.accumulate_batch)
            batch_loss.backward()
            if ((((iter + 1) % opt.accumulate_batch) == 0) or (iter == (len(training_generator) - 1))):
                optimizer.step()
                optimizer.zero_grad()
                step += 1
            loss = loss.item()
            union_loss = union_loss.item()
            instance_loss = instance_loss.item()
            epoch_loss.append(float(loss))
            current_lr = optimizer.param_groups[0]['lr']
            if ((step % opt.log_interval) == 0):
                writer.add_scalars('Union Action Classification Loss', {'train': union_act_cls_loss}, step)
                writer.add_scalars('Union Subject Regression Loss', {'train': union_sub_reg_loss}, step)
                writer.add_scalars('Union Object Regression Loss', {'train': union_obj_reg_loss}, step)
                writer.add_scalars('Union Diff Regression Loss', {'train': union_diff_reg_loss}, step)
                writer.add_scalars('Instance Action Classification Loss', {'train': inst_act_cls_loss}, step)
                writer.add_scalars('Instance Object Classification Loss', {'train': inst_obj_cls_loss}, step)
                writer.add_scalars('Instance Regression Loss', {'train': inst_obj_reg_loss}, step)
                writer.add_scalars('Total Loss', {'train': loss}, step)
                writer.add_scalars('Union Loss', {'train': union_loss}, step)
                writer.add_scalars('Instance Loss', {'train': instance_loss}, step)
                writer.add_scalar('learning_rate', current_lr, step)
            if ((iter % 20) == 0):
                print('Step: {}. Epoch: {}/{}. Iteration: {}/{}. Union loss: {:.5f}. Instance loss: {:.5f}.   Total loss: {:.5f}. Learning rate: {:.5f}'.format(step, epoch, opt.num_epochs, ((iter + 1) // opt.accumulate_batch), num_iter_per_epoch, union_loss, instance_loss, loss, current_lr))
            if (((step % opt.save_interval) == 0) and (step > 0)):
                save_checkpoint(model, f'efficientdet-d{opt.compound_coef}_{epoch}_{step}.pth')
                print('checkpoint...')
        except Exception as e:
            print('[Error]', traceback.format_exc())
            print(e)
            continue
    if ((epoch % opt.val_interval) == 0):
        union_loss_ls = []
        instance_loss_ls = []
        union_act_cls_loss_ls = []
        union_obj_cls_loss_ls = []
        union_act_reg_loss_ls = []
        union_sub_reg_loss_ls = []
        union_obj_reg_loss_ls = []
        union_diff_reg_loss_ls = []
        inst_act_cls_loss_ls = []
        inst_obj_cls_loss_ls = []
        inst_obj_reg_loss_ls = []
        val_loss = []
        for (iter, data) in enumerate(val_generator):
            if (((iter + 1) % 50) == 0):
                print(('%d/%d' % ((iter + 1), len(val_generator))))
            with torch.no_grad():
                imgs = data['img']
                annot = data['annot']
                if (params.num_gpus == 1):
                    imgs = imgs.cuda()
                    for key in annot:
                        annot[key] = annot[key].cuda()
                (union_act_cls_loss, union_sub_reg_loss, union_obj_reg_loss, union_diff_reg_loss, inst_act_cls_loss, inst_obj_cls_loss, inst_obj_reg_loss) = model(imgs, annot['instance'], annot['interaction'])
                union_act_cls_loss = union_act_cls_loss.mean()
                union_sub_reg_loss = union_sub_reg_loss.mean()
                union_obj_reg_loss = union_obj_reg_loss.mean()
                union_diff_reg_loss = union_diff_reg_loss.mean()
                inst_act_cls_loss = inst_act_cls_loss.mean()
                inst_obj_cls_loss = inst_obj_cls_loss.mean()
                inst_obj_reg_loss = inst_obj_reg_loss.mean()
                union_loss = (((union_act_cls_loss + union_sub_reg_loss) + union_obj_reg_loss) + union_diff_reg_loss)
                instance_loss = ((inst_act_cls_loss + inst_obj_cls_loss) + inst_obj_reg_loss)
                loss = (union_loss + inst_act_cls_loss)
                if ((loss == 0) or (not torch.isfinite(loss))):
                    continue
                val_loss.append(loss.item())
                union_act_cls_loss_ls.append(union_act_cls_loss.item())
                union_sub_reg_loss_ls.append(union_sub_reg_loss.item())
                union_obj_reg_loss_ls.append(union_obj_reg_loss.item())
                union_diff_reg_loss_ls.append(union_diff_reg_loss.item())
                inst_act_cls_loss_ls.append(inst_act_cls_loss.item())
                inst_obj_cls_loss_ls.append(inst_obj_cls_loss.item())
                inst_obj_reg_loss_ls.append(inst_obj_reg_loss.item())
                union_loss_ls.append(union_loss.item())
                instance_loss_ls.append(instance_loss.item())
        union_loss = np.mean(union_loss_ls)
        instance_loss = np.mean(instance_loss_ls)
        union_act_cls_loss = np.mean(union_act_cls_loss_ls)
        union_sub_reg_loss = np.mean(union_sub_reg_loss_ls)
        union_obj_reg_loss = np.mean(union_obj_reg_loss_ls)
        union_diff_reg_loss = np.mean(union_diff_reg_loss_ls)
        inst_act_cls_loss = np.mean(inst_act_cls_loss_ls)
        inst_obj_cls_loss = np.mean(inst_obj_cls_loss_ls)
        inst_obj_reg_loss = np.mean(inst_obj_reg_loss_ls)
        loss = (union_loss + inst_act_cls_loss)
        print('Val. Epoch: {}/{}. Union loss: {:1.5f}. Instance loss: {:1.5f}. Total loss: {:1.5f}'.format(epoch, opt.num_epochs, union_loss, instance_loss, loss))
        writer.add_scalars('Union Action Classification Loss', {'val': union_act_cls_loss}, step)
        writer.add_scalars('Union Subject Regression Loss', {'val': union_sub_reg_loss}, step)
        writer.add_scalars('Union Object Regression Loss', {'val': union_obj_reg_loss}, step)
        writer.add_scalars('Union Diff Regression Loss', {'val': union_diff_reg_loss}, step)
        writer.add_scalars('Instance Action Classification Loss', {'val': inst_act_cls_loss}, step)
        writer.add_scalars('Instance Object Classification Loss', {'val': inst_obj_cls_loss}, step)
        writer.add_scalars('Instance Regression Loss', {'val': inst_obj_reg_loss}, step)
        writer.add_scalars('Total Loss', {'val': loss}, step)
        writer.add_scalars('Union Loss', {'val': union_loss}, step)
        writer.add_scalars('Instance Loss', {'val': instance_loss}, step)
        if ((loss + opt.es_min_delta) < best_loss):
            best_loss = loss
            best_epoch = epoch
            save_checkpoint(model, f'efficientdet-d{opt.compound_coef}_{epoch}_{step}.pth')
        scheduler.step(np.mean(val_loss))
        if (optimizer.param_groups[0]['lr'] < (opt.lr / 100)):
            break
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
args.distributed_rank = distributed_utils.distributed_init(args)
single_process_main(args)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return bpe.is_beginning_of_word(tok)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
constraints = self.get_check_constraints(table_name, schema)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
try:
    return next(self._gen)
except NameError:
    return self._gen.next()
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(x, x2, y) = next(self.iter_ref)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return super(SafeFileCache, self).set(*args, **kwargs)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import unidic_lite
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from sacremoses import MosesTokenizer, MosesDetokenizer
self.tok = MosesTokenizer(args.moses_source_lang)
self.detok = MosesDetokenizer(args.moses_target_lang)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
logging.debug('Try to load dataset as images')
(train_ds, val_ds, test_ds) = image_folder_dataset.load_dataset(dataset_folder, inmem, workers)
(mean, std) = _load_mean_std_from_file(dataset_folder, inmem, workers)
logging.debug('Setting up dataset transforms')
transform = transforms.Compose([transforms.Resize(model_expected_input_size), transforms.ToTensor(), transforms.Normalize(mean=mean, std=std)])
train_ds.transform = transform
val_ds.transform = transform
test_ds.transform = transform
(train_loader, val_loader, test_loader) = _dataloaders_from_datasets(batch_size, train_ds, val_ds, test_ds, workers)
logging.info('Dataset loaded as images')
return (train_loader, val_loader, test_loader, len(train_ds.classes))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
tmp_data[index_id] = self.loc[index_item]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
future_mask = future_mask.bool()
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import numexpr as ne
visualized_image = ne.evaluate('img * (1 - alpha / 255.0) + rgb * (alpha / 255.0)')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import numpy as np
import tensorflow as tf
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.pool.put(conn, block=False)
return
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import re
import numpy as np
import tensorflow as tf
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
for i in range(len(split1)):
    indexes = [int(x) for x in split1[i].strip().lstrip('[').rstrip(']').strip().split(',')]
    if (len(indexes) < 1):
        raise ValueError(('invalid --lstm-delay argument, too-short element: ' + lstm_delay))
    elif ((len(indexes) == 2) and ((indexes[0] * indexes[1]) >= 0)):
        raise ValueError('Warning: {} is not a standard BLSTM mode. There should be a negative delay for the forward, and a postive delay for the backward.'.format(indexes))
    if ((len(indexes) == 2) and (indexes[0] > 0)):
        (indexes[0], indexes[1]) = (indexes[1], indexes[0])
    lstm_delay_array.append(indexes)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
if config.aggressive:
    engine = main_train_agg
else:
    engine = main_train
engine.train(model, train_feed, valid_feed, test_feed, config, evaluator, gen=dialog_utils.generate_with_adv)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
loaded_model = torch.jit.load('traced_model.pt')
os.remove('traced_model.pt')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
float(value)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0
"
from clearml import Task
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
device = torch.device(('cuda' if (cfg.MACHINE.DEVICE == 'gpu') else 'cpu'))
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
if model.config.is_encoder_decoder:
    model.config.use_cache = False
    input_ids = inputs['input_ids']
    attention_mask = inputs['attention_mask']
    decoder_input_ids = inputs['decoder_input_ids']
    decoder_attention_mask = inputs['decoder_attention_mask']
    traced_model = torch.jit.trace(model, (input_ids, attention_mask, decoder_input_ids, decoder_attention_mask))
else:
    input_ids = inputs['input_ids']
    traced_model = torch.jit.trace(model, input_ids)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
while (not done):
    action = agent.act(obs)['action']
    if isinstance(action, torch.Tensor):
        action = action.item()
    (new_obs, reward, done, _) = env.step(action)
    agent.analyze_feedback(reward, done)
    actions.append(action)
    images.append(obs['image'])
    directions.append(obs['direction'])
    obs = new_obs
if ((reward > 0) and ((args.filter_steps == 0) or (len(images) <= args.filter_steps))):
    demos.append((mission, blosc.pack_array(np.array(images)), directions, actions))
    just_crashed = False
if (reward == 0):
    if (args.on_exception == 'crash'):
        raise Exception('mission failed, the seed is {}'.format((seed + len(demos))))
    just_crashed = True
    logger.info('mission failed')
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.img_data = np.load('binarized_notMNIST.npy')
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
import spacy
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
backbone_student_pth = os.path.join(cfg.student_pth, (str(cfg.student_global_step) + 'backbone.pth'))
backbone_student.load_state_dict(torch.load(backbone_student_pth, map_location=torch.device(local_rank)))
if (rank == 0):
    logging.info('backbone student loaded successfully!')
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with winreg.OpenKeyEx(winreg.HKEY_LOCAL_MACHINE, 'Software\\Imagemagick\\Current', 0, (winreg.KEY_QUERY_VALUE | flag)) as hkey:
    binpath = winreg.QueryValueEx(hkey, 'BinPath')[0]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
assert (pointer.shape == array.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
d = cache['vis/cbc_value']
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.scale_activations = self.precision_rule['scale_activations']
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
resolved_archive_file = cached_path(archive_file, cache_dir=cache_dir, force_download=force_download, proxies=proxies, resume_download=resume_download, local_files_only=local_files_only)
if (resolved_archive_file is None):
    raise EnvironmentError
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from .convert_tf_checkpoint_to_pytorch import convert_tf_checkpoint_to_pytorch
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
iter(size)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
import apex_C
flatten_impl = apex_C.flatten
unflatten_impl = apex_C.unflatten
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return im.resize((W2, H2), resample=Image.LANCZOS)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with open(pose_file, 'r') as f:
    lines = f.readlines()
    if (self.frames is not None):
        lines = [lines[i] for i in self.frames]
    for line in lines:
        T_w_cam0 = np.fromstring(line, dtype=float, sep=' ')
        T_w_cam0 = T_w_cam0.reshape(3, 4)
        T_w_cam0 = np.vstack((T_w_cam0, [0, 0, 0, 1]))
        poses.append(torch.from_numpy(T_w_cam0.astype(np.float32)))
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
demo_score = np.mean(expert_model(demo_data_gen.random_training_set_smiles(1000))[1])
baseline_score = np.mean(expert_model(unbiased_data_gen.random_training_set_smiles(1000))[1])
step_idx = Count()
gen_data = (prior_data_gen if is_pretraining else demo_data_gen)
with TBMeanTracker(tb_writer, 1) as tracker:
    mode = ('Pretraining' if is_pretraining else 'Fine tuning')
    n_epochs = 30
    for epoch in range(n_epochs):
        epoch_losses = []
        epoch_mean_preds = []
        epoch_per_valid = []
        with grad_stats:
            for b in trange(0, num_batches, desc=f'Epoch {(epoch + 1)}/{n_epochs}, {mode} in progress...'):
                (inputs, labels) = gen_data.random_training_set()
                optimizer.zero_grad()
                predictions = generator(inputs)[0]
                predictions = predictions.permute(1, 0, (- 1))
                predictions = predictions.contiguous().view((- 1), predictions.shape[(- 1)])
                labels = labels.contiguous().view((- 1))
                loss = criterion(predictions, labels)
                epoch_losses.append(loss.item())
                loss.backward()
                if grad_clipping:
                    torch.nn.utils.clip_grad_norm_(generator.parameters(), grad_clipping)
                optimizer.step()
                n_to_generate = 200
                with torch.set_grad_enabled(False):
                    samples = generate_smiles(generator, demo_data_gen, rnn_args, num_samples=n_to_generate, max_len=smiles_max_len)
                samples_pred = expert_model(samples)[1]
                eval_dict = {}
                eval_score = RNNBaseline.evaluate(eval_dict, samples, demo_data_gen.random_training_set_smiles(1000))
                tracker.track('loss', loss.item(), step_idx.IncAndGet())
                for k in eval_dict:
                    tracker.track(f'{k}', eval_dict[k], step_idx.i)
                mean_preds = np.mean(samples_pred)
                epoch_mean_preds.append(mean_preds)
                per_valid = (len(samples_pred) / n_to_generate)
                epoch_per_valid.append(per_valid)
                if (exp_type == 'drd2'):
                    per_qualified = (float(len([v for v in samples_pred if (v >= 0.8)])) / len(samples_pred))
                    score = mean_preds
                elif (exp_type == 'logp'):
                    per_qualified = (np.sum(((samples_pred >= 1.0) & (samples_pred < 5.0))) / len(samples_pred))
                    score = mean_preds
                elif (exp_type == 'jak2_max'):
                    per_qualified = (np.sum((samples_pred >= demo_score)) / len(samples_pred))
                    diff = (mean_preds - demo_score)
                    score = np.exp(diff)
                elif (exp_type == 'jak2_min'):
                    per_qualified = (np.sum((samples_pred <= demo_score)) / len(samples_pred))
                    diff = (demo_score - mean_preds)
                    score = np.exp(diff)
                else:
                    score = per_valid
                    per_qualified = 0.0
                unbiased_smiles_mean_pred.append(float(baseline_score))
                biased_smiles_mean_pred.append(float(demo_score))
                gen_smiles_mean_pred.append(float(mean_preds))
                tb_writer.add_scalars('qsar_score', {'sampled': mean_preds, 'baseline': baseline_score, 'demo_data': demo_score}, step_idx.i)
                tb_writer.add_scalars('SMILES stats', {'per. of valid': per_valid, 'per. of qualified': per_qualified}, step_idx.i)
                avg_len = np.nanmean([len(s) for s in samples])
                tracker.track('Average SMILES length', avg_len, step_idx.i)
                score_exp_avg.update(score)
                if (score_exp_avg.value > best_score):
                    best_model_wts = copy.deepcopy(generator.state_dict())
                    best_score = score_exp_avg.value
                    best_epoch = epoch
                if ((step_idx.i > 0) and ((step_idx.i % 1000) == 0)):
                    smiles = generate_smiles(generator=generator, gen_data=gen_data, init_args=rnn_args, num_samples=3, max_len=smiles_max_len)
                    print(f'Sample SMILES = {smiles}')
            print(f'{time_since(start)}: Epoch {(epoch + 1)}/{n_epochs}, loss={np.mean(epoch_losses)},Mean value of predictions = {np.mean(epoch_mean_preds)}, % of valid SMILES = {np.mean(epoch_per_valid)}')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from apex import amp
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
Ntotal = ary.shape[axis]
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
iter_time = storage.history('time').global_avg()
eta_seconds = (storage.history('time').median(1000) * ((self._max_iter - iteration) - 1))
storage.put_scalar('eta_seconds', eta_seconds, smoothing_hint=False)
eta_string = str(datetime.timedelta(seconds=int(eta_seconds)))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
cmd = cls.rgetattr(cls, cmd)
return cmd(*args, **kwargs)
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
for (k, v) in train_ctx.metrics.items():
    if isinstance(v, (int, float)):
        if ctx.vis.win_exists(k):
            ctx.vis.line(X=np.array([train_ctx.epoch_idx]), Y=np.array([v]), opts=dict(title=k, xlabel='epoch'), win=k, update='append')
        else:
            ctx.vis.line(X=np.array([train_ctx.epoch_idx]), Y=np.array([v]), opts=dict(title=k, xlabel='epoch'), win=k)
ctx.vis.save([env])
",0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
new[alg] += values
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return int(s)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
shutil.copy2(file_path, task_directory_path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
x_train = x_train.astype('float64')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
f = DatasetCatalog._REGISTERED[name]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
with _io.FileIO(fd, 'wb') as file:
    file.write(data)
_os.replace(path_tmp, path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
tokenizer = cls(*init_inputs, **init_kwargs)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
while (vid.isOpened() and running):
    while (frame_buffer.qsize() > 100):
        time.sleep(0.001)
    start_time = time.time()
    if (not vid_done):
        next_frames = pool.apply_async(get_next_frame, args=(vid,))
    else:
        next_frames = None
    if (not (vid_done and (len(active_frames) == 0))):
        for frame in active_frames:
            _args = [frame['value']]
            if (frame['idx'] == 0):
                _args.append(fps_str)
            frame['value'] = pool.apply_async(sequence[frame['idx']], args=_args)
        for frame in active_frames:
            if (frame['idx'] == 0):
                frame_buffer.put(frame['value'].get())
        active_frames = [x for x in active_frames if (x['idx'] > 0)]
        for frame in list(reversed(active_frames)):
            frame['value'] = frame['value'].get()
            frame['idx'] -= 1
            if (frame['idx'] == 0):
                active_frames += [{'value': extract_frame(frame['value'], i), 'idx': 0} for i in range(1, len(frame['value'][0]))]
                frame['value'] = extract_frame(frame['value'], 0)
        if (next_frames is not None):
            frames = next_frames.get()
            if (len(frames) == 0):
                vid_done = True
            else:
                active_frames.append({'value': frames, 'idx': (len(sequence) - 1)})
        frame_times.add((time.time() - start_time))
        fps = (args.video_multiframe / frame_times.get_avg())
    else:
        fps = 0
    fps_str = ('Processing FPS: %.2f | Video Playback FPS: %.2f | Frames in Buffer: %d' % (fps, video_fps, frame_buffer.qsize()))
    if (not args.display_fps):
        print((('\r' + fps_str) + '    '), end='')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
return accimage.Image(path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
r._next = next(self.resolve_redirects(r, request, yield_requests=True, **kwargs))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
"
from fairseq.modules.lightconv_layer import LightconvLayer
return LightconvLayer(input_size, kernel_size=kernel_size, padding_l=padding_l, num_heads=num_heads, weight_dropout=weight_dropout, weight_softmax=weight_softmax, bias=bias)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
out_string = subprocess.check_output(['gcc', '-dumpversion'])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
ret.pred_masks = [predictions[i]['segmentation'] for i in chosen]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(line, field) = line.rstrip().rsplit(' ', 1)
if (field == '#fairseq:overwrite'):
    overwrite = True
    (line, field) = line.rsplit(' ', 1)
else:
    overwrite = False
count = int(field)
word = line
if ((word in self) and (not overwrite)):
    raise RuntimeError(""Duplicate word found when loading Dictionary: '{}'. Duplicate words can overwrite earlier ones by adding the #fairseq:overwrite flag at the end of the corresponding row in the dictionary file. If using the Camembert model, please download an updated copy of the model file."".format(word))
self.add_symbol(word, n=count, overwrite=overwrite)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
assert (pointer.shape == array.shape)
",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
named_index = np.ix_(full_identifiers, column_index)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
context = ' '.join(dp['captions'])
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
return ((float(self.num_incorrect_words) * 100.0) / self.num_words)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1
"
return [self.protocol_parser[x] for x in filenames]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
self.link_executable(objects, 'a.out', libraries=libraries, library_dirs=library_dirs)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
"
os.remove(last_snapshot)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
nice = self.__nice__()
classname = self.__class__.__name__
return '<{0}({1}) at {2}>'.format(classname, nice, hex(id(self)))
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
(datestring, timestring) = datetimestring.split('T')
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
"
target = self._cache[_hashable(x)]
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"
os.makedirs(path)
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
